# 模組 02：程式編譯與執行

> 從 C 原始碼到可執行檔：理解編譯流程與 Makefile

---

## 📌 學習目標

完成本模組後，你將能夠：
- ✅ 理解從原始碼到可執行檔的完整流程
- ✅ 認識 GCC 工具鏈（編譯器、連結器）
- ✅ 學會使用 Makefile 自動化編譯
- ✅ 了解交叉編譯的概念
- ✅ 實際操作專案的編譯系統

**對應專案檔案**：
- [`makedefs`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/makedefs)
- [`examples/uart_hello_world/Makefile`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/Makefile)
- [`examples/arm_fir_example/Makefile`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/arm_fir_example/Makefile)

---

## 1. 編譯流程概覽

### 1.1 從原始碼到執行檔

**問題：電腦為什麼不能直接執行我寫的 C 語言程式？**

想像一下：
- 你寫的 C 語言程式碼 → 就像是用中文寫的食譜
- 電腦的 CPU → 就像是只會看圖片料理步驟的廚師
- **編譯** → 就是把中文食譜翻譯成圖片步驟的過程

所以我們需要「編譯」這個翻譯過程！

---

### 🔄 編譯流程全貌（先看大圖）

```
你寫的程式           經過編譯器            電腦能執行的程式
    ↓                   ↓                      ↓
uart_hello_world.c  →  [4個步驟]  →  uart_hello_world.bin
  (中文食譜)           (翻譯過程)         (圖片步驟)
```

這 4 個步驟是：

```
┌────────────────────────────────────────────────────────────┐
│                                                              │
│  步驟 1: 預處理 = 複製貼上                                    │
│  ────────────────────────                                   │
│  把 #include 的檔案內容複製進來                               │
│  把 #define 的東西做文字取代                                  │
│                                                              │
│  uart_hello_world.c                                         │
│  (你寫的程式)                                                 │
│       ↓                                                      │
│  uart_hello_world.i                                         │
│  (複製貼上後的完整版)                                          │
│                                                              │
├────────────────────────────────────────────────────────────┤
│                                                              │
│  步驟 2: 編譯 = 翻譯成組合語言                                │
│  ──────────────────────────                                 │
│  把 C 語言翻譯成接近機器碼的簡單指令                            │
│                                                              │
│  uart_hello_world.i                                         │
│       ↓                                                      │
│  uart_hello_world.s                                         │
│  (ARM 組合語言 - 人類勉強看得懂的機器指令)                      │
│                                                              │
├────────────────────────────────────────────────────────────┤
│                                                              │
│  步驟 3: 組譯 = 翻譯成 0 和 1                                 │
│  ─────────────────────────                                  │
│  把組合語言翻譯成真正的 0 和 1                                 │
│                                                              │
│  uart_hello_world.s                                         │
│       ↓                                                      │
│  uart_hello_world.o                                         │
│  (二進位檔 - 只有 0 和 1，但還不完整)                          │
│                                                              │
├────────────────────────────────────────────────────────────┤
│                                                              │
│  步驟 4: 連結 = 組裝拼圖                                      │
│  ────────────────────                                        │
│  把多個 .o 檔案拼在一起，變成完整程式                           │
│                                                              │
│  uart_hello_world.o + startup.o + system.o                 │
│       ↓                                                      │
│  uart_hello_world.bin                                       │
│  (完整的程式，可以放進晶片執行)                                 │
│                                                              │
└────────────────────────────────────────────────────────────┘
```

---

## 📖 四個階段詳細說明

現在讓我們一個一個看懂每個步驟！

---

### 🔹 階段 1: 預處理 = 複製貼上機器人

**這個階段在做什麼？**

想像你在寫作文，你寫了：
```
（插入我昨天寫的開頭段落）
主要內容...
```

預處理器就像是幫你把「昨天寫的開頭段落」真的複製過來貼上的助手！

---

#### 🔸 實際例子：看看預處理做了什麼

**你寫的程式（`uart_hello_world.c`）：**
```c
#include <stdint.h>     ← 「去拿 stdint.h 的內容複製過來」
#define LED_PIN 5       ← 「把所有 LED_PIN 換成 5」

int main() {
    int pin = LED_PIN;  ← 這裡有 LED_PIN
    ...
}
```

**預處理後（`uart_hello_world.i`）：**
```c
// stdint.h 的內容全部被貼在這裡（可能有 3000 行！）
typedef unsigned int uint32_t;
typedef signed int int32_t;
typedef unsigned short uint16_t;
... (還有很多行)

int main() {
    int pin = 5;        ← LED_PIN 被換成 5 了！
    ...
}
```

---

#### 🔸 專業術語解釋（白話版）

**`#include <stdint.h>` 是什麼意思？**

```
#include          = 「包含」= 把另一個檔案的內容複製過來
<stdint.h>        = 檔案名稱
  <...>           = 用角括號 → 表示這是系統提供的檔案
  "..."           = 用引號 → 表示這是你自己寫的檔案

範例：
#include <stdint.h>      ← 系統的檔案
#include "my_config.h"   ← 我自己寫的檔案
```

**stdint.h 裡面有什麼？為什麼需要它？**

問題：C 語言的 `int` 大小不固定！
- 在某些電腦上，`int` = 16 bits（可以存 -32768 ~ 32767）
- 在某些電腦上，`int` = 32 bits（可以存 -2147483648 ~ 2147483647）

這樣很容易出錯！所以 `stdint.h` 提供了固定大小的型別：
```c
uint8_t   → 保證是 8 bits 的無號整數 (0 ~ 255)
uint16_t  → 保證是 16 bits 的無號整數 (0 ~ 65535)
uint32_t  → 保證是 32 bits 的無號整數 (0 ~ 4294967295)
int32_t   → 保證是 32 bits 的有號整數 (-2147483648 ~ 2147483647)
```

**`#define LED_PIN 5` 是什麼意思？**

這叫做「巨集」（Macro），就是「文字取代」的規則：

```
步驟 1: 你寫
#define LED_PIN 5

步驟 2: 預處理器會在你的程式裡搜尋所有 LED_PIN

步驟 3: 把每個 LED_PIN 都換成 5
```

**實際例子：**
```c
// 你寫的：
#define MAX_STUDENTS 30

int class_size = MAX_STUDENTS;
int exam_scores[MAX_STUDENTS];

// 預處理後：
int class_size = 30;
int exam_scores[30];
```

**為什麼要用 #define？直接寫 5 不行嗎？**

比較一下：

**不用 #define（不好）：**
```c
int led_pin = 5;
int gpio_config = 5;
int default_state = 5;
// ... 程式裡有 100 個地方寫了 5

// 如果 LED 改到第 7 號腳位，你要改 100 個地方！😱
```

**用 #define（好）：**
```c
#define LED_PIN 5

int led_pin = LED_PIN;
int gpio_config = LED_PIN;
int default_state = LED_PIN;
// ... 程式裡有 100 個地方用 LED_PIN

// 如果 LED 改到第 7 號腳位，只要改一個地方！😊
#define LED_PIN 7  ← 只改這一行，全部都變 7 了！
```

---

#### 🔸 預處理器做的 4 件事（總結）

```
┌─────────────────────────────────────────────────────┐
│                                                       │
│  1️⃣ 複製 #include 的檔案                             │
│     #include <stdio.h>  →  把 stdio.h 全部貼進來     │
│                                                       │
│  2️⃣ 替換 #define 的文字                              │
│     #define PI 3.14  →  把所有 PI 換成 3.14          │
│                                                       │
│  3️⃣ 處理 #ifdef（條件編譯）                          │
│     #ifdef DEBUG  →  如果有定義 DEBUG 就保留這段     │
│                                                       │
│  4️⃣ 刪除所有註解                                     │
│     // 這是註解  →  刪掉！編譯器不需要看註解          │
│                                                       │
└─────────────────────────────────────────────────────┘
```

**條件編譯例子（#ifdef）：**

這個功能很酷！可以讓同一份程式碼，編譯出不同版本：

```c
// 你寫的程式：
#ifdef DEBUG
    printf("除錯訊息：變數 x = %d\n", x);  ← 只有除錯版才有
#endif

printf("正常訊息\n");  ← 所有版本都有

// 如果編譯時定義了 DEBUG：
// gcc -D DEBUG ...
// 預處理後會保留 printf("除錯訊息...")

// 如果編譯時沒定義 DEBUG：
// gcc ...
// 預處理後會刪除 printf("除錯訊息...")
```

**檔案大小對比：**

```
uart_hello_world.c    ← 你寫的           50 行
uart_hello_world.i    ← 預處理後       3500 行（多了 #include 的內容）
```

---

### 🔹 階段 2: 編譯 = 翻譯成簡單指令

**這個階段在做什麼？**

想像你要教一個 5 歲小孩做蛋糕：
- C 語言 → 「把材料混合均勻」（抽象的描述）
- 組合語言 → 「拿攪拌器、放入碗中、按開關、攪拌 30 秒」（具體的步驟）

編譯器就是把「抽象的 C 語言」翻譯成「具體的簡單指令」！

---

#### 🔸 實際例子：看看 C 語言如何變成組合語言

**C 語言（你寫的）：**
```c
int add(int a, int b) {
    return a + b;
}
```

**ARM 組合語言（編譯後）：**
```assembly
add:
    ADD r0, r0, r1    ← 把 r0 和 r1 加起來，結果放回 r0
    BX  lr            ← 返回
```

這就像是：
```
C 語言：   「把 a 和 b 加起來」
組合語言： 「把抽屜0 和 抽屜1 的東西加起來，放回抽屜0」
```

---

#### 🔸 組合語言的基本概念

**什麼是暫存器（Register）？**

CPU 裡面有很多小抽屜，叫做「暫存器」，用來暫時存放資料：

```
┌──────────────────────────────────────┐
│      CPU 的小抽屜（暫存器）            │
│                                        │
│  r0 [ 5      ]  ← 抽屜 0 放了數字 5   │
│  r1 [ 10     ]  ← 抽屜 1 放了數字 10  │
│  r2 [ 15     ]  ← 抽屜 2 放了數字 15  │
│  r3 [        ]  ← 抽屜 3 是空的       │
│  ...                                   │
│  r12[        ]                         │
│  lr [ 0x1234 ]  ← 特殊抽屜：記住回去的路 │
│  sp [ 0x2000 ]  ← 特殊抽屜：堆疊位址   │
│                                        │
└──────────────────────────────────────┘
```

**常見的組合語言指令（白話解釋）：**

```
MOV r0, #5         →  「把數字 5 放進抽屜 r0」
                       r0 = 5

ADD r0, r1, r2     →  「把 r1 和 r2 加起來，結果放進 r0」
                       r0 = r1 + r2

SUB r0, r1, r2     →  「把 r1 減去 r2，結果放進 r0」
                       r0 = r1 - r2

BL print_uart0     →  「跳去執行 print_uart0 函式，記得回來的路」
                       print_uart0();

BX lr              →  「按照 lr 記住的路返回」
                       return;
```

---

#### 🔸 實際翻譯例子

**C 語言：**
```c
int x = 10;
int y = 20;
int z = x + y;
```

**對應的組合語言：**
```assembly
MOV r0, #10        ; r0 = 10  (這是 x)
MOV r1, #20        ; r1 = 20  (這是 y)
ADD r2, r0, r1     ; r2 = r0 + r1 = 30  (這是 z)
```

看！很簡單吧！組合語言就是把每個動作拆得很細：
- C 語言一行可以做很多事
- 組合語言一行只做一件很簡單的事

---

### 🔹 階段 3: 組譯 = 翻譯成 0 和 1

**這個階段在做什麼？**

想像你在翻譯摩斯密碼：
- 組合語言 → 「A」、「B」、「C」（人類看得懂的字母）
- 機器碼 → 「·−」、「−···」、「−·−·」（點和線的密碼）

組譯器就是把「人類看得懂的指令」翻譯成「CPU 看得懂的 0 和 1」！

---

#### 🔸 實際例子：組合語言變成 0 和 1

**組合語言：**
```assembly
MOV r0, #5         ← 人類勉強看得懂
ADD r0, r0, r1     ← 「把 r0 和 r1 加起來」
```

**機器碼（十六進位表示）：**
```
20 05              ← MOV r0, #5 變成這兩個 bytes
44 08              ← ADD r0, r0, r1 變成這兩個 bytes
```

**機器碼（二進位表示，CPU 真正看的）：**
```
00100000 00000101  ← MOV r0, #5 (純粹的 0 和 1)
01000100 00001000  ← ADD r0, r0, r1
```

CPU 只看得懂 0 和 1！

---

#### 🔸 .o 檔案裡有什麼？

`.o` 檔案（Object File）是「半成品」，包含：

```
┌─────────────────────────────────────────┐
│  uart_hello_world.o (目標檔)             │
│                                           │
│  1️⃣ 機器碼（0 和 1）                     │
│     00100000 00000101 01000100 ...       │
│     ↑ 這些是 CPU 的指令                  │
│                                           │
│  2️⃣ 符號表（記錄函式名稱和位址）          │
│     main         → 位址 0x0000           │
│     print_uart0  → 位址 ??? (還不知道)    │
│     ↑ 有些函式在別的檔案，還不知道位址     │
│                                           │
│  3️⃣ 待修正清單                           │
│     「記得連結時要修正 print_uart0 的位址」│
│                                           │
└─────────────────────────────────────────┘
```

**為什麼 .o 檔還不能執行？**

```
想像拼拼圖：

uart_hello_world.o   →  拼圖的一塊
startup.o            →  拼圖的另一塊
system.o             →  拼圖的第三塊

現在每一塊都做好了（都是 0 和 1 了）
但還沒拼起來！所以不是完整的圖案！

需要「連結器」把它們拼起來！
```

---

### 🔹 階段 4: 連結 = 拼裝拼圖

**這個階段在做什麼？**

想像你在拼拼圖：
- 每個 .o 檔案 → 拼圖的一塊
- 連結器 → 把拼圖拼起來的人
- 最終的 .bin 檔 → 完整的拼圖

連結器的工作就是把所有拼圖塊（.o 檔案）拼成一幅完整的圖畫（可執行程式）！

---

#### 🔸 實際例子：看看連結器如何拼裝

**你的專案有這些檔案：**

```
┌─────────────────────────────────────────────────┐
│                                                   │
│  uart_hello_world.o  ← 你的主程式                 │
│  • 有 main 函式                                   │
│  • 呼叫了 print_uart0 (但不知道在哪裡)            │
│                                                   │
│  startup.o           ← 啟動程式碼                 │
│  • 有 Reset_Handler 函式                          │
│  • 負責一開機時的初始化                            │
│                                                   │
│  system.o            ← 系統設定                   │
│  • 有 SystemInit 函式                             │
│  • 有 print_uart0 函式 ← 在這裡！                 │
│                                                   │
└─────────────────────────────────────────────────┘
```

**連結器做的事：**

```
步驟 1: 把所有 .o 檔案收集起來
  uart_hello_world.o + startup.o + system.o

步驟 2: 解決「不知道在哪裡」的問題
  uart_hello_world.o 說:「我要用 print_uart0，但不知道在哪」
  連結器找到：「print_uart0 在 system.o 的位址 0x1234」
  連結器修正：「好，我幫你填上 0x1234」

步驟 3: 決定每個東西的位址
  main         → 放在 0x0000
  print_uart0  → 放在 0x1234
  SystemInit   → 放在 0x2000

步驟 4: 全部合併成一個檔案
  = uart_hello_world.axf (完整程式)
```

---

#### 🔸 兩種檔案格式

連結後會產生兩種檔案：

**uart_hello_world.axf (給除錯用)：**
```
┌──────────────────────────────────────┐
│  uart_hello_world.axf (7.3 KB)       │
│                                        │
│  📦 機器碼 (程式本身)          400 B  │
│  📝 除錯符號 (函式名稱、行號)  6 KB   │
│  📋 其他資訊 (段落資訊等)      900 B  │
│                                        │
│  優點: GDB 除錯時看得到變數名稱       │
│  缺點: 檔案大                          │
│  用途: 用 GDB 除錯時使用               │
│                                        │
└──────────────────────────────────────┘
```

**uart_hello_world.bin (給晶片用)：**
```
┌──────────────────────────────────────┐
│  uart_hello_world.bin (423 B)        │
│                                        │
│  📦 機器碼 (純粹的 0 和 1)     423 B  │
│                                        │
│  優點: 檔案最小，可以直接燒進晶片      │
│  缺點: 沒有除錯資訊                    │
│  用途: 燒進晶片或給 QEMU 執行          │
│                                        │
└──────────────────────────────────────┘
```

**簡單比較：**

```
uart_hello_world.axf (7.3 KB)
  = 機器碼 + 除錯資訊 + 其他資訊
  → 就像是「有字幕的電影」

uart_hello_world.bin (423 B)
  = 純粹的機器碼
  → 就像是「沒有字幕的電影」
```

---

#### 🔸 完整流程總結

```
你寫的程式
   ↓
uart_hello_world.c (50 行)
   ↓ [預處理] 複製貼上
uart_hello_world.i (3500 行)
   ↓ [編譯] 翻譯成簡單指令
uart_hello_world.s (組合語言)
   ↓ [組譯] 翻譯成 0 和 1
uart_hello_world.o (半成品)
   ↓ [連結] 拼裝拼圖
uart_hello_world.axf (7.3 KB，有除錯資訊)
   ↓ [轉換格式]
uart_hello_world.bin (423 B，純機器碼)
   ↓
放進晶片執行！🎉
```

---

### 1.2 專案實際編譯產物

以 UART 範例為例，編譯後會產生：

```bash
examples/uart_hello_world/gcc/
├── uart_hello_world.o          # 主程式目標檔
├── startup_gcc.o                # 啟動程式碼目標檔
├── system_lm3s.o                # 系統初始化目標檔
├── uart_hello_world.d           # 依賴檔案
├── startup_gcc.d
├── system_lm3s.d
├── uart_hello_world.axf         # ELF 可執行檔 (7.3 KB)
└── uart_hello_world.bin         # 二進位檔 (423 Bytes)
```

檔案大小差異：
```
uart_hello_world.axf   7.3 KB    ← 包含符號表、除錯資訊
uart_hello_world.bin   423 B     ← 純程式碼與資料
```

---

## 2. GCC 工具鏈（一組好用的工具）

### 2.1 什麼是工具鏈？

想像你要蓋房子，需要一整套工具：

```
蓋房子需要的工具           →    編譯程式需要的工具
────────────────                ─────────────────
🔨 榔頭                          gcc (編譯器)
🔧 螺絲起子                      ld (連結器)
🪚 鋸子                          objcopy (轉換工具)
📏 捲尺                          gdb (除錯器)
```

「工具鏈」就是一整套工具的集合！在我們的專案中，這套工具叫做「GCC ARM 工具鏈」。

---

### 2.2 主要的 5 個工具

```
┌─────────────────────────────────────────────────┐
│                                                   │
│  1️⃣ arm-none-eabi-gcc  (編譯器)                 │
│     工作: 把 C 語言翻譯成機器碼                   │
│     就像: 翻譯機                                  │
│                                                   │
│  2️⃣ arm-none-eabi-ld   (連結器)                 │
│     工作: 把多個檔案拼起來                        │
│     就像: 拼圖師傅                                │
│                                                   │
│  3️⃣ arm-none-eabi-objcopy  (格式轉換)           │
│     工作: 把 .axf 轉成 .bin                       │
│     就像: 格式轉換器（Word → PDF）                │
│                                                   │
│  4️⃣ arm-none-eabi-ar   (打包工具)               │
│     工作: 把多個 .o 打包成函式庫                  │
│     就像: 壓縮軟體（把檔案打包成 .zip）           │
│                                                   │
│  5️⃣ arm-none-eabi-gdb  (除錯器)                 │
│     工作: 找程式的 bug                            │
│     就像: 偵探（找出問題在哪裡）                  │
│                                                   │
└─────────────────────────────────────────────────┘
```

---

### 2.3 交叉編譯（為什麼要用特殊的編譯器？）

**arm-none-eabi-gcc** = **ARM 交叉編譯器**
- **arm**: 目標架構是 ARM 處理器
- **none**: 沒有作業系統 (bare-metal / 裸機)
- **eabi**: Embedded Application Binary Interface (嵌入式應用程式二進位介面)
- **gcc**: GNU C Compiler

**編譯器 (Compiler)** = **將高階語言翻譯成低階語言的程式**
- **輸入**: C 語言原始碼
- **輸出**: 組合語言或機器碼
- **過程**: 語法分析 → 語意分析 → 最佳化 → 程式碼生成

**將 C 編譯成組合語言**
- **命令**: `gcc -S source.c`
- **輸出**: `source.s` (ARM 組合語言)
- **用途**: 想要檢查編譯器產生的組合語言時使用

**將組合語言組譯成機器碼**
- **命令**: `gcc -c source.c` 或 `gcc -c source.s`
- **輸出**: `source.o` (ELF 目標檔)
- **組譯 (Assemble)**: 將組合語言的助記符號 (如 MOV, PUSH) 翻譯成二進位機器碼
- **範例**:
  ```
  MOV r0, #5    →  0x2005  (機器碼)
  PUSH {r4,lr}  →  0xB530  (機器碼)
  ```

#### 工具 2: arm-none-eabi-ld (連結器)

**arm-none-eabi-ld** = **ARM 連結器**
- **ld**: Linker (連結器)
- **作用**: 將多個 .o 檔案組合成一個可執行檔

**連結器 (Linker)** = **程式碼的組裝工**
- **輸入**: 多個 `.o` 檔案 + 函式庫 (`.a` 或 `.so`)
- **輸出**: 可執行檔 (`.axf` / `.elf`)
- **類比**: 像是拼圖師傅，把各個拼圖 (.o 檔案) 組合成完整的圖畫 (可執行檔)

**連結多個 .o 檔案**
- **為什麼需要**: 一個專案通常有多個 .c 檔案，編譯後產生多個 .o 檔案
- **範例**:
  ```
  main.o          (main 函式)
  + uart.o        (UART 函式)
  + startup.o     (啟動程式碼)
  ─────────────
  = program.axf   (完整程式)
  ```
- **連結過程**: 解析所有函式呼叫，將它們指向正確的位址

**連結函式庫**
- **函式庫 (Library)**: 預先編譯好的函式集合
- **三個重要函式庫**:

  1. **libc** = **C 標準函式庫**
     - **提供**: printf, malloc, strcpy, memcpy 等標準函式
     - **檔案**: libc.a (靜態連結) 或 libc.so (動態連結)
     - **必要性**: 幾乎所有 C 程式都需要

  2. **libm** = **數學函式庫**
     - **m**: Math (數學)
     - **提供**: sin, cos, sqrt, pow, log 等數學函式
     - **使用**: 編譯時加 `-lm` 參數

  3. **libgcc** = **GCC 支援函式庫**
     - **提供**: 編譯器內建函式
     - **範例**: 64-bit 整數除法 (ARM Cortex-M3 沒有硬體 64-bit 除法)
     - **自動連結**: 通常不需要手動指定

**產生可執行檔**
- **可執行檔**: 包含所有程式碼、資料，可以直接執行的檔案
- **格式**: ELF (Executable and Linkable Format)
- **內容**:
  - 機器碼 (所有 .o 合併後)
  - 初始化資料 (.data 段的初始值)
  - 除錯符號 (函式名稱、變數名稱、行號)
  - 段落資訊 (.text, .data, .bss 的位址和大小)

#### 工具 3: arm-none-eabi-objcopy (格式轉換工具)

**arm-none-eabi-objcopy** = **目標檔格式轉換工具**
- **obj**: Object (目標檔)
- **copy**: 複製 (實際上是轉換格式)
- **作用**: 在不同檔案格式之間轉換

**格式轉換工具** = **檔案格式翻譯機**
- **輸入**: 一種格式的檔案
- **輸出**: 另一種格式的檔案
- **內容**: 程式碼和資料相同，只是包裝方式不同

**從 .axf (ELF) 轉成 .bin**
- **命令**: `objcopy -O binary program.axf program.bin`
- **-O binary**: Output format = binary (輸出格式 = 純二進位)
- **用途**: 燒錄到 Flash、QEMU 執行
- **轉換過程**:
  ```
  program.axf (7.3 KB)
    • 機器碼: 400 bytes
    • 除錯符號: 6 KB
    • ELF 標頭: 900 bytes
    ↓ objcopy 移除 metadata
  program.bin (400 bytes)
    • 只剩純機器碼和資料
  ```

**從 .axf 轉成 .hex (Intel HEX)**
- **命令**: `objcopy -O ihex program.axf program.hex`
- **Intel HEX**: 一種文字格式的韌體檔案
- **特色**:
  - 文字檔 (可以用文字編輯器開啟)
  - 每行包含位址和資料
  - 有校驗和 (Checksum)
- **用途**: 某些燒錄工具要求 .hex 格式
- **範例**:
  ```
  :10000000C0200000C1000000C3000000C5000000E6
  :10001000C7000000C9000000CB000000CD00000066
  :00000001FF
  ```
  - `:10` = 16 bytes 資料
  - `0000` = 位址
  - `00` = 資料類型
  - `C0200000...` = 資料內容
  - `E6` = 校驗和

#### 工具 4: arm-none-eabi-ar (函式庫工具)

**arm-none-eabi-ar** = **靜態函式庫建立工具**
- **ar**: Archive (封存)
- **作用**: 將多個 .o 檔案打包成一個 .a 函式庫檔案

**函式庫工具** = **目標檔打包機**
- **輸入**: 多個 `.o` 檔案
- **輸出**: 一個 `.a` 函式庫檔案
- **類比**: 像是把多本書 (.o) 裝訂成一本合集 (.a)

**建立靜態函式庫 (.a)**
- **靜態函式庫**: 編譯時就連結到可執行檔中
- **副檔名**: `.a` (Archive)
- **命令**: `ar rcs libmylib.a file1.o file2.o file3.o`
  - **r**: Replace (替換，如果已存在就替換)
  - **c**: Create (建立，如果不存在就建立)
  - **s**: 建立索引 (加速連結)
- **命名規則**: `lib<名稱>.a`
  - **範例**: libmath.a, libc.a
  - **連結時**: 用 `-lmath` (省略 lib 和 .a)

**使用靜態函式庫**:
```bash
# 建立函式庫
ar rcs libmymath.a add.o subtract.o multiply.o

# 編譯時連結
gcc main.c -L. -lmymath -o program
#           ↑   ↑
#           |   └─ 連結 libmymath.a
#           └─ 函式庫搜尋路徑是當前目錄
```

**靜態 vs 動態函式庫**:
```
靜態函式庫 (.a):
  ✓ 連結時複製到可執行檔中
  ✓ 可執行檔可以獨立執行 (不需要 .a 檔案)
  ✗ 可執行檔較大
  ✓ 適合: 嵌入式系統 (只有一個可執行檔)

動態函式庫 (.so / .dll):
  ✓ 執行時才載入
  ✓ 可執行檔較小
  ✓ 多個程式可共用同一個函式庫
  ✗ 執行時需要 .so 檔案
  ✓ 適合: 桌面系統
```

#### 工具 5: arm-none-eabi-gdb (除錯器)

**arm-none-eabi-gdb** = **ARM 除錯器**
- **gdb**: GNU Debugger (GNU 除錯器)
- **作用**: 單步執行、檢查變數、設定中斷點

**除錯器 (Debugger)** = **程式檢查工具**
- **功能**:
  - 單步執行 (Step)
  - 設定中斷點 (Breakpoint)
  - 檢查變數值 (Print)
  - 檢查記憶體 (Examine)
  - 查看呼叫堆疊 (Backtrace)
- **使用時機**: 程式有 bug，需要找出問題原因

**除錯 ARM 程式**
- **遠端除錯**: GDB 在電腦上執行，透過網路連接到 QEMU 或實體硬體
- **連接方式**:
  ```bash
  # 啟動 QEMU (提供 GDB server)
  qemu-system-arm -M lm3s6965evb -kernel program.bin -s -S
  #                                                     ↑  ↑
  #                                                     |  └─ 啟動時暫停
  #                                                     └─ 開啟 GDB server (port 1234)

  # 啟動 GDB
  arm-none-eabi-gdb program.axf
  (gdb) target remote localhost:1234  # 連接到 QEMU
  (gdb) break main                    # 在 main 設中斷點
  (gdb) continue                      # 繼續執行
  ```

**GDB 常用命令**:
```
break main      設定中斷點在 main 函式
continue        繼續執行到下一個中斷點
step            單步執行 (進入函式)
next            單步執行 (不進入函式)
print x         顯示變數 x 的值
backtrace       顯示呼叫堆疊
info registers  顯示所有暫存器的值
x/10x 0x0       檢查位址 0x0 開始的 10 個 words (十六進位)
```

---

---

### 2.3 交叉編譯（為什麼要用特殊的編譯器？）

**問題：為什麼不能用一般的 gcc？**

想像一下你在翻譯書籍：

```
情況 1: 本地翻譯 (一般的 gcc)
───────────────────────
中文書 → 中文翻譯機 → 中文書（給中文讀者看）
  ↑         ↑           ↑
原始碼    編譯器      可執行檔

在電腦 A 編譯 → 產生給電腦 A 執行的程式
```

```
情況 2: 交叉翻譯 (交叉編譯)
───────────────────────────
中文書 → 中翻日翻譯機 → 日文書（給日本讀者看）
  ↑          ↑            ↑
原始碼    交叉編譯器    可執行檔

在電腦 A 編譯 → 產生給晶片 B 執行的程式
```

---

#### 🔸 為什麼需要交叉編譯？

**我們的情況：**

```
┌──────────────────────────────────────────────┐
│                                                │
│  你的電腦（x86_64）               ARM 晶片    │
│  ─────────────                   ────────     │
│  💪 很強大                        💪 很小       │
│  • 4 核心 CPU                     • 單核心     │
│  • 16 GB 記憶體                   • 64 KB      │
│  • 能跑編譯器                     • 連編譯器   │
│                                      都裝不下！ │
│                                                │
│  說「x86 語言」                   說「ARM 語言」│
│  (Intel 指令集)                  (ARM 指令集)  │
│                                                │
└──────────────────────────────────────────────┘
```

**解決方案：交叉編譯**

```
步驟 1: 在你的強大電腦上編譯
  電腦: x86_64 Linux
  編譯器: arm-none-eabi-gcc  ← 特殊的編譯器！
  編譯速度: 快！(因為電腦強大)

步驟 2: 產生 ARM 晶片能執行的程式
  輸出: uart_hello_world.bin
  語言: ARM 機器碼
  ↓
  這個檔案是給 ARM 晶片執行的！

步驟 3: 把 .bin 檔案上傳到 ARM 晶片
  用 QEMU 模擬器 或 實體晶片
```

---

#### 🔸 名稱解釋：arm-none-eabi-gcc

這個長長的名字告訴我們很多資訊：

```
arm-none-eabi-gcc
 ↑   ↑    ↑    ↑
 │   │    │    └─ gcc = 編譯器
 │   │    └────── eabi = 一種規則（怎麼傳參數、怎麼返回值）
 │   └─────────── none = 沒有作業系統（裸機）
 └─────────────── arm = 給 ARM 晶片用的

白話翻譯:
「這是一個編譯器，
 產生給 ARM 晶片執行的程式，
 這個晶片沒有作業系統（直接控制硬體）」
```

**對比：**

```
gcc                  →  給你電腦用的編譯器
                        產生 x86_64 指令

arm-none-eabi-gcc    →  給 ARM 晶片用的編譯器
                        產生 ARM 指令
```

**📖 本地編譯 vs 交叉編譯完全解析**

讓我們深入理解本地編譯和交叉編譯的差異，以及為什麼嵌入式開發需要交叉編譯：

#### 本地編譯 (Native Compilation)

**本地編譯 (Native Compilation)** = **在同一平台上編譯和執行**
- **Native**: 本地的、原生的
- **Compilation**: 編譯
- **定義**: 開發平台、編譯平台、執行平台是同一個
- **範例**: 在 x86_64 Linux 上編譯，產出可在 x86_64 Linux 執行的程式

**開發平台: x86_64 Linux**
- **x86_64**: Intel/AMD 64-bit 處理器架構
  - **x86**: Intel 8086 處理器的後代
  - **64**: 64-bit (可處理 64-bit 資料和位址)
- **Linux**: 作業系統
- **這是你的電腦**: 可能是筆電、桌機、伺服器

**編譯器: gcc (x86_64)**
- **gcc**: GNU C Compiler
- **(x86_64)**: 產生 x86_64 機器碼的編譯器
- **預設行為**: 系統的 gcc 通常產生本平台的可執行檔
- **命令**: 直接用 `gcc` (不是 `arm-none-eabi-gcc`)

**產出: 可在 x86_64 執行的程式**
- **機器碼**: x86_64 指令集
  - **範例指令**: `mov rax, 5`, `call printf`, `ret`
- **可執行檔**: ELF 格式，作業系統是 Linux
- **執行**: 直接在你的電腦上執行 `./program`

**本地編譯的優點**:
- **簡單**: 只需要一套工具
- **快速測試**: 編譯完立刻執行，不需要上傳到其他裝置
- **完整除錯**: 可以使用所有除錯工具

**本地編譯的限制**:
- **只能跑在同一平台**: x86_64 的程式無法在 ARM 上執行
- **無法開發嵌入式系統**: ARM MCU 沒有 GCC、沒有作業系統

**同一平台開發、編譯、執行**
- **一致性**: 所有步驟在同一環境
- **類比**: 像是在工廠裡製造產品，並在同一個工廠使用這個產品

#### 交叉編譯 (Cross Compilation)

**交叉編譯 (Cross Compilation)** = **在一個平台編譯，在另一個平台執行**
- **Cross**: 交叉、跨越
- **定義**: 開發平台 ≠ 目標平台
- **範例**: 在 x86_64 Linux 上編譯，產出可在 ARM Cortex-M3 執行的程式

**開發平台: x86_64 Linux ← 你的電腦**
- **作用**: 提供開發環境
- **優勢**:
  - 運算能力強大 (多核心、大記憶體)
  - 有完整的工具鏈 (編輯器、版本控制、CI/CD)
  - 編譯速度快
- **為什麼不能直接編譯**: 系統預設的 gcc 產生 x86_64 機器碼，ARM 無法執行

**編譯器: arm-none-eabi-gcc ← ARM 交叉編譯器**
- **交叉編譯器**: 在 x86_64 上執行，但產生 ARM 機器碼的編譯器
- **特殊之處**:
  - **執行環境**: x86_64 Linux (在你的電腦上跑)
  - **輸出程式碼**: ARM Thumb-2 機器碼 (給 ARM 執行)
- **安裝**: `sudo apt-get install gcc-arm-none-eabi`

**產出: 可在 ARM Cortex-M3 執行的程式 ← 目標平台**
- **機器碼**: ARM Thumb-2 指令集
  - **範例指令**: `movs r0, #5`, `bl printf`, `bx lr`
- **CPU**: ARM Cortex-M3 (32-bit，RISC 架構)
- **記憶體**: 256KB Flash + 64KB SRAM (資源有限)
- **作業系統**: 無 (bare-metal / 裸機)
- **執行方式**:
  - 上傳到實體硬體 (透過 JTAG/SWD)
  - 在 QEMU 模擬器執行

**在 x86 平台編譯**
- **編譯器本身**: x86_64 可執行檔
- **執行環境**: 你的 Linux 系統
- **編譯速度**: 快 (現代電腦效能好)

**產生 ARM 平台可執行的程式**
- **機器碼格式**: ARM 二進位指令
- **記憶體布局**: 符合 ARM Cortex-M3 規範
- **啟動方式**: 符合 ARM 中斷向量表規範
- **周邊裝置**: 針對 LM3S6965 的 UART, GPIO, Timer 等

**交叉編譯的原因**:

1. **ARM 微控制器資源有限，無法自己編譯**
   - **記憶體**: 只有 64KB SRAM，連 GCC 都裝不下 (GCC 需要 GB 等級)
   - **儲存空間**: 只有 256KB Flash，無法儲存編譯器
   - **運算能力**: Cortex-M3 只有 ~50 MHz，編譯會非常慢
   - **無作業系統**: 沒有 Linux，無法執行 GCC

2. **在強大的電腦上編譯，再下載到 ARM 執行**
   - **效率**: 現代電腦編譯 1 秒，ARM MCU 可能要 10 分鐘
   - **便利性**: 可以使用熟悉的開發環境 (VS Code, Git, GDB)
   - **工作流程**:
     ```
     1. 在電腦上寫程式 (C 語言)
     2. 交叉編譯器產生 ARM 機器碼 (.bin)
     3. 上傳到 ARM 硬體 (透過 JTAG) 或 QEMU
     4. ARM 執行程式
     5. 用 GDB 透過網路連接到 ARM 進行除錯
     ```

**交叉編譯的架構對應**:

```
編譯器主機平台        →    目標平台
(Host Platform)            (Target Platform)
─────────────────────────────────────────────
x86_64 Linux          →    ARM Cortex-M3
編譯器在這裡執行           產生的程式在這裡執行

類比:
翻譯機在台灣執行      →    譯文給日本人閱讀
(機器在台灣)              (結果給日本人用)
```

**為什麼叫「交叉」？**
- **兩個不同的架構交會**: x86_64 ⟷ ARM
- **編譯過程跨越平台**: 從一個世界跳到另一個世界
- **不同於本地編譯**: 本地編譯是 x86_64 → x86_64 (同一個世界)

#### 命名規則解釋

```
arm-none-eabi-gcc
 ↑   ↑    ↑    ↑
 │   │    │    └─ 工具名稱 (gcc = GNU C Compiler)
 │   │    └────── 二進位介面 (eabi = Embedded ABI)
 │   └─────────── 作業系統 (none = 裸機，無作業系統)
 └─────────────── 目標架構 (arm = ARM 處理器)
```

**📖 arm-none-eabi-gcc 命名規則完全解析**

交叉編譯器的名稱遵循特定的命名慣例，讓我們拆解每一個部分的意義：

#### 第一部分: arm (目標架構)

**arm** = **目標處理器架構**
- **ARM**: Advanced RISC Machine (進階精簡指令集機器)
- **定義**: 這個編譯器產生的機器碼是給 ARM 處理器執行的
- **不是**: x86, x86_64, riscv, mips 等其他架構

**ARM 架構的特色**:
- **RISC**: Reduced Instruction Set Computing (精簡指令集)
  - 指令數量少、格式規則
  - 相對於 CISC (Complex Instruction Set Computing，如 x86)
- **低功耗**: 特別適合行動裝置和嵌入式系統
- **應用廣泛**: 手機 (Apple A/M 系列、Qualcomm Snapdragon)、樹莓派、MCU

**為什麼是 arm 而不是具體型號**:
- **arm** 是架構家族的統稱
- **包含**: ARMv7-M (Cortex-M3/M4)、ARMv8-M (Cortex-M33)、ARMv8-A (Cortex-A53) 等
- **編譯器支援多種 ARM 變體**: 透過 `-mcpu` 參數指定具體型號
  - `-mcpu=cortex-m3`: 編譯給 Cortex-M3
  - `-mcpu=cortex-m4`: 編譯給 Cortex-M4
  - `-mcpu=cortex-a53`: 編譯給 Cortex-A53

#### 第二部分: none (作業系統)

**none** = **無作業系統 (Bare-metal)**
- **定義**: 目標平台沒有作業系統
- **Bare-metal**: 裸機，程式直接在硬體上執行
- **對比**:
  - **arm-none-eabi-gcc**: 無作業系統 (MCU 開發)
  - **arm-linux-gnueabihf-gcc**: Linux 作業系統 (樹莓派、嵌入式 Linux)
  - **arm-windows-gnu-gcc**: Windows 作業系統 (Windows on ARM)

**無作業系統的影響**:
1. **無系統呼叫 (System Call)**:
   - 沒有 `fork()`, `exec()`, `open()` 等系統呼叫
   - 沒有檔案系統、行程管理

2. **直接存取硬體**:
   - 可以直接寫入周邊暫存器
   - 不需要透過驅動程式

3. **單一程式執行**:
   - 沒有多工 (Multi-tasking)
   - 除非使用 RTOS (Real-Time Operating System)

4. **完全控制**:
   - 控制所有硬體資源
   - 控制中斷、記憶體配置

**範例對比**:
```c
// 有作業系統 (Linux):
FILE *f = fopen("log.txt", "w");  // 使用檔案系統
fprintf(f, "Hello\n");
fclose(f);

// 無作業系統 (Bare-metal):
UART0->DR = 'H';  // 直接寫 UART 暫存器
UART0->DR = 'e';
UART0->DR = 'l';
// 沒有檔案系統，直接操作硬體
```

#### 第三部分: eabi (二進位介面)

**eabi** = **Embedded Application Binary Interface**
- **Embedded**: 嵌入式
- **Application**: 應用程式
- **Binary**: 二進位
- **Interface**: 介面
- **定義**: 定義函式呼叫、資料型別、系統呼叫的標準規範

**ABI (Application Binary Interface)** = **應用程式二進位介面**
- **作用**: 定義編譯後的程式如何在二進位層級上互動
- **規範內容**:
  1. **呼叫慣例 (Calling Convention)**
  2. **資料型別大小和對齊**
  3. **暫存器使用規則**
  4. **堆疊布局**

**EABI vs 其他 ABI**:
```
eabi (Embedded ABI):
  • 針對嵌入式系統最佳化
  • 沒有作業系統相關的系統呼叫
  • 適合: MCU (Cortex-M 系列)

gnueabi (GNU EABI):
  • GNU 版本的 EABI
  • 有作業系統支援
  • 軟浮點 (Soft Float)

gnueabihf (GNU EABI Hard Float):
  • 硬體浮點數支援
  • 適合: 樹莓派 (Cortex-A 系列有 FPU)
```

**呼叫慣例範例**:
根據 ARM EABI 規範:
```
函式參數傳遞:
  • 前 4 個參數: r0, r1, r2, r3
  • 第 5 個以後: 放在堆疊上

返回值:
  • 32-bit 或更小: r0
  • 64-bit: r0 (低 32-bit) + r1 (高 32-bit)

範例:
int add(int a, int b, int c, int d, int e) {
    return a + b + c + d + e;
}

呼叫 add(1, 2, 3, 4, 5):
  r0 = 1    ← 第1個參數
  r1 = 2    ← 第2個參數
  r2 = 3    ← 第3個參數
  r3 = 4    ← 第4個參數
  [SP] = 5  ← 第5個參數 (放堆疊)
```

**為什麼 ABI 重要？**
- **相容性**: 不同編譯器產生的 .o 可以一起連結
- **函式庫**: 預編譯的函式庫 (libc.a) 可以與你的程式連結
- **除錯**: GDB 知道如何解析堆疊、找到參數和返回值

#### 第四部分: gcc (工具名稱)

**gcc** = **GNU C Compiler**
- **GNU**: GNU's Not Unix (遞迴縮寫，自由軟體專案)
- **C Compiler**: C 語言編譯器
- **實際上**: 現在是 GNU Compiler Collection (編譯器集合)
  - 支援 C, C++, Objective-C, Fortran, Ada, Go 等

**gcc 的作用**:
- **C 編譯器**: 將 C 程式碼編譯成機器碼
- **驅動程式**: 協調預處理器、編譯器、組譯器、連結器
- **多功能**:
  ```bash
  gcc -E source.c       # 只預處理
  gcc -S source.c       # 預處理 + 編譯成組合語言
  gcc -c source.c       # 預處理 + 編譯 + 組譯 (產生 .o)
  gcc source.c -o prog  # 完整流程 (產生可執行檔)
  ```

**其他工具的命名**:
```
arm-none-eabi-gcc      C/C++ 編譯器
arm-none-eabi-g++      C++ 編譯器 (實際上和 gcc 相同，只是預設用 C++)
arm-none-eabi-ld       連結器
arm-none-eabi-as       組譯器
arm-none-eabi-ar       靜態函式庫工具
arm-none-eabi-objcopy  格式轉換工具
arm-none-eabi-objdump  反組譯工具
arm-none-eabi-gdb      除錯器
arm-none-eabi-size     顯示段落大小
arm-none-eabi-nm       列出符號表
arm-none-eabi-strip    移除符號表
```

**命名慣例總結**:
```
<架構>-<作業系統>-<ABI>-<工具>

範例:
arm-none-eabi-gcc       ARM 裸機 EABI 編譯器
arm-linux-gnueabihf-gcc ARM Linux EABI 硬浮點編譯器
x86_64-w64-mingw32-gcc  x86_64 Windows MinGW 編譯器
riscv64-unknown-elf-gcc RISC-V 64-bit 裸機 ELF 編譯器
```

**為什麼需要這麼長的名稱？**
- **明確性**: 一看就知道這個編譯器的目標平台
- **共存**: 同一系統可以安裝多個交叉編譯器
  - `arm-none-eabi-gcc` (ARM MCU 開發)
  - `arm-linux-gnueabihf-gcc` (樹莓派開發)
  - `gcc` (本機 x86_64 開發)
- **避免混淆**: 不會誤用錯誤的編譯器

---

---

## 3. Makefile（自動化編譯的腳本）

### 3.1 什麼是 Makefile？

想像你每天要做同樣的事：

```
沒有 Makefile（手動）:
────────────────────────
每次編譯要打 10 行命令：
$ arm-none-eabi-gcc -mthumb -mcpu=cortex-m3 ... uart_hello_world.c
$ arm-none-eabi-gcc -mthumb -mcpu=cortex-m3 ... startup_gcc.c
$ arm-none-eabi-gcc -mthumb -mcpu=cortex-m3 ... system_lm3s.c
$ arm-none-eabi-ld ... (一堆參數)
$ arm-none-eabi-objcopy ...
😫 每次都要打這麼多！
```

```
有 Makefile（自動）:
───────────────────
只要打一個命令：
$ make

✨ Makefile 自動幫你執行所有步驟！
```

**Makefile 就像是一份食譜**，告訴電腦：
1. 需要哪些材料（原始檔）
2. 怎麼做（編譯命令）
3. 做成什麼（最終的 .bin 檔）

---

### 3.2 專案的 Makefile 結構

我們的專案有兩層 Makefile：

```
┌────────────────────────────────────────┐
│                                          │
│  makedefs                                │
│  ─────────                               │
│  共用的設定（所有專案都用）              │
│  • 編譯器名稱: arm-none-eabi-gcc        │
│  • 編譯參數: -mthumb -mcpu=cortex-m3    │
│  • 連結參數: ...                         │
│                                          │
│     ↓ 被引入                             │
│                                          │
│  examples/uart_hello_world/Makefile     │
│  ────────────────────────────────────   │
│  這個專案專用的設定                      │
│  • 原始檔: uart_hello_world.c           │
│  • 需要的函式庫: startup.c, system.c    │
│  • 最終產生: uart_hello_world.bin       │
│                                          │
└────────────────────────────────────────┘
```

---

### 3.3 重要的編譯參數（白話解釋）

打開 [makedefs](makedefs) 會看到很多參數，以下是重要的幾個：

```
┌──────────────────────────────────────────────┐
│                                                │
│  -mthumb                                      │
│  「用省空間的指令」                            │
│  → ARM 有兩種指令：32-bit (大) 和            │
│    16/32-bit 混合 (小)                        │
│  → Cortex-M3 只會用混合的，比較省空間         │
│                                                │
│  -mcpu=cortex-m3                              │
│  「我的 CPU 是 Cortex-M3」                    │
│  → 告訴編譯器產生最適合這個 CPU 的程式碼      │
│                                                │
│  -O0                                          │
│  「不要最佳化」                                │
│  → 程式碼和你寫的一模一樣，方便除錯           │
│  → 如果用 -O2，編譯器會重新排列程式碼，       │
│    執行速度快但難除錯                          │
│                                                │
│  -Wall                                        │
│  「顯示所有警告」                              │
│  → 如果有可疑的程式碼，編譯器會警告你         │
│    例如：變數宣告了但沒用到                    │
│                                                │
│  -DPART_LM3S6965                              │
│  「定義晶片型號是 LM3S6965」                   │
│  → 相當於在程式開頭加上:                       │
│    #define PART_LM3S6965                      │
│                                                │
└──────────────────────────────────────────────┘
```

#### 連結參數 (LDFLAGS)

```makefile
# makedefs:127
LDFLAGS=--gc-sections      # 垃圾回收未使用的區段
```

這個參數會移除未使用的函數和變數，減小最終程式大小。

---

### 3.2 UART 範例 Makefile

**檔案位置**: [`examples/uart_hello_world/Makefile`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/Makefile)

```makefile
# 定義晶片型號
PART=LM3S6965

# 專案根目錄
ROOT=../..

# 引入共用定義
include ${ROOT}/makedefs

# 原始碼搜尋路徑
VPATH=../../lm3s

# 標頭檔搜尋路徑
IPATH=.
IPATH+=../..
IPATH+=../../CMSIS/Include

# 預設目標：編譯 uart_hello_world.axf
all: ${COMPILER}
all: ${COMPILER}/uart_hello_world.axf

# 依賴關係
${COMPILER}/uart_hello_world.axf: ${COMPILER}/uart_hello_world.o
${COMPILER}/uart_hello_world.axf: ${COMPILER}/startup_${COMPILER}.o
${COMPILER}/uart_hello_world.axf: ${COMPILER}/system_lm3s.o
${COMPILER}/uart_hello_world.axf: uart_hello_world.ld

# 連結腳本
SCATTERgcc_uart_hello_world=uart_hello_world.ld

# 程式進入點
ENTRY_uart_hello_world=Reset_Handler
```

#### Makefile 流程圖

```
┌──────────────────────────────────────────────────────────┐
│          uart_hello_world Makefile 執行流程                │
│                                                            │
│  $ make                                                    │
│    │                                                       │
│    ├─→ 建立 gcc/ 目錄（如果不存在）                         │
│    │                                                       │
│    ├─→ 編譯 uart_hello_world.c                            │
│    │    gcc ... -o gcc/uart_hello_world.o                 │
│    │                                                       │
│    ├─→ 編譯 startup_gcc.c                                 │
│    │    gcc ... -o gcc/startup_gcc.o                      │
│    │                                                       │
│    ├─→ 編譯 system_lm3s.c（從 ../../lm3s/ 找到）           │
│    │    gcc ... -o gcc/system_lm3s.o                      │
│    │                                                       │
│    ├─→ 連結所有 .o 檔案                                    │
│    │    ld -T uart_hello_world.ld \                       │
│    │       --entry Reset_Handler \                        │
│    │       --gc-sections \                                │
│    │       -o gcc/uart_hello_world.axf \                  │
│    │       uart_hello_world.o startup_gcc.o system_lm3s.o \│
│    │       libc.a libm.a libgcc.a                         │
│    │                                                       │
│    └─→ 產生二進位檔案                                      │
│         objcopy -O binary \                               │
│                 gcc/uart_hello_world.axf \                │
│                 gcc/uart_hello_world.bin                  │
│                                                            │
└──────────────────────────────────────────────────────────┘
```

---

### 3.3 FIR 範例 Makefile

**檔案位置**: [`examples/arm_fir_example/Makefile`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/arm_fir_example/Makefile)

FIR 範例的 Makefile 更複雜，因為需要編譯 DSP 函式庫：

```makefile
# 額外的原始碼搜尋路徑
VPATH=../../CMSIS/DSP_Lib/Source/FilteringFunctions/
VPATH+=../../lm3s

# 依賴關係（包含 DSP 模組）
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/arm_fir_example_f32.o
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/arm_fir_data.o
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/math_helper.o
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/startup_${COMPILER}.o
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/system_lm3s.o

# DSP 函式庫模組
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/arm_fir_f32.o
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/arm_fir_init_f32.o
```

#### VPATH 機制

```
┌────────────────────────────────────────────────────────┐
│              VPATH 搜尋路徑機制                          │
│                                                          │
│  VPATH=../../CMSIS/DSP_Lib/Source/FilteringFunctions/   │
│                                                          │
│  當 Makefile 需要 arm_fir_f32.c 時：                    │
│  1. 先在當前目錄找                                       │
│  2. 找不到 → 到 VPATH 路徑找                            │
│  3. 找到 → 使用該檔案編譯                               │
│                                                          │
│  範例：                                                  │
│  arm_fir_f32.c                                          │
│    ↓ 不在當前目錄                                        │
│    ↓ 在 VPATH 中搜尋                                    │
│    ↓ 找到！                                             │
│  ../../CMSIS/DSP_Lib/Source/FilteringFunctions/\        │
│                                    arm_fir_f32.c         │
│                                                          │
└────────────────────────────────────────────────────────┘
```

---

---

## 4. 實際動手編譯！

### 4.1 第一次編譯 UART 範例

**步驟 1: 進入專案目錄**

```bash
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world
```

**步驟 2: 清除舊的編譯檔案（如果有的話）**

```bash
make clean
```

這會刪除之前編譯產生的檔案，讓我們重新開始。

**步驟 3: 編譯！**

```bash
make
```

你會看到類似這樣的輸出：

```
  CC    uart_hello_world.c          ← 正在編譯 uart_hello_world.c
  CC    startup_gcc.c                ← 正在編譯 startup_gcc.c
  CC    ../../lm3s/system_lm3s.c    ← 正在編譯 system_lm3s.c
  LD    gcc/uart_hello_world.axf    ← 正在連結
  ALL IS GOOD, CHILL OUT            ← 成功！
```

**步驟 4: 查看產生了什麼檔案**

```bash
ls -lh gcc/
```

你會看到：

```
uart_hello_world.o      ← 主程式的目標檔
startup_gcc.o           ← 啟動程式的目標檔
system_lm3s.o           ← 系統設定的目標檔
uart_hello_world.axf    ← 完整程式（含除錯資訊）7.3 KB
uart_hello_world.bin    ← 純機器碼（給晶片用）423 Bytes
```

**恭喜！你已經成功編譯出可以在 ARM 晶片上執行的程式了！🎉**

---

### 4.2 編譯 FIR 範例

```bash
# 進入 FIR 範例目錄
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/arm_fir_example

# 清除
make clean

# 編譯
make

# 輸出：
#   CC    arm_fir_example_f32.c
#   CC    arm_fir_data.c
#   CC    math_helper.c
#   CC    ../../CMSIS/DSP_Lib/Source/FilteringFunctions/arm_fir_f32.c
#   CC    ../../CMSIS/DSP_Lib/Source/FilteringFunctions/arm_fir_init_f32.c
#   CC    startup_gcc.c
#   CC    ../../lm3s/system_lm3s.c
#   LD    gcc/arm_fir_example_f32.axf arm_fir_example_f32.ld
#   ALL IS GOOD, CHILL OUT

# 查看編譯結果
ls -lh gcc/
# -rwxr-xr-x arm_fir_example_f32.axf    (57 KB)
# -rw-r--r-- arm_fir_example_f32.bin    (13 KB)
```

---

### 4.3 編譯參數詳解

使用 `VERBOSE=1` 查看完整編譯命令：

```bash
make VERBOSE=1

# 完整編譯命令範例：
arm-none-eabi-gcc \
    -mthumb \
    -mcpu=cortex-m3 \
    -O0 \
    -ffunction-sections \
    -fdata-sections \
    -MD \
    -std=c99 \
    -Wall \
    -pedantic \
    -DPART_LM3S6965 \
    -D ARM_MATH_CM3 \
    -c \
    -Dgcc \
    -I. \
    -I../.. \
    -I../../CMSIS/Include \
    -o gcc/uart_hello_world.o \
    uart_hello_world.c
```

---

## 5. 依賴關係管理

### 5.1 .d 依賴檔案

編譯時會自動產生 `.d` 檔案，記錄標頭檔依賴關係：

```bash
# 查看 uart_hello_world.d
cat gcc/uart_hello_world.d

# 內容範例：
gcc/uart_hello_world.o: uart_hello_world.c \
  lm3s_config.h \
  ../../lm3s/lm3s_cmsis.h \
  ../../CMSIS/Include/core_cm3.h \
  ../../CMSIS/Include/core_cmFunc.h
```

這表示：
- 如果 `uart_hello_world.c` 修改 → 重新編譯
- 如果 `lm3s_config.h` 修改 → 重新編譯
- 如果 `core_cm3.h` 修改 → 重新編譯

```
┌──────────────────────────────────────────────────┐
│           依賴關係自動追蹤                          │
│                                                    │
│  uart_hello_world.c                               │
│    ↓ 包含 (include)                               │
│  lm3s_config.h                                    │
│    ↓ 包含                                         │
│  lm3s_cmsis.h                                     │
│    ↓ 包含                                         │
│  core_cm3.h                                       │
│                                                    │
│  如果任何一個檔案修改，                              │
│  uart_hello_world.o 會自動重新編譯                 │
│                                                    │
└──────────────────────────────────────────────────┘
```

---

## 6. 從所有範例根目錄編譯

專案也提供了頂層 Makefile：

```bash
# 從專案根目錄編譯所有範例
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S
make

# 清除所有編譯產物
make clean
```

---

## 7. 編譯最佳化等級

### 7.1 最佳化等級比較

```
┌─────────────────────────────────────────────────────────┐
│            GCC 最佳化等級                                 │
├─────────────────────────────────────────────────────────┤
│                                                           │
│  -O0  (預設)                                             │
│  ────────                                                │
│  • 不進行最佳化                                           │
│  • 編譯速度最快                                           │
│  • 程式碼大小最大                                         │
│  • 執行速度最慢                                           │
│  • 除錯最容易（程式碼與原始碼一一對應）                      │
│  ✓ 適合：開發階段、除錯                                   │
│                                                           │
│  -O1                                                     │
│  ────                                                    │
│  • 基本最佳化                                             │
│  • 不會顯著增加編譯時間                                    │
│  • 適度減小程式碼大小                                      │
│                                                           │
│  -O2                                                     │
│  ────                                                    │
│  • 進階最佳化                                             │
│  • 顯著減小程式碼大小                                      │
│  • 提升執行速度                                           │
│  • 除錯較困難（程式碼可能被重排）                           │
│  ✓ 適合：發布版本                                         │
│                                                           │
│  -O3                                                     │
│  ────                                                    │
│  • 最激進的最佳化                                         │
│  • 可能增加程式碼大小（函數內聯）                           │
│  • 最快的執行速度                                         │
│  • 除錯非常困難                                           │
│                                                           │
│  -Os                                                     │
│  ────                                                    │
│  • 優化程式碼大小                                         │
│  • 類似 -O2 但更注重空間                                  │
│  ✓ 適合：記憶體受限的嵌入式系統                            │
│                                                           │
└─────────────────────────────────────────────────────────┘
```

### 7.2 修改最佳化等級

要使用不同最佳化等級，修改 `makedefs` 中的 CFLAGS：

```makefile
# 原本
CFLAGS=-mthumb -mcpu=cortex-m3 -O0 ...

# 改為 -O2
CFLAGS=-mthumb -mcpu=cortex-m3 -O2 ...
```

---

## 8. 除錯符號

### 8.1 加入除錯符號

```bash
# 編譯時加入 DEBUG=1
make DEBUG=1

# 這會在 CFLAGS 加入 -g 參數
# makedefs:151
# CFLAGS+=-g -D DEBUG
```

有除錯符號的好處：
```
┌────────────────────────────────────────────┐
│  有除錯符號 (-g)                            │
│  ────────────────                          │
│  ✓ GDB 可以顯示原始碼                       │
│  ✓ GDB 可以設定函數名稱中斷點               │
│  ✓ GDB 可以顯示變數名稱                     │
│  ✓ GDB 可以顯示呼叫堆疊                     │
│  ✗ 檔案會變大                              │
│                                            │
│  沒有除錯符號                               │
│  ────────────                              │
│  ✗ 只能看到記憶體位址                       │
│  ✗ 只能用位址設中斷點                       │
│  ✓ 檔案較小                                │
│                                            │
└────────────────────────────────────────────┘
```

---

## 9. Makefile 進階技巧

### 9.1 平行編譯

```bash
# 使用 4 個 CPU 核心平行編譯
make -j4

# 自動偵測 CPU 核心數
make -j$(nproc)
```

### 9.2 只編譯不連結

```bash
# 只編譯 .c 到 .o（不連結成 .axf）
make gcc/uart_hello_world.o
```

### 9.3 查看 Makefile 變數

```bash
# 查看 CFLAGS 的值
make -p | grep "^CFLAGS"
```

---

## 10. 常見問題與排除

### 問題 1：找不到 arm-none-eabi-gcc

```bash
$ make
bash: arm-none-eabi-gcc: command not found
```

**解決**：
```bash
# 在 Ubuntu/Debian
sudo apt-get install gcc-arm-none-eabi

# 或使用本專案的 Docker 環境
docker run --rm -v $(pwd):/work -w /work \
    cmsis-lm3s-qemu:latest make
```

---

### 問題 2：編譯錯誤

```bash
error: 'UART0' undeclared
```

**檢查**：
1. 是否 `#include` 了正確的標頭檔
2. 是否定義了 `-DPART_LM3S6965`
3. 查看 `.d` 檔案確認依賴關係

---

### 問題 3：連結錯誤

```bash
undefined reference to `arm_fir_f32'
```

**解決**：
確認 Makefile 中有加入依賴：
```makefile
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/arm_fir_f32.o
```

---

## 📝 實作練習

### 練習 1：編譯 UART 範例

```bash
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world
make clean
make
ls -lh gcc/
```

觀察編譯過程和產生的檔案。

---

### 練習 2：查看依賴關係

```bash
cat gcc/uart_hello_world.d
```

繪製依賴關係圖。

---

### 練習 3：使用除錯符號編譯

```bash
make clean
make DEBUG=1
ls -lh gcc/uart_hello_world.axf
```

比較有無 DEBUG 的檔案大小差異。

---

### 練習 4：修改最佳化等級

1. 編輯 `makedefs`，將 `-O0` 改成 `-O2`
2. 重新編譯
3. 比較檔案大小

<details>
<summary>預期結果</summary>

使用 `-O2` 後，`.bin` 檔案會變小，因為編譯器移除了冗餘程式碼並進行最佳化。

</details>

---

## 🎯 學習檢查點

完成本模組後，請確認你能：

- [ ] 說明編譯的四個階段（預處理、編譯、組譯、連結）
- [ ] 解釋交叉編譯的概念
- [ ] 理解 `arm-none-eabi-gcc` 命名的意義
- [ ] 解讀 makedefs 中的 CFLAGS 參數
- [ ] 使用 Makefile 編譯專案
- [ ] 理解 VPATH 搜尋路徑機制
- [ ] 查看並理解 .d 依賴檔案
- [ ] 區分 .axf 和 .bin 檔案的差異
- [ ] 知道如何加入除錯符號
- [ ] 理解不同最佳化等級的影響

---

## 🔗 下一步

恭喜完成模組 02！

你現在已經理解了程式編譯流程和 Makefile 系統。接下來在[模組 03：記憶體原理](03-記憶體原理.md)中，我們將學習程式如何被載入記憶體，以及 Linker Script 和啟動程式碼的運作原理。

---

**版本**：1.0
**更新日期**：2025-11-16
