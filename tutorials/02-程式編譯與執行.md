# 模組 02：程式編譯與執行

> 從 C 原始碼到可執行檔：理解編譯流程與 Makefile

---

## 📌 學習目標

完成本模組後，你將能夠：
- ✅ 理解從原始碼到可執行檔的完整流程
- ✅ 認識 GCC 工具鏈（編譯器、連結器）
- ✅ 學會使用 Makefile 自動化編譯
- ✅ 了解交叉編譯的概念
- ✅ 實際操作專案的編譯系統

**對應專案檔案**：
- [`makedefs`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/makedefs)
- [`examples/uart_hello_world/Makefile`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/Makefile)
- [`examples/arm_fir_example/Makefile`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/arm_fir_example/Makefile)

---

## 1. 編譯流程概覽

### 1.1 從原始碼到執行檔

當你寫完程式後，電腦無法直接執行你的 C 語言程式碼。需要經過「編譯」過程：

```
┌──────────────────────────────────────────────────────────────┐
│              編譯流程四階段                                      │
│                                                                │
│  階段 1: 預處理 (Preprocessing)                                │
│  ┌──────────────────────────────────────┐                     │
│  │  uart_hello_world.c                  │                     │
│  │  ──────────────────                  │                     │
│  │  #include <stdint.h>                 │                     │
│  │  #define LED_PIN 5                   │                     │
│  │  ...                                 │                     │
│  └────────────┬─────────────────────────┘                     │
│               │ gcc -E                                         │
│               ▼                                                │
│  ┌──────────────────────────────────────┐                     │
│  │  uart_hello_world.i                  │                     │
│  │  ──────────────────                  │                     │
│  │  • 展開 #include 檔案                 │                     │
│  │  • 展開 #define 巨集                  │                     │
│  │  • 處理條件編譯 (#ifdef)              │                     │
│  │  • 移除註解                          │                     │
│  └────────────┬─────────────────────────┘                     │
│               │                                                │
│  ═══════════════════════════════════════                      │
│                                                                │
│  階段 2: 編譯 (Compilation)                                    │
│               │ gcc -S                                         │
│               ▼                                                │
│  ┌──────────────────────────────────────┐                     │
│  │  uart_hello_world.s                  │                     │
│  │  ──────────────────                  │                     │
│  │  ; ARM 組合語言                       │                     │
│  │  PUSH {r4, lr}                       │                     │
│  │  MOV r0, #5                          │                     │
│  │  BL print_uart0                      │                     │
│  │  ...                                 │                     │
│  └────────────┬─────────────────────────┘                     │
│               │                                                │
│  ═══════════════════════════════════════                      │
│                                                                │
│  階段 3: 組譯 (Assembly)                                       │
│               │ gcc -c                                         │
│               ▼                                                │
│  ┌──────────────────────────────────────┐                     │
│  │  uart_hello_world.o                  │                     │
│  │  ──────────────────                  │                     │
│  │  • 二進位機器碼                       │                     │
│  │  • 目標檔 (Object File)               │                     │
│  │  • 尚未連結                          │                     │
│  │  10110101 01001110 ...               │                     │
│  └────────────┬─────────────────────────┘                     │
│               │                                                │
│  ═══════════════════════════════════════                      │
│                                                                │
│  階段 4: 連結 (Linking)                                        │
│               │ ld                                             │
│               ▼                                                │
│  ┌──────────────────────────────────────┐                     │
│  │  uart_hello_world.axf (ELF)          │                     │
│  │  ──────────────────                  │                     │
│  │  • 完整可執行檔                       │                     │
│  │  • 包含除錯符號                       │                     │
│  │  • 連結所有 .o 和函式庫                │                     │
│  └────────────┬─────────────────────────┘                     │
│               │ objcopy                                        │
│               ▼                                                │
│  ┌──────────────────────────────────────┐                     │
│  │  uart_hello_world.bin                │                     │
│  │  ──────────────────                  │                     │
│  │  • 純二進位檔                         │                     │
│  │  • 用於燒錄到 Flash / QEMU 執行       │                     │
│  └──────────────────────────────────────┘                     │
│                                                                │
└──────────────────────────────────────────────────────────────┘
```

---

### 1.2 專案實際編譯產物

以 UART 範例為例，編譯後會產生：

```bash
examples/uart_hello_world/gcc/
├── uart_hello_world.o          # 主程式目標檔
├── startup_gcc.o                # 啟動程式碼目標檔
├── system_lm3s.o                # 系統初始化目標檔
├── uart_hello_world.d           # 依賴檔案
├── startup_gcc.d
├── system_lm3s.d
├── uart_hello_world.axf         # ELF 可執行檔 (7.3 KB)
└── uart_hello_world.bin         # 二進位檔 (423 Bytes)
```

檔案大小差異：
```
uart_hello_world.axf   7.3 KB    ← 包含符號表、除錯資訊
uart_hello_world.bin   423 B     ← 純程式碼與資料
```

---

## 2. GCC 工具鏈

### 2.1 什麼是工具鏈（Toolchain）？

工具鏈是一組協同工作的開發工具：

```
┌──────────────────────────────────────────────────────────┐
│               GCC ARM 工具鏈                               │
│                                                            │
│  ┌──────────────────────────────────────────────────┐    │
│  │  arm-none-eabi-gcc       編譯器                   │    │
│  │  • 將 C 編譯成組合語言                             │    │
│  │  • 將組合語言組譯成機器碼                           │    │
│  └──────────────────────────────────────────────────┘    │
│                                                            │
│  ┌──────────────────────────────────────────────────┐    │
│  │  arm-none-eabi-ld        連結器                   │    │
│  │  • 連結多個 .o 檔案                               │    │
│  │  • 連結函式庫 (libc, libm, libgcc)                │    │
│  │  • 產生可執行檔                                   │    │
│  └──────────────────────────────────────────────────┘    │
│                                                            │
│  ┌──────────────────────────────────────────────────┐    │
│  │  arm-none-eabi-objcopy   格式轉換工具              │    │
│  │  • 從 .axf (ELF) 轉成 .bin                        │    │
│  │  • 從 .axf 轉成 .hex (Intel HEX)                  │    │
│  └──────────────────────────────────────────────────┘    │
│                                                            │
│  ┌──────────────────────────────────────────────────┐    │
│  │  arm-none-eabi-ar        函式庫工具                │    │
│  │  • 建立靜態函式庫 (.a)                             │    │
│  └──────────────────────────────────────────────────┘    │
│                                                            │
│  ┌──────────────────────────────────────────────────┐    │
│  │  arm-none-eabi-gdb       除錯器                   │    │
│  │  • 除錯 ARM 程式                                  │    │
│  └──────────────────────────────────────────────────┘    │
│                                                            │
└──────────────────────────────────────────────────────────┘
```

---

### 2.2 交叉編譯（Cross Compilation）

本專案使用「交叉編譯」：

```
┌────────────────────────────────────────────────────────────┐
│               本地編譯 vs 交叉編譯                            │
├────────────────────────────────────────────────────────────┤
│                                                              │
│  本地編譯 (Native Compilation)                              │
│  ━━━━━━━━━━━━━━━━━━━━━━━━                                  │
│                                                              │
│   開發平台: x86_64 Linux                                     │
│       ↓                                                      │
│   編譯器: gcc (x86_64)                                       │
│       ↓                                                      │
│   產出: 可在 x86_64 執行的程式                                │
│                                                              │
│   ┌──────────────────────────────────┐                      │
│   │  同一平台開發、編譯、執行          │                      │
│   └──────────────────────────────────┘                      │
│                                                              │
├────────────────────────────────────────────────────────────┤
│                                                              │
│  交叉編譯 (Cross Compilation)                               │
│  ━━━━━━━━━━━━━━━━━━━━━━━                                   │
│                                                              │
│   開發平台: x86_64 Linux          ← 你的電腦                 │
│       ↓                                                      │
│   編譯器: arm-none-eabi-gcc       ← ARM 交叉編譯器           │
│       ↓                                                      │
│   產出: 可在 ARM Cortex-M3 執行的程式  ← 目標平台             │
│                                                              │
│   ┌──────────────────────────────────┐                      │
│   │  在 x86 平台編譯                  │                      │
│   │  產生 ARM 平台可執行的程式         │                      │
│   └──────────────────────────────────┘                      │
│                                                              │
│  原因：                                                       │
│  • ARM 微控制器資源有限，無法自己編譯                          │
│  • 在強大的電腦上編譯，再下載到 ARM 執行                       │
│                                                              │
└────────────────────────────────────────────────────────────┘
```

#### 命名規則解釋

```
arm-none-eabi-gcc
 ↑   ↑    ↑    ↑
 │   │    │    └─ 工具名稱 (gcc = GNU C Compiler)
 │   │    └────── 二進位介面 (eabi = Embedded ABI)
 │   └─────────── 作業系統 (none = 裸機，無作業系統)
 └─────────────── 目標架構 (arm = ARM 處理器)
```

---

## 3. 專案 Makefile 系統

### 3.1 makedefs 檔案解析

專案使用 `makedefs` 定義共用的編譯規則。

**檔案位置**: [`makedefs`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/makedefs)

#### 編譯器設定

```makefile
# makedefs:83-84
# 自動選擇可用的工具鏈
PREFIX=${shell type arm-stellaris-eabi-gcc > /dev/null 2>&1 && \
         echo arm-stellaris-eabi || echo arm-none-eabi}

# makedefs:89
CC=${PREFIX}-gcc      # 編譯器命令
```

#### 編譯參數 (CFLAGS)

```makefile
# makedefs:101-112
CFLAGS=-mthumb             \   # 使用 Thumb-2 指令集
       -mcpu=cortex-m3     \   # 目標 CPU: Cortex-M3
       -O0                 \   # 最佳化等級 0 (不最佳化)
       -ffunction-sections \   # 每個函數獨立區段
       -fdata-sections     \   # 每個資料獨立區段
       -MD                 \   # 產生依賴檔案 .d
       -std=c99            \   # 使用 C99 標準
       -Wall               \   # 啟用所有警告
       -pedantic           \   # 嚴格遵守標準
       -DPART_${PART}      \   # 定義晶片型號 (LM3S6965)
       -D ARM_MATH_CM3     \   # 定義 ARM 數學函式庫
       -c                      # 只編譯不連結
```

參數說明：

```
┌─────────────────────────────────────────────────────┐
│  關鍵編譯參數解釋                                      │
├─────────────────────────────────────────────────────┤
│                                                       │
│  -mthumb                                             │
│  ────────                                            │
│  使用 Thumb-2 指令集（16/32-bit 混合指令）             │
│  • 比純 32-bit ARM 指令更節省空間                     │
│  • Cortex-M3 只支援 Thumb-2                          │
│                                                       │
│  -mcpu=cortex-m3                                     │
│  ────────────────                                    │
│  指定目標處理器                                        │
│  • 產生 Cortex-M3 最佳化的程式碼                      │
│                                                       │
│  -O0                                                 │
│  ────                                                │
│  最佳化等級 0（不最佳化）                              │
│  • 方便除錯，程式碼與原始碼對應                         │
│  • -O1, -O2, -O3 會犧牲除錯性以提升效能                │
│                                                       │
│  -ffunction-sections                                 │
│  ────────────────────                                │
│  每個函數放在獨立區段                                  │
│  • 配合連結器的 --gc-sections                         │
│  • 可移除未使用的函數，減小程式大小                     │
│                                                       │
│  -DPART_LM3S6965                                     │
│  ────────────────                                    │
│  定義預處理器巨集                                      │
│  • 相當於在程式開頭加上 #define PART_LM3S6965         │
│                                                       │
│  -D ARM_MATH_CM3                                     │
│  ────────────────                                    │
│  啟用 CMSIS-DSP 的 Cortex-M3 最佳化                   │
│  • 使用 Cortex-M3 特有的指令加速                      │
│                                                       │
└─────────────────────────────────────────────────────┘
```

#### 連結參數 (LDFLAGS)

```makefile
# makedefs:127
LDFLAGS=--gc-sections      # 垃圾回收未使用的區段
```

這個參數會移除未使用的函數和變數，減小最終程式大小。

---

### 3.2 UART 範例 Makefile

**檔案位置**: [`examples/uart_hello_world/Makefile`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/Makefile)

```makefile
# 定義晶片型號
PART=LM3S6965

# 專案根目錄
ROOT=../..

# 引入共用定義
include ${ROOT}/makedefs

# 原始碼搜尋路徑
VPATH=../../lm3s

# 標頭檔搜尋路徑
IPATH=.
IPATH+=../..
IPATH+=../../CMSIS/Include

# 預設目標：編譯 uart_hello_world.axf
all: ${COMPILER}
all: ${COMPILER}/uart_hello_world.axf

# 依賴關係
${COMPILER}/uart_hello_world.axf: ${COMPILER}/uart_hello_world.o
${COMPILER}/uart_hello_world.axf: ${COMPILER}/startup_${COMPILER}.o
${COMPILER}/uart_hello_world.axf: ${COMPILER}/system_lm3s.o
${COMPILER}/uart_hello_world.axf: uart_hello_world.ld

# 連結腳本
SCATTERgcc_uart_hello_world=uart_hello_world.ld

# 程式進入點
ENTRY_uart_hello_world=Reset_Handler
```

#### Makefile 流程圖

```
┌──────────────────────────────────────────────────────────┐
│          uart_hello_world Makefile 執行流程                │
│                                                            │
│  $ make                                                    │
│    │                                                       │
│    ├─→ 建立 gcc/ 目錄（如果不存在）                         │
│    │                                                       │
│    ├─→ 編譯 uart_hello_world.c                            │
│    │    gcc ... -o gcc/uart_hello_world.o                 │
│    │                                                       │
│    ├─→ 編譯 startup_gcc.c                                 │
│    │    gcc ... -o gcc/startup_gcc.o                      │
│    │                                                       │
│    ├─→ 編譯 system_lm3s.c（從 ../../lm3s/ 找到）           │
│    │    gcc ... -o gcc/system_lm3s.o                      │
│    │                                                       │
│    ├─→ 連結所有 .o 檔案                                    │
│    │    ld -T uart_hello_world.ld \                       │
│    │       --entry Reset_Handler \                        │
│    │       --gc-sections \                                │
│    │       -o gcc/uart_hello_world.axf \                  │
│    │       uart_hello_world.o startup_gcc.o system_lm3s.o \│
│    │       libc.a libm.a libgcc.a                         │
│    │                                                       │
│    └─→ 產生二進位檔案                                      │
│         objcopy -O binary \                               │
│                 gcc/uart_hello_world.axf \                │
│                 gcc/uart_hello_world.bin                  │
│                                                            │
└──────────────────────────────────────────────────────────┘
```

---

### 3.3 FIR 範例 Makefile

**檔案位置**: [`examples/arm_fir_example/Makefile`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/arm_fir_example/Makefile)

FIR 範例的 Makefile 更複雜，因為需要編譯 DSP 函式庫：

```makefile
# 額外的原始碼搜尋路徑
VPATH=../../CMSIS/DSP_Lib/Source/FilteringFunctions/
VPATH+=../../lm3s

# 依賴關係（包含 DSP 模組）
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/arm_fir_example_f32.o
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/arm_fir_data.o
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/math_helper.o
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/startup_${COMPILER}.o
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/system_lm3s.o

# DSP 函式庫模組
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/arm_fir_f32.o
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/arm_fir_init_f32.o
```

#### VPATH 機制

```
┌────────────────────────────────────────────────────────┐
│              VPATH 搜尋路徑機制                          │
│                                                          │
│  VPATH=../../CMSIS/DSP_Lib/Source/FilteringFunctions/   │
│                                                          │
│  當 Makefile 需要 arm_fir_f32.c 時：                    │
│  1. 先在當前目錄找                                       │
│  2. 找不到 → 到 VPATH 路徑找                            │
│  3. 找到 → 使用該檔案編譯                               │
│                                                          │
│  範例：                                                  │
│  arm_fir_f32.c                                          │
│    ↓ 不在當前目錄                                        │
│    ↓ 在 VPATH 中搜尋                                    │
│    ↓ 找到！                                             │
│  ../../CMSIS/DSP_Lib/Source/FilteringFunctions/\        │
│                                    arm_fir_f32.c         │
│                                                          │
└────────────────────────────────────────────────────────┘
```

---

## 4. 實際編譯操作

### 4.1 編譯 UART 範例

```bash
# 進入 UART 範例目錄
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world

# 清除之前的編譯產物
make clean

# 編譯
make

# 輸出：
#   CC    uart_hello_world.c
#   CC    startup_gcc.c
#   CC    ../../lm3s/system_lm3s.c
#   LD    gcc/uart_hello_world.axf uart_hello_world.ld
#   ALL IS GOOD, CHILL OUT

# 查看編譯結果
ls -lh gcc/
# -rw-r--r-- uart_hello_world.o
# -rw-r--r-- startup_gcc.o
# -rw-r--r-- system_lm3s.o
# -rwxr-xr-x uart_hello_world.axf    (7.3 KB)
# -rw-r--r-- uart_hello_world.bin    (423 B)
```

---

### 4.2 編譯 FIR 範例

```bash
# 進入 FIR 範例目錄
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/arm_fir_example

# 清除
make clean

# 編譯
make

# 輸出：
#   CC    arm_fir_example_f32.c
#   CC    arm_fir_data.c
#   CC    math_helper.c
#   CC    ../../CMSIS/DSP_Lib/Source/FilteringFunctions/arm_fir_f32.c
#   CC    ../../CMSIS/DSP_Lib/Source/FilteringFunctions/arm_fir_init_f32.c
#   CC    startup_gcc.c
#   CC    ../../lm3s/system_lm3s.c
#   LD    gcc/arm_fir_example_f32.axf arm_fir_example_f32.ld
#   ALL IS GOOD, CHILL OUT

# 查看編譯結果
ls -lh gcc/
# -rwxr-xr-x arm_fir_example_f32.axf    (57 KB)
# -rw-r--r-- arm_fir_example_f32.bin    (13 KB)
```

---

### 4.3 編譯參數詳解

使用 `VERBOSE=1` 查看完整編譯命令：

```bash
make VERBOSE=1

# 完整編譯命令範例：
arm-none-eabi-gcc \
    -mthumb \
    -mcpu=cortex-m3 \
    -O0 \
    -ffunction-sections \
    -fdata-sections \
    -MD \
    -std=c99 \
    -Wall \
    -pedantic \
    -DPART_LM3S6965 \
    -D ARM_MATH_CM3 \
    -c \
    -Dgcc \
    -I. \
    -I../.. \
    -I../../CMSIS/Include \
    -o gcc/uart_hello_world.o \
    uart_hello_world.c
```

---

## 5. 依賴關係管理

### 5.1 .d 依賴檔案

編譯時會自動產生 `.d` 檔案，記錄標頭檔依賴關係：

```bash
# 查看 uart_hello_world.d
cat gcc/uart_hello_world.d

# 內容範例：
gcc/uart_hello_world.o: uart_hello_world.c \
  lm3s_config.h \
  ../../lm3s/lm3s_cmsis.h \
  ../../CMSIS/Include/core_cm3.h \
  ../../CMSIS/Include/core_cmFunc.h
```

這表示：
- 如果 `uart_hello_world.c` 修改 → 重新編譯
- 如果 `lm3s_config.h` 修改 → 重新編譯
- 如果 `core_cm3.h` 修改 → 重新編譯

```
┌──────────────────────────────────────────────────┐
│           依賴關係自動追蹤                          │
│                                                    │
│  uart_hello_world.c                               │
│    ↓ 包含 (include)                               │
│  lm3s_config.h                                    │
│    ↓ 包含                                         │
│  lm3s_cmsis.h                                     │
│    ↓ 包含                                         │
│  core_cm3.h                                       │
│                                                    │
│  如果任何一個檔案修改，                              │
│  uart_hello_world.o 會自動重新編譯                 │
│                                                    │
└──────────────────────────────────────────────────┘
```

---

## 6. 從所有範例根目錄編譯

專案也提供了頂層 Makefile：

```bash
# 從專案根目錄編譯所有範例
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S
make

# 清除所有編譯產物
make clean
```

---

## 7. 編譯最佳化等級

### 7.1 最佳化等級比較

```
┌─────────────────────────────────────────────────────────┐
│            GCC 最佳化等級                                 │
├─────────────────────────────────────────────────────────┤
│                                                           │
│  -O0  (預設)                                             │
│  ────────                                                │
│  • 不進行最佳化                                           │
│  • 編譯速度最快                                           │
│  • 程式碼大小最大                                         │
│  • 執行速度最慢                                           │
│  • 除錯最容易（程式碼與原始碼一一對應）                      │
│  ✓ 適合：開發階段、除錯                                   │
│                                                           │
│  -O1                                                     │
│  ────                                                    │
│  • 基本最佳化                                             │
│  • 不會顯著增加編譯時間                                    │
│  • 適度減小程式碼大小                                      │
│                                                           │
│  -O2                                                     │
│  ────                                                    │
│  • 進階最佳化                                             │
│  • 顯著減小程式碼大小                                      │
│  • 提升執行速度                                           │
│  • 除錯較困難（程式碼可能被重排）                           │
│  ✓ 適合：發布版本                                         │
│                                                           │
│  -O3                                                     │
│  ────                                                    │
│  • 最激進的最佳化                                         │
│  • 可能增加程式碼大小（函數內聯）                           │
│  • 最快的執行速度                                         │
│  • 除錯非常困難                                           │
│                                                           │
│  -Os                                                     │
│  ────                                                    │
│  • 優化程式碼大小                                         │
│  • 類似 -O2 但更注重空間                                  │
│  ✓ 適合：記憶體受限的嵌入式系統                            │
│                                                           │
└─────────────────────────────────────────────────────────┘
```

### 7.2 修改最佳化等級

要使用不同最佳化等級，修改 `makedefs` 中的 CFLAGS：

```makefile
# 原本
CFLAGS=-mthumb -mcpu=cortex-m3 -O0 ...

# 改為 -O2
CFLAGS=-mthumb -mcpu=cortex-m3 -O2 ...
```

---

## 8. 除錯符號

### 8.1 加入除錯符號

```bash
# 編譯時加入 DEBUG=1
make DEBUG=1

# 這會在 CFLAGS 加入 -g 參數
# makedefs:151
# CFLAGS+=-g -D DEBUG
```

有除錯符號的好處：
```
┌────────────────────────────────────────────┐
│  有除錯符號 (-g)                            │
│  ────────────────                          │
│  ✓ GDB 可以顯示原始碼                       │
│  ✓ GDB 可以設定函數名稱中斷點               │
│  ✓ GDB 可以顯示變數名稱                     │
│  ✓ GDB 可以顯示呼叫堆疊                     │
│  ✗ 檔案會變大                              │
│                                            │
│  沒有除錯符號                               │
│  ────────────                              │
│  ✗ 只能看到記憶體位址                       │
│  ✗ 只能用位址設中斷點                       │
│  ✓ 檔案較小                                │
│                                            │
└────────────────────────────────────────────┘
```

---

## 9. Makefile 進階技巧

### 9.1 平行編譯

```bash
# 使用 4 個 CPU 核心平行編譯
make -j4

# 自動偵測 CPU 核心數
make -j$(nproc)
```

### 9.2 只編譯不連結

```bash
# 只編譯 .c 到 .o（不連結成 .axf）
make gcc/uart_hello_world.o
```

### 9.3 查看 Makefile 變數

```bash
# 查看 CFLAGS 的值
make -p | grep "^CFLAGS"
```

---

## 10. 常見問題與排除

### 問題 1：找不到 arm-none-eabi-gcc

```bash
$ make
bash: arm-none-eabi-gcc: command not found
```

**解決**：
```bash
# 在 Ubuntu/Debian
sudo apt-get install gcc-arm-none-eabi

# 或使用本專案的 Docker 環境
docker run --rm -v $(pwd):/work -w /work \
    cmsis-lm3s-qemu:latest make
```

---

### 問題 2：編譯錯誤

```bash
error: 'UART0' undeclared
```

**檢查**：
1. 是否 `#include` 了正確的標頭檔
2. 是否定義了 `-DPART_LM3S6965`
3. 查看 `.d` 檔案確認依賴關係

---

### 問題 3：連結錯誤

```bash
undefined reference to `arm_fir_f32'
```

**解決**：
確認 Makefile 中有加入依賴：
```makefile
${COMPILER}/arm_fir_example_f32.axf: ${COMPILER}/arm_fir_f32.o
```

---

## 📝 實作練習

### 練習 1：編譯 UART 範例

```bash
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world
make clean
make
ls -lh gcc/
```

觀察編譯過程和產生的檔案。

---

### 練習 2：查看依賴關係

```bash
cat gcc/uart_hello_world.d
```

繪製依賴關係圖。

---

### 練習 3：使用除錯符號編譯

```bash
make clean
make DEBUG=1
ls -lh gcc/uart_hello_world.axf
```

比較有無 DEBUG 的檔案大小差異。

---

### 練習 4：修改最佳化等級

1. 編輯 `makedefs`，將 `-O0` 改成 `-O2`
2. 重新編譯
3. 比較檔案大小

<details>
<summary>預期結果</summary>

使用 `-O2` 後，`.bin` 檔案會變小，因為編譯器移除了冗餘程式碼並進行最佳化。

</details>

---

## 🎯 學習檢查點

完成本模組後，請確認你能：

- [ ] 說明編譯的四個階段（預處理、編譯、組譯、連結）
- [ ] 解釋交叉編譯的概念
- [ ] 理解 `arm-none-eabi-gcc` 命名的意義
- [ ] 解讀 makedefs 中的 CFLAGS 參數
- [ ] 使用 Makefile 編譯專案
- [ ] 理解 VPATH 搜尋路徑機制
- [ ] 查看並理解 .d 依賴檔案
- [ ] 區分 .axf 和 .bin 檔案的差異
- [ ] 知道如何加入除錯符號
- [ ] 理解不同最佳化等級的影響

---

## 🔗 下一步

恭喜完成模組 02！

你現在已經理解了程式編譯流程和 Makefile 系統。接下來在[模組 03：記憶體原理](03-記憶體原理.md)中，我們將學習程式如何被載入記憶體，以及 Linker Script 和啟動程式碼的運作原理。

---

**版本**：1.0
**更新日期**：2025-11-16
