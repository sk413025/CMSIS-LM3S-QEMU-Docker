# 模組 03：記憶體原理

> 理解程式如何載入記憶體：Linker Script 與啟動流程

---

## 📌 學習目標

完成本模組後，你將能夠：
- ✅ 理解 Flash 與 RAM 的差異與用途
- ✅ 認識 LM3S6965 的記憶體映射（Memory Map）
- ✅ 學會解讀 Linker Script (.ld 檔案)
- ✅ 了解程式啟動流程（從上電到 main）
- ✅ 理解中斷向量表的作用

**對應專案檔案**：
- [`examples/uart_hello_world/uart_hello_world.ld`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/uart_hello_world.ld) - Linker Script
- [`examples/uart_hello_world/startup_gcc.c`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/startup_gcc.c) - 啟動程式碼

---

## 🎯 學習之前：一個重要的問題

在開始之前，讓我們先思考一個問題：**當你的程式編譯完成後，這些程式碼和資料要放在哪裡？**

想像一下，你寫了一個程式，裡面有：
- 程式碼（函數、邏輯）
- 常數（像是 `const int MAX = 100;`）
- 已初始化變數（像是 `int counter = 0;`）
- 未初始化變數（像是 `int buffer[1000];`）

這些東西都需要「住」在記憶體的某個地方。但問題來了：微控制器有不同種類的記憶體（Flash 和 RAM），**它們該住在哪裡？誰來決定？**

這就是本模組要回答的問題！

---

## 1. 記憶體基礎回顧

### 1.1 為什麼需要兩種記憶體？

你可能會疑惑：**為什麼 LM3S6965 要有兩種記憶體（Flash 和 RAM）？一種不夠嗎？**

讓我用一個生活化的比喻來解釋：

**想像你是一位廚師**：
- **Flash = 食譜書**：記錄了所有料理步驟（程式碼）和固定配方（常數）。就算停電了，食譜還在那裡，不會消失。
- **RAM = 工作檯**：你實際料理時放食材、調味料的地方（變數）。速度快、方便存取，但一旦停電（斷電），工作檯就會被清空。

嵌入式系統也是一樣的道理：
- **Flash**：適合存放「不會變的東西」（程式碼、常數），斷電後依然保留
- **RAM**：適合存放「會變動的東西」（變數、計算結果），速度快但斷電就消失

---

### 1.2 LM3S6965 的記憶體配置

現在讓我們看看 LM3S6965 微控制器的記憶體是如何配置的：

```
┌────────────────────────────────────────────────────────────┐
│          LM3S6965 記憶體配置                                 │
├────────────────────────────────────────────────────────────┤
│                                                              │
│  Flash Memory (快閃記憶體)                                   │
│  ━━━━━━━━━━━━━━━━━━━━━                                     │
│  大小: 256 KB (0x40000 bytes)                               │
│  位址: 0x00000000 ~ 0x0003FFFF                              │
│  特性:                                                       │
│    ✓ 非揮發性（斷電資料保留）                                 │
│    ✓ 可讀、可寫（較慢）                                       │
│    ✓ 用途: 儲存程式碼、常數                                   │
│                                                              │
│  ┌─────────────────────────────────────┐                   │
│  │ 0x00000000  ┌───────────────────┐   │                   │
│  │             │  中斷向量表        │   │                   │
│  │             ├───────────────────┤   │                   │
│  │             │  程式碼 (.text)    │   │                   │
│  │             ├───────────────────┤   │                   │
│  │             │  常數 (.rodata)    │   │                   │
│  │             ├───────────────────┤   │                   │
│  │             │  初始化資料副本    │   │                   │
│  │ 0x0003FFFF  └───────────────────┘   │                   │
│  └─────────────────────────────────────┘                   │
│                                                              │
├────────────────────────────────────────────────────────────┤
│                                                              │
│  SRAM (靜態隨機存取記憶體)                                    │
│  ━━━━━━━━━━━━━━━━━━━━━                                     │
│  大小: 64 KB (0x10000 bytes)                                │
│  位址: 0x20000000 ~ 0x2000FFFF                              │
│  特性:                                                       │
│    ✓ 揮發性（斷電資料消失）                                   │
│    ✓ 快速讀寫                                                │
│    ✓ 用途: 儲存變數、堆疊、堆積                               │
│                                                              │
│  ┌─────────────────────────────────────┐                   │
│  │ 0x20000000  ┌───────────────────┐   │                   │
│  │             │  .data (已初始化)  │   │                   │
│  │             ├───────────────────┤   │                   │
│  │             │  .bss (未初始化)   │   │                   │
│  │             ├───────────────────┤   │                   │
│  │             │  Heap (堆積) ↓    │   │                   │
│  │             │        ...        │   │                   │
│  │             │  Stack (堆疊) ↑   │   │                   │
│  │ 0x2000FFFF  └───────────────────┘   │                   │
│  └─────────────────────────────────────┘                   │
│                                                              │
└────────────────────────────────────────────────────────────┘
```

**讓我們仔細解讀這張圖**：

#### Flash Memory（左側）

**位址範圍**：`0x00000000` 到 `0x0003FFFF`（共 256 KB）

這就像是一本「永久保存的筆記本」。上面圖示告訴我們，Flash 裡面從上到下依序存放：

1. **中斷向量表**（位於最開頭）：想像這是一本「緊急聯絡人名單」，告訴 CPU 發生各種事件時要找誰處理
2. **程式碼 (.text)**：你寫的所有函數、邏輯都在這裡
3. **常數 (.rodata)**：`ro` = read-only（唯讀），存放不會變的資料，像是字串 `"Hello"`
4. **初始化資料副本**：這個比較特別，稍後會詳細解釋

**為什麼位址從 0x00000000 開始？** 因為 ARM Cortex-M3 的規定：CPU 上電後會從位址 0x00000000 開始讀取第一個指令。所以 Flash 必須從這裡開始。

#### SRAM（右側）

**位址範圍**：`0x20000000` 到 `0x2000FFFF`（共 64 KB）

注意位址是 `0x2` 開頭，跟 Flash 的 `0x0` 不同！這表示它們是**完全分開的兩塊記憶體**。

SRAM 裡面存放（從上到下）：

1. **.data（已初始化變數）**：像是 `int x = 10;` 這種有給初始值的變數
2. **.bss（未初始化變數）**：像是 `int y;` 或 `int buffer[1000];` 這種沒給初始值的
3. **Heap（堆積）**：動態記憶體分配用（`malloc`）
4. **Stack（堆疊）**：儲存函數呼叫、區域變數

**為什麼是 0x20000000？** 這是 ARM Cortex-M3 的標準設計，SRAM 固定在這個位址範圍。

---

### 1.3 一個重要的問題：初始值從哪來？

看到上面的圖，你可能會想：「等等，`.data` 區段在 RAM 裡面，但 RAM 斷電就會清空，那變數的初始值怎麼保留？」

**非常好的問題！** 答案是：

1. **編譯時**：初始值被存在 Flash 的「初始化資料副本」區域
2. **啟動時**：有一段特殊的程式碼（startup code）會把這些初始值從 Flash **複製**到 RAM
3. **執行時**：程式就可以在 RAM 裡快速讀寫這些變數了

這就像是：
- Flash = 保險箱裡的「原始文件」
- RAM = 辦公桌上的「工作用副本」
- 每次開機 = 從保險箱把文件拿出來放到辦公桌

---

## 2. Linker Script 解析

### 2.1 什麼是 Linker Script？為什麼需要它？

在模組 02 我們學過，編譯過程的最後一步是「連結」（Linking），把多個 `.o` 檔案組合成一個可執行檔。但是連結器怎麼知道：
- `.text` 要放在 Flash 還是 RAM？
- `.data` 要放在哪個位址？
- 中斷向量表要放在哪裡？

**答案就是：Linker Script（連結器腳本）！**

想像你在搬家，Linker Script 就像是「家具擺放平面圖」：
- 哪些家具（程式碼、資料）要放在哪個房間（Flash、RAM）
- 每件家具的精確位置（記憶體位址）
- 房間的大小限制（記憶體容量）

**檔案位置**: [`examples/uart_hello_world/uart_hello_world.ld`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/uart_hello_world.ld)

---

### 2.2 MEMORY 區段：定義「房間」

讓我們看看 Linker Script 的第一部分：

```c
// uart_hello_world.ld:28-32
MEMORY
{
    FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000
    SRAM (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00010000
}
```

**這段程式碼在做什麼？** 它在告訴連結器：「我的微控制器有兩個記憶體區域」

讓我們逐行解析：

```
┌──────────────────────────────────────────────────────┐
│               MEMORY 定義解析                          │
├──────────────────────────────────────────────────────┤
│                                                        │
│  FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000│
│    ↑    ↑      ↑                    ↑                 │
│    │    │      │                    └─ 長度: 256 KB   │
│    │    │      └────────────────────── 起始: 0x0     │
│    │    └───────────────────────────── 權限: rx       │
│    └────────────────────────────────── 名稱: FLASH   │
│                                                        │
│  權限說明:                                             │
│    r = readable   (可讀)                              │
│    w = writable   (可寫)                              │
│    x = executable (可執行)                            │
│                                                        │
│  FLASH (rx)  → 可讀、可執行 (程式碼區域)               │
│  SRAM  (rwx) → 可讀、可寫、可執行 (資料區域)           │
│                                                        │
└──────────────────────────────────────────────────────┘
```

**詳細說明**：

**第一行：`FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000`**

- `FLASH`：這是我們給這塊記憶體取的名字，後面會用到
- `(rx)`：權限設定
  - `r` = readable（可讀）：CPU 可以讀取這裡的資料
  - `x` = executable（可執行）：CPU 可以把這裡當作指令執行
  - **沒有 w**：表示一般情況下不能隨便寫入（Flash 寫入較慢且有次數限制）
- `ORIGIN = 0x00000000`：這塊記憶體從位址 0 開始
- `LENGTH = 0x00040000`：長度是 0x40000 bytes = 256 KB

**第二行：`SRAM (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00010000`**

- `SRAM`：這塊記憶體的名字
- `(rwx)`：有讀、寫、執行的權限（因為變數需要被修改）
- `ORIGIN = 0x20000000`：從位址 0x20000000 開始
- `LENGTH = 0x00010000`：長度是 0x10000 bytes = 64 KB

**為什麼要標明權限？** 這是一種安全機制。如果程式碼不小心試圖寫入 Flash（通常是 bug），CPU 可以偵測到並報錯，而不是默默造成錯誤。

---

### 2.3 SECTIONS 區段：安排「家具」

定義好「房間」（MEMORY）之後，接下來要安排「家具」（程式碼和資料）放在哪裡：

```c
// uart_hello_world.ld:34-58
SECTIONS
{
    .text :
    {
        _text = .;
        KEEP(*(.isr_vector))
        *(.text*)
        *(.rodata*)
        _etext = .;
    } > FLASH

    .data : AT(ADDR(.text) + SIZEOF(.text))
    {
        _data = .;
        *(vtable)
        *(.data*)
        _edata = .;
    } > SRAM

    .bss :
    {
        _bss = .;
        *(.bss*)
        *(COMMON)
        _ebss = .;
    } > SRAM
}
```

**這段看起來很複雜，但別緊張！** 讓我們一個一個區段來理解。

---

#### 2.3.1 .text 區段（程式碼段）

```c
.text :
{
    _text = .;              // 標記起始位址
    KEEP(*(.isr_vector))   // 中斷向量表（強制保留）
    *(.text*)              // 所有程式碼
    *(.rodata*)            // 所有唯讀資料
    _etext = .;            // 標記結束位址
} > FLASH                   // 存放在 FLASH
```

讓我們逐行解釋：

**`_text = .;`**
- `_text` 是一個符號（symbol），代表 `.text` 區段的起始位址
- `.` 表示「當前位址」
- 這行的意思是：「記住 .text 的起始位址，取名叫 `_text`」
- 後面的 startup code 會用到這個符號

**`KEEP(*(.isr_vector))`**
- `*(.isr_vector)`：收集所有檔案中的 `.isr_vector` 區段
- `KEEP(...)`：**強制保留**，即使連結器認為沒用到也不要移除
- 為什麼要 KEEP？因為中斷向量表看起來像是「沒人呼叫的變數」，但其實 CPU 硬體會直接讀取，所以必須保留

**`*(.text*)`**
- `*`：所有檔案
- `.text*`：名稱以 `.text` 開頭的區段（包括 `.text.main`, `.text.foo` 等）
- 這會收集你所有的函數程式碼

**`*(.rodata*)`**
- `ro` = read-only
- `data` = 資料
- 收集所有唯讀資料，例如：
  ```c
  const char msg[] = "Hello";  // 存在 .rodata
  ```

**`_etext = .;`**
- `e` = end
- 標記 `.text` 區段的結束位址

**`} > FLASH`**
- 整個 `.text` 區段要放在 FLASH 裡面

---

現在讓我們看看這個區段在記憶體中的實際樣子：

```
┌──────────────────────────────────────────────────────────┐
│                  程式記憶體佈局                             │
├──────────────────────────────────────────────────────────┤
│                                                            │
│  .text 區段 (程式碼段) → 存放在 FLASH                       │
│  ━━━━━━━━━━━━━━━━━━━━                                    │
│                                                            │
│  ┌────────────────────────────────────────┐               │
│  │  FLASH  0x00000000                     │               │
│  │  ┌──────────────────────────────────┐  │               │
│  │  │  .isr_vector (中斷向量表)         │  │ ← KEEP()     │
│  │  │  • Reset_Handler 位址             │  │   強制保留   │
│  │  │  • NMI_Handler 位址               │  │              │
│  │  │  • HardFault_Handler 位址 ...    │  │              │
│  │  ├──────────────────────────────────┤  │               │
│  │  │  .text (程式碼)                   │  │               │
│  │  │  • main()                        │  │               │
│  │  │  • print_uart0()                 │  │               │
│  │  │  • 其他函數 ...                   │  │               │
│  │  ├──────────────────────────────────┤  │               │
│  │  │  .rodata (唯讀資料)               │  │               │
│  │  │  • 字串常數 "Hello World"        │  │               │
│  │  │  • const 變數                    │  │               │
│  │  └──────────────────────────────────┘  │               │
│  │         ↑                               │               │
│  │        _text (起始位址符號)              │               │
│  │         ↓                               │               │
│  │        _etext (結束位址符號)             │               │
│  └────────────────────────────────────────┘               │
│                                                            │
└──────────────────────────────────────────────────────────┘
```

**這張圖告訴我們**：

1. **中斷向量表必須在最前面**（0x00000000），因為 CPU 上電後會先讀這裡
2. **程式碼緊接在後面**，包含你所有的函數
3. **唯讀資料再接著**，像是字串常數
4. **`_text` 和 `_etext` 是書籤**，標記這個區段的開始和結束，startup code 會用到

---

#### 2.3.2 .data 區段（已初始化變數）

```c
.data : AT(ADDR(.text) + SIZEOF(.text))
{
    _data = .;
    *(vtable)
    *(.data*)
    _edata = .;
} > SRAM
```

這個區段比較複雜，讓我們仔細理解：

**`> SRAM`**
- 這個區段要存放在 SRAM（執行時存取）

**`AT(ADDR(.text) + SIZEOF(.text))`**
- 這是關鍵！`AT` 表示「Load Address」（載入位址）
- `ADDR(.text)`：取得 `.text` 的位址（0x00000000）
- `SIZEOF(.text)`：`.text` 的大小（假設是 0x1000）
- 合起來：**初始值存在 Flash 的 0x00000000 + 0x1000 = 0x00001000**

**為什麼需要 AT？** 因為：
- **執行時位址**：`.data` 在 SRAM（0x20000000）
- **存放位址**：初始值在 Flash（0x00001000）
- 開機時要從 Flash 複製到 SRAM

讓我們用圖來理解：

```
┌──────────────────────────────────────────────────────────┤
│                                                            │
│  .data 區段 (已初始化資料) → 存放在 SRAM                    │
│  ━━━━━━━━━━━━━━━━━━━━━━━                                 │
│                                                            │
│  ┌────────────────────────────────────────┐               │
│  │  SRAM  0x20000000                      │               │
│  │  ┌──────────────────────────────────┐  │               │
│  │  │  .data                           │  │               │
│  │  │  int x = 10;      // 初值 10     │  │               │
│  │  │  char msg[] = "Hi"; // 初值 "Hi" │  │               │
│  │  └──────────────────────────────────┘  │               │
│  │         ↑                               │               │
│  │        _data (起始)                     │               │
│  │         ↓                               │               │
│  │        _edata (結束)                    │               │
│  └────────────────────────────────────────┘               │
│                                                            │
│  問題：初始值從哪裡來？                                     │
│  答案：從 FLASH 複製！                                     │
│                                                            │
│  AT(ADDR(.text) + SIZEOF(.text))                          │
│    ↑                                                      │
│    └─ 告訴連結器：.data 的初始值存在 FLASH 的 .text 後面   │
│                                                            │
│  啟動時，startup code 會將這些初始值從 FLASH 複製到 SRAM   │
│                                                            │
└──────────────────────────────────────────────────────────┘
```

**實際流程是這樣的**：

1. **編譯時**：
   ```c
   int x = 10;  // 你寫的程式碼
   ```
   編譯器會把初始值 `10` 存在 Flash 裡

2. **開機時**（startup code 執行）：
   ```c
   // 從 Flash 複製到 SRAM
   *0x20000000 = *0x00001000;  // 把 10 複製過去
   ```

3. **執行時**（你的程式）：
   ```c
   x = 20;  // 修改的是 SRAM 裡的值，Flash 不動
   ```

**為什麼這樣設計？**
- Flash 斷電不會消失，可以保存初始值
- RAM 速度快，適合執行時讀寫
- 兩全其美！

---

#### 2.3.3 .bss 區段（未初始化變數）

```c
.bss :
{
    _bss = .;
    *(.bss*)
    *(COMMON)
    _ebss = .;
} > SRAM
```

這個區段相對簡單：

```
┌──────────────────────────────────────────────────────────┤
│                                                            │
│  .bss 區段 (未初始化資料) → 存放在 SRAM                     │
│  ━━━━━━━━━━━━━━━━━━━━━━                                  │
│                                                            │
│  ┌────────────────────────────────────────┐               │
│  │  SRAM  (緊接著 .data 之後)              │               │
│  │  ┌──────────────────────────────────┐  │               │
│  │  │  .bss                            │  │               │
│  │  │  int y;          // 初值 0       │  │               │
│  │  │  static int z;   // 初值 0       │  │               │
│  │  └──────────────────────────────────┘  │               │
│  │         ↑                               │               │
│  │        _bss (起始)                      │               │
│  │         ↓                               │               │
│  │        _ebss (結束)                     │               │
│  └────────────────────────────────────────┘               │
│                                                            │
│  BSS = Block Started by Symbol                            │
│  特性：                                                    │
│    • 不佔用 FLASH 空間（不需儲存初始值）                    │
│    • 啟動時由 startup code 清零                           │
│    • 節省程式大小                                          │
│                                                            │
└──────────────────────────────────────────────────────────┘
```

**BSS 的巧妙之處**：

假設你宣告了一個大陣列：
```c
int buffer[1000];  // 沒有初始化
```

**如果是 .data**（有初始值）：
- Flash 要存 1000 × 4 bytes = 4000 bytes 的初始值
- 程式檔案會變大 4000 bytes

**如果是 .bss**（沒初始值）：
- Flash 只需記錄「有一個 4000 bytes 的區域要清零」
- 程式檔案只增加幾個 bytes
- 開機時 startup code 跑一個迴圈把這塊記憶體清零即可

**這就是為什麼未初始化變數能節省程式大小！**

---

### 2.4 完整記憶體佈局圖

現在我們把所有東西整合起來看：

```
         FLASH (256 KB)              SRAM (64 KB)
  ┌───────────────────────┐    ┌───────────────────────┐
  │ 0x00000000            │    │ 0x20000000            │
  ├───────────────────────┤    ├───────────────────────┤
  │                       │    │                       │
  │  .isr_vector          │    │  .data                │
  │  (中斷向量表)          │    │  (已初始化變數)        │
  │  - Stack top pointer  │    │                       │
  │  - Reset_Handler      │    │  int x = 10;          │
  │  - NMI_Handler        │    │  char msg[] = "Hi";   │
  │  - ...                │    │                       │
  │                       │    ├───────────────────────┤
  ├───────────────────────┤    │                       │
  │                       │    │  .bss                 │
  │  .text                │    │  (未初始化變數)        │
  │  (程式碼)              │    │                       │
  │                       │    │  int y;               │
  │  main()               │    │  static int buffer[100];
  │  print_uart0()        │    │                       │
  │  ...                  │    ├───────────────────────┤
  │                       │    │                       │
  ├───────────────────────┤    │  Heap (堆積)          │
  │                       │    │  ↓ 向下成長            │
  │  .rodata              │    │                       │
  │  (唯讀資料/常數)       │    │  ...                  │
  │                       │    │                       │
  │  "Hello World"        │    │  Stack (堆疊)         │
  │  const float pi=3.14  │    │  ↑ 向上成長            │
  │                       │    │                       │
  ├───────────────────────┤    ├───────────────────────┤
  │                       │    │ 0x2000FFFF            │
  │  .data 初始值副本      │    └───────────────────────┘
  │  (用於啟動時複製)      │
  │                       │         ↑ 執行時使用
  ├───────────────────────┤
  │ 0x0003FFFF            │
  └───────────────────────┘
         ↑ 編譯時寫入
```

**這張完整的圖展示了**：

**左側（Flash）**：
- 從上到下依序是：中斷向量表 → 程式碼 → 唯讀資料 → .data 初始值
- 所有東西在編譯時就確定了，燒錄到 Flash 後就不會變
- 斷電後依然保留

**右側（SRAM）**：
- .data 和 .bss 在開機時由 startup code 準備好
- Heap 和 Stack 在程式執行時動態使用
- 斷電後全部消失

**中間的箭頭表示**：
- Flash 是「來源」（編譯時寫入）
- SRAM 是「工作區」（執行時使用）

---

## 3. 中斷向量表

### 3.1 什麼是中斷向量表？為什麼需要它？

在繼續之前，讓我們先理解**什麼是中斷**。

**生活化比喻**：

想像你正在專心看書（執行主程式），突然：
- 門鈴響了（UART 收到資料）
- 鬧鐘響了（計時器到時）
- 有人敲門（按鈕被按下）

你需要**暫停看書**，去處理這些事件，處理完再**繼續看書**。這就是「中斷」（Interrupt）！

**在微控制器裡**：
- CPU 正在執行你的 main() 函數
- 突然 UART 收到資料（硬體事件）
- CPU 需要知道「發生這個事件時，我該執行哪個函數？」

**中斷向量表就是這個「事件處理對照表」！**

---

### 3.2 中斷向量表的結構

讓我們看看專案中的實際程式碼：

**檔案位置**: [`examples/uart_hello_world/startup_gcc.c`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/startup_gcc.c)

```c
// startup_gcc.c 中的中斷向量表定義
__attribute__ ((section(".isr_vector")))
void (* const g_pfnVectors[])(void) =
{
    (void (*)(void))((unsigned long)&_stack_top),  // 0: Stack top
    Reset_Handler,                                  // 1: Reset
    NMI_Handler,                                    // 2: NMI
    HardFault_Handler,                              // 3: Hard Fault
    MemManage_Handler,                              // 4: Memory Management
    BusFault_Handler,                               // 5: Bus Fault
    UsageFault_Handler,                             // 6: Usage Fault
    0,                                              // 7: Reserved
    0,                                              // 8: Reserved
    0,                                              // 9: Reserved
    0,                                              // 10: Reserved
    SVC_Handler,                                    // 11: SVCall
    DebugMon_Handler,                               // 12: Debug Monitor
    0,                                              // 13: Reserved
    PendSV_Handler,                                 // 14: PendSV
    SysTick_Handler,                                // 15: SysTick
    // 外部中斷 (LM3S6965 特定)
    GPIOPortA_IRQHandler,                           // 16: GPIO Port A
    GPIOPortB_IRQHandler,                           // 17: GPIO Port B
    // ... 更多中斷處理器
    UART0_IRQHandler,                               // 21: UART0
    UART1_IRQHandler,                               // 22: UART1
    // ... 共 47+ 個中斷向量
};
```

**讓我們逐步理解這段程式碼**：

**`__attribute__ ((section(".isr_vector")))`**
- 這是告訴編譯器：「這個陣列要放在 `.isr_vector` 區段」
- 還記得 Linker Script 裡的 `KEEP(*(.isr_vector))` 嗎？就是這裡！
- 這樣這個陣列會被放在 Flash 的最開頭（0x00000000）

**`void (* const g_pfnVectors[])(void)`**
- 這是一個**函數指標陣列**
- `void (*)(void)` = 「指向無參數無返回值函數的指標」
- `const` = 這個陣列是常數，不會被修改
- `g_pfnVectors` = 陣列的名字（global pointer to functions for vectors）

**陣列內容**：
- 第 0 項：堆疊頂端位址（特殊，不是函數）
- 第 1 項：Reset_Handler（重置時執行）
- 第 2 項：NMI_Handler（Non-Maskable Interrupt）
- ...
- 第 21 項：UART0_IRQHandler（UART0 中斷時執行）

---

現在讓我們看看這個陣列在記憶體中的實際樣子：

```
┌──────────────────────────────────────────────────────────┐
│          中斷向量表在記憶體中的佈局                         │
├──────────────────────────────────────────────────────────┤
│                                                            │
│  FLASH 0x00000000                                         │
│  ┌──────────────────────────────────────────────────┐    │
│  │  Offset    內容                    說明            │    │
│  ├──────────────────────────────────────────────────┤    │
│  │  0x00      0x20010000             堆疊頂端位址    │    │
│  │            (_stack_top)                          │    │
│  ├──────────────────────────────────────────────────┤    │
│  │  0x04      0x00000341             Reset_Handler  │    │
│  │            (Reset 處理器位址)                     │    │
│  ├──────────────────────────────────────────────────┤    │
│  │  0x08      0x000003A5             NMI_Handler    │    │
│  ├──────────────────────────────────────────────────┤    │
│  │  0x0C      0x000003A7             HardFault      │    │
│  ├──────────────────────────────────────────────────┤    │
│  │  ...       ...                    ...            │    │
│  ├──────────────────────────────────────────────────┤    │
│  │  0x54      0x000004B1             UART0_IRQHandler    │
│  ├──────────────────────────────────────────────────┤    │
│  │  ...       ...                    ...            │    │
│  └──────────────────────────────────────────────────┘    │
│                                                            │
│  當 CPU 上電或重置時：                                     │
│  1. 從 0x00 讀取堆疊指標 (SP) 的初始值                     │
│  2. 從 0x04 讀取 Reset_Handler 的位址                     │
│  3. 跳到 Reset_Handler 執行                               │
│                                                            │
│  當發生中斷時 (例如 UART0 收到資料)：                       │
│  1. CPU 自動查表找到 UART0_IRQHandler 位址                │
│  2. 跳到 UART0_IRQHandler 執行                            │
│  3. 執行完畢後返回原程式                                   │
│                                                            │
└──────────────────────────────────────────────────────────┘
```

**這張圖的關鍵資訊**：

1. **每個項目佔 4 bytes**（32-bit ARM）
   - 0x00 ~ 0x03：第 0 項（堆疊頂端）
   - 0x04 ~ 0x07：第 1 項（Reset_Handler）
   - 0x08 ~ 0x0B：第 2 項（NMI_Handler）
   - ...依此類推

2. **第 0 項很特殊**
   - 不是函數位址，而是堆疊指標的初始值
   - CPU 上電後會讀取這個值設定 SP（Stack Pointer）

3. **第 1 項是 Reset_Handler**
   - CPU 上電後執行的第一個函數
   - 負責初始化系統（複製 .data、清零 .bss、呼叫 main）

4. **硬體自動查表**
   - 當 UART0 產生中斷，CPU 硬體會**自動**讀取位址 0x54 的內容
   - 跳到該位址執行（不需要你寫程式碼去查表）

---

### 3.3 WEAK 屬性：一個聰明的設計

你可能會想：「我的程式可能不會用到所有 47 個中斷，那我是不是要實作 47 個函數？」

**答案是：不用！** 這就是 `WEAK` 屬性的巧妙之處：

```c
#define WEAK __attribute__ ((weak))

void WEAK UART0_IRQHandler(void);
```

讓我們看看它如何運作：

```
┌────────────────────────────────────────────────┐
│          WEAK 弱符號機制                        │
├────────────────────────────────────────────────┤
│                                                 │
│  startup_gcc.c:                                │
│  void WEAK UART0_IRQHandler(void) {            │
│      while(1) { }  // 預設實作：無窮迴圈        │
│  }                                              │
│                                                 │
│  你的程式 (uart_app.c):                        │
│  void UART0_IRQHandler(void) {                 │
│      // 你的處理邏輯                            │
│      process_uart_data();                      │
│  }                                              │
│                                                 │
│  連結時：                                       │
│  ┌─────────────────────────────────────┐       │
│  │  強符號優先於弱符號                  │       │
│  │  使用你的實作，忽略 startup 的預設   │       │
│  └─────────────────────────────────────┘       │
│                                                 │
│  好處：                                         │
│  ✓ 你只需實作用到的中斷處理器                   │
│  ✓ 未實作的會使用預設版本（安全的無窮迴圈）      │
│  ✓ 不會有「未定義符號」連結錯誤                 │
│                                                 │
└────────────────────────────────────────────────┘
```

**實際例子**：

假設你只用到 UART0，不用 UART1：

**你的程式碼**：
```c
void UART0_IRQHandler(void) {
    // 處理 UART0 中斷
    handle_uart_data();
}

// 不需要寫 UART1_IRQHandler
```

**連結時發生什麼**：
1. 連結器找到 `UART0_IRQHandler`
   - startup_gcc.c 有一個 WEAK 版本
   - 你的程式有一個強版本
   - 使用你的版本（強符號優先）

2. 連結器找到 `UART1_IRQHandler`
   - startup_gcc.c 有一個 WEAK 版本
   - 你沒有提供
   - 使用 WEAK 版本（無窮迴圈，確保不會亂跑）

**為什麼預設是無窮迴圈？**
- 如果中斷發生但沒有處理函數，直接返回會導致同樣的中斷不斷發生
- 無窮迴圈會讓系統「卡住」，讓你知道有問題（更容易 debug）

---

## 4. 程式啟動流程

### 4.1 從上電到 main()：一段神奇的旅程

現在我們終於要揭開「微控制器開機」的完整過程了！

想像一下，你剛把微控制器接上電源，**CPU 完全不知道要做什麼**。沒有作業系統、沒有 BIOS，它只知道一件事：「從位址 0x00000000 開始」。

讓我們看看從上電到執行你的 `main()` 函數，中間發生了什麼：

```
┌──────────────────────────────────────────────────────────┐
│              ARM Cortex-M3 啟動流程                        │
│                                                            │
│  ⚡ 上電 / 重置                                            │
│  │                                                         │
│  ↓                                                         │
│  ┌────────────────────────────────────────────┐           │
│  │ 步驟 1: 硬體初始化                          │           │
│  │  • CPU 從 0x00000000 開始                  │           │
│  │  • 讀取 0x00 → 設定 SP (堆疊指標)           │           │
│  │    SP = 0x20010000                         │           │
│  │  • 讀取 0x04 → 取得 Reset_Handler 位址     │           │
│  │    PC = Reset_Handler                      │           │
│  └────────────────────────────────────────────┘           │
│  │                                                         │
│  ↓                                                         │
│  ┌────────────────────────────────────────────┐           │
│  │ 步驟 2: Reset_Handler 執行                 │           │
│  │  (定義在 startup_gcc.c)                    │           │
│  └────────────────────────────────────────────┘           │
│  │                                                         │
│  ↓                                                         │
│  ┌────────────────────────────────────────────┐           │
│  │ 步驟 2.1: 複製 .data 初始值                │           │
│  │                                            │           │
│  │  從 FLASH 複製到 SRAM:                     │           │
│  │  ┌─────────┐      ┌─────────┐             │           │
│  │  │ FLASH   │ ───→ │  SRAM   │             │           │
│  │  │ .data   │ 複製  │ .data   │             │           │
│  │  │ 初始值  │      │         │             │           │
│  │  └─────────┘      └─────────┘             │           │
│  │                                            │           │
│  │  程式碼範例:                                │           │
│  │  unsigned long *src = &_etext;            │           │
│  │  unsigned long *dst = &_data;             │           │
│  │  while (dst < &_edata) {                  │           │
│  │      *dst++ = *src++;                     │           │
│  │  }                                        │           │
│  └────────────────────────────────────────────┘           │
│  │                                                         │
│  ↓                                                         │
│  ┌────────────────────────────────────────────┐           │
│  │ 步驟 2.2: 清零 .bss                        │           │
│  │                                            │           │
│  │  將 .bss 區段全部設為 0:                   │           │
│  │  ┌─────────┐                               │           │
│  │  │  SRAM   │                               │           │
│  │  │  .bss   │ ← 全部填 0                    │           │
│  │  │ 0 0 0 0 │                               │           │
│  │  └─────────┘                               │           │
│  │                                            │           │
│  │  程式碼範例:                                │           │
│  │  unsigned long *dst = &_bss;              │           │
│  │  while (dst < &_ebss) {                   │           │
│  │      *dst++ = 0;                          │           │
│  │  }                                        │           │
│  └────────────────────────────────────────────┘           │
│  │                                                         │
│  ↓                                                         │
│  ┌────────────────────────────────────────────┐           │
│  │ 步驟 2.3: 呼叫系統初始化                    │           │
│  │  SystemInit();                             │           │
│  │  • 設定時脈                                │           │
│  │  • 配置 PLL                                │           │
│  │  (定義在 system_lm3s.c)                    │           │
│  └────────────────────────────────────────────┘           │
│  │                                                         │
│  ↓                                                         │
│  ┌────────────────────────────────────────────┐           │
│  │ 步驟 3: 呼叫 main()                        │           │
│  │  main();                                   │           │
│  │  你的程式開始執行！                         │           │
│  └────────────────────────────────────────────┘           │
│  │                                                         │
│  ↓                                                         │
│  ┌────────────────────────────────────────────┐           │
│  │ 步驟 4: main() 返回後                      │           │
│  │  while(1) { }  // 無窮迴圈                 │           │
│  │  (嵌入式系統通常不會返回)                   │           │
│  └────────────────────────────────────────────┘           │
│                                                            │
└──────────────────────────────────────────────────────────┘
```

**讓我們詳細走過每一步**：

---

#### 步驟 1：硬體初始化（CPU 自己做的）

**上電瞬間，CPU 做了這些事**：

1. **讀取位址 0x00**（中斷向量表第 0 項）
   - 內容：0x20010000（堆疊頂端位址）
   - CPU 把這個值寫入 SP（Stack Pointer）暫存器
   - **為什麼？** 因為接下來要執行程式碼，需要堆疊來儲存函數呼叫資訊

2. **讀取位址 0x04**（中斷向量表第 1 項）
   - 內容：0x00000341（假設 Reset_Handler 在這個位址）
   - CPU 把這個值寫入 PC（Program Counter）暫存器
   - **結果：** CPU 跳到 Reset_Handler 開始執行

**注意**：這兩步是 ARM Cortex-M3 的**硬體行為**，不需要你寫程式碼！

---

#### 步驟 2.1：複製 .data 初始值

**為什麼要複製？**
- 你的程式有變數：`int counter = 5;`
- 初始值 `5` 存在 Flash（斷電不會消失）
- 但程式執行時需要在 RAM 裡讀寫（速度快）
- 所以要把初始值從 Flash **複製**到 RAM

**實際程式碼**（在 Reset_Handler 裡）：
```c
unsigned long *src = &_etext;   // Flash 的位址
unsigned long *dst = &_data;    // RAM 的位址

while (dst < &_edata) {
    *dst++ = *src++;  // 一個一個 byte 複製
}
```

**還記得 Linker Script 裡的符號嗎？**
- `_etext`：`.text` 結束位址，也是 `.data` 初始值在 Flash 的起始位址
- `_data`：`.data` 在 SRAM 的起始位址
- `_edata`：`.data` 在 SRAM 的結束位址

**比喻**：這就像是每次開工，要先從保險箱（Flash）把今天要用的文件（初始值）拿出來放到辦公桌（RAM）上。

---

#### 步驟 2.2：清零 .bss

**為什麼要清零？**
- C 語言規定：未初始化的全域變數、靜態變數初始值是 0
- 但 RAM 上電後是**隨機數值**（垃圾資料）
- 所以必須手動清零

**實際程式碼**：
```c
unsigned long *dst = &_bss;

while (dst < &_ebss) {
    *dst++ = 0;  // 設為 0
}
```

**舉例**：
```c
int x;              // 未初始化，應該是 0
static int y;       // 未初始化，應該是 0
int buffer[1000];   // 未初始化，應該全是 0
```

如果不清零，這些變數可能是 `0x5A3F1234` 之類的隨機數值，會造成程式錯誤！

---

#### 步驟 2.3：呼叫系統初始化

```c
SystemInit();
```

這個函數（定義在 `system_lm3s.c`）負責：
- 設定系統時脈（例如從 8 MHz 提升到 50 MHz）
- 配置 PLL（Phase-Locked Loop，倍頻器）
- 初始化周邊時脈

**為什麼需要這步？**
- CPU 預設可能只跑 8 MHz（很慢）
- 透過設定可以提升到 50 MHz
- 這需要寫入特定暫存器

---

#### 步驟 3：呼叫 main()

```c
main();
```

**終於！** 你的程式開始執行了！

到這裡為止，所有準備工作都完成了：
- ✅ 堆疊已設定
- ✅ .data 已複製
- ✅ .bss 已清零
- ✅ 系統時脈已設定

現在 `main()` 裡的程式碼可以安全地執行了。

---

#### 步驟 4：main() 返回後

在一般的電腦程式，`main()` 結束後程式就終止了。但**嵌入式系統不一樣**！

```c
while(1) {
    // 無窮迴圈
}
```

**為什麼？**
- 嵌入式系統沒有作業系統可以「返回」
- 如果 `main()` 結束，CPU 會繼續執行下一個位址的指令（可能是垃圾資料）
- 無窮迴圈確保 CPU 「停在這裡」

**最佳實踐**：
```c
int main(void) {
    init_hardware();

    while(1) {  // 主迴圈
        do_something();
    }

    // 程式不應該跑到這裡
}
```

---

### 4.2 Reset_Handler 實際程式碼

讓我們看看完整的 Reset_Handler 程式碼（簡化版）：

```c
void Reset_Handler(void)
{
    unsigned long *pulsrc, *puldst;

    // 1. 複製 .data 初始值從 FLASH 到 SRAM
    pulsrc = &_etext;  // FLASH 中 .data 初始值的位址
    for(puldst = &_data; puldst < &_edata; )
    {
        *puldst++ = *pulsrc++;
    }

    // 2. 清零 .bss 區段
    for(puldst = &_bss; puldst < &_ebss; )
    {
        *puldst++ = 0;
    }

    // 3. 呼叫系統初始化
    SystemInit();

    // 4. 呼叫 main()
    main();

    // 5. 如果 main() 返回（不應該發生），進入無窮迴圈
    while(1)
    {
    }
}
```

**這段程式碼的每一行都至關重要**！沒有它，你的程式無法正確執行。

**思考**：
- 如果沒有步驟 1，已初始化變數會是隨機數值
- 如果沒有步驟 2，未初始化變數不會是 0
- 如果沒有步驟 3，CPU 可能只跑 8 MHz
- 如果沒有步驟 5，main() 返回後會發生不可預測的行為

---

## 5. 實際範例分析

### 5.1 查看 UART 範例的記憶體使用

現在讓我們用實際的工具來查看我們的程式使用了多少記憶體：

```bash
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world
make

# 查看各區段大小
arm-none-eabi-size gcc/uart_hello_world.axf

# 輸出範例：
#    text    data     bss     dec     hex filename
#     512      16      64     592     250 uart_hello_world.axf
#      ↑       ↑       ↑
#      │       │       └─ .bss 大小 (未初始化變數)
#      │       └───────── .data 大小 (已初始化變數)
#      └───────────────── .text + .rodata 大小 (程式碼+常數)
```

**解讀這個輸出**：

- **text = 512 bytes**
  - 包含 `.text`（程式碼）和 `.rodata`（常數）
  - 存放在 Flash
  - 這個範例的程式碼很小，只有 512 bytes

- **data = 16 bytes**
  - 已初始化變數
  - 需要在 Flash 存 16 bytes（初始值）
  - 需要在 SRAM 占 16 bytes（執行時）

- **bss = 64 bytes**
  - 未初始化變數
  - 不佔 Flash 空間（只需清零）
  - 在 SRAM 占 64 bytes

- **dec = 592 bytes**
  - 總共使用 = 512 + 16 + 64 = 592 bytes

**Flash 實際佔用**：512 + 16 = 528 bytes（不包括 bss）
**SRAM 實際佔用**：16 + 64 = 80 bytes

這就是為什麼 `.bss` 能節省程式大小！64 bytes 的未初始化變數完全不佔 Flash。

---

### 5.2 使用 objdump 查看區段

如果你想看更詳細的資訊：

```bash
# 查看所有區段資訊
arm-none-eabi-objdump -h gcc/uart_hello_world.axf

# 輸出範例：
# Idx Name          Size      VMA       LMA       File off  Algn
#   0 .text         000001a0  00000000  00000000  00008000  2**2
#                   CONTENTS, ALLOC, LOAD, READONLY, CODE
#   1 .data         00000010  20000000  000001a0  00010000  2**2
#                   CONTENTS, ALLOC, LOAD, DATA
#   2 .bss          00000040  20000010  000001b0  00010010  2**2
#                   ALLOC
```

**讓我們解讀每一欄**：

**Name**：區段名稱
**Size**：大小
**VMA**（Virtual Memory Address）：執行時位址
**LMA**（Load Memory Address）：存放位址
**File off**：在 .axf 檔案中的偏移量
**Algn**：對齊要求（2**2 = 4 bytes 對齊）

**重點觀察**：

**.text 區段**：
- Size: 0x1A0 (416 bytes)
- VMA = LMA = 0x00000000（在 Flash，執行位址 = 存放位址）

**.data 區段**：
- Size: 0x10 (16 bytes)
- VMA: 0x20000000（執行時在 SRAM）
- LMA: 0x000001A0（存放在 Flash，緊接在 .text 後面）
- **VMA ≠ LMA**：這就是為什麼需要複製！

**.bss 區段**：
- Size: 0x40 (64 bytes)
- VMA: 0x20000010（在 SRAM，緊接在 .data 後面）
- 沒有 LMA（不佔 Flash）
- 沒有 `CONTENTS` 標記（不需存放資料）

---

### 5.3 查看符號表

符號表告訴我們各個符號的位址：

```bash
# 查看所有符號
arm-none-eabi-nm gcc/uart_hello_world.axf | grep -E "_text|_data|_bss|_stack"

# 輸出範例：
# 00000000 T _text        # .text 起始位址
# 000001a0 T _etext       # .text 結束位址
# 20000000 D _data        # .data 起始位址
# 20000010 D _edata       # .data 結束位址
# 20000010 B _bss         # .bss 起始位址
# 20000050 B _ebss        # .bss 結束位址
# 20010000 D _stack_top   # 堆疊頂端
```

**這些符號在哪裡定義的？** Linker Script！還記得 `_text = .;` 這些語句嗎？

**符號類型**：
- `T`（Text）：程式碼區段
- `D`（Data）：已初始化資料區段
- `B`（BSS）：未初始化資料區段

**驗證我們的理解**：
- `.text` 從 0x00000000 到 0x000001a0，大小 = 0x1a0 ✅
- `.data` 從 0x20000000 到 0x20000010，大小 = 0x10 ✅
- `.bss` 從 0x20000010 到 0x20000050，大小 = 0x40 ✅
- 堆疊從 0x20010000 開始（SRAM 最頂端）✅

---

## 6. 堆疊 (Stack)

### 6.1 什麼是堆疊？

堆疊（Stack）是程式執行時**非常重要**的記憶體區域。讓我們用生活化的比喻來理解：

**想像堆疊是一疊盤子**：
- 洗好的盤子一個一個**往上疊**（PUSH）
- 要用盤子時從**最上面拿**（POP）
- 永遠只能操作最上面的盤子（LIFO：Last In First Out）

在程式裡，堆疊用來：

```
┌──────────────────────────────────────────────────────┐
│                  堆疊用途                              │
├──────────────────────────────────────────────────────┤
│                                                        │
│  1. 儲存區域變數                                       │
│     void foo() {                                      │
│         int x = 10;  ← 存在堆疊                        │
│     }                                                 │
│                                                        │
│  2. 儲存函數返回位址                                   │
│     呼叫 foo() → 將返回位址壓入堆疊                    │
│     foo() 結束 → 從堆疊取出返回位址                    │
│                                                        │
│  3. 傳遞函數參數（超過暫存器數量時）                    │
│                                                        │
│  4. 儲存暫存器狀態（中斷發生時）                        │
│                                                        │
└──────────────────────────────────────────────────────┘
```

**實際例子**：

```c
void bar() {
    int c = 30;
    // ...
}

void foo() {
    int b = 20;
    bar();  // 呼叫 bar
    // ...
}

int main() {
    int a = 10;
    foo();  // 呼叫 foo
    return 0;
}
```

**堆疊變化過程**：

```
main() 執行：              foo() 執行：               bar() 執行：
┌────────────┐            ┌────────────┐            ┌────────────┐
│            │            │  c = 30    │            │  c = 30    │ ← SP
│            │            ├────────────┤            ├────────────┤
│            │            │ 返回位址   │            │ 返回位址   │
│            │            ├────────────┤            ├────────────┤
│            │            │  b = 20    │            │  b = 20    │
│            │            ├────────────┤            ├────────────┤
│            │            │ 返回位址   │            │ 返回位址   │
│  a = 10    │ ← SP       ├────────────┤            ├────────────┤
├────────────┤            │  a = 10    │            │  a = 10    │
│            │            ├────────────┤            ├────────────┤
└────────────┘            │            │            │            │
```

**注意 SP（Stack Pointer）的位置**：每次函數呼叫，SP 往上移；函數返回，SP 往下移。

---

### 6.2 堆疊成長方向

ARM Cortex-M3 的堆疊有個特別的地方：**向下成長**！

```
         SRAM (64 KB)
  ┌─────────────────────┐
  │ 0x20000000          │
  ├─────────────────────┤
  │  .data              │
  ├─────────────────────┤
  │  .bss               │
  ├─────────────────────┤  ← Heap 起始
  │                     │
  │  Heap ↓             │  向下成長
  │                     │
  │  ...                │
  │                     │
  │  Stack ↑            │  向上成長（但 SP 遞減）
  │                     │
  ├─────────────────────┤  ← _stack_top (0x20010000)
  │ 0x2000FFFF          │
  └─────────────────────┘

  Stack Pointer (SP) 從 0x20010000 開始
  每次 PUSH → SP 減少
  每次 POP  → SP 增加
```

**為什麼向下成長？**
- SP 初始值 = 0x20010000（SRAM 最高位址 + 1）
- PUSH 時：先遞減 SP，再寫入資料（SP = SP - 4, [SP] = data）
- POP 時：先讀取資料，再遞增 SP（data = [SP], SP = SP + 4）

**Stack 和 Heap 的「相遇」問題**：
- Heap 從下往上成長（malloc 分配記憶體）
- Stack 從上往下成長（函數呼叫）
- 如果它們相遇了 = **Stack Overflow**（堆疊溢位）！

**如何避免？**
- 不要遞迴太深
- 不要在函數裡宣告超大陣列
- 監控堆疊使用量

---

## 📝 實作練習

### 練習 1：查看 Linker Script

```bash
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world
cat uart_hello_world.ld
```

**回答下列問題**：

1. FLASH 的起始位址是多少？
2. SRAM 的大小是多少 KB？
3. .text 區段存放在哪裡（FLASH 還是 SRAM）？
4. 中斷向量表區段的名稱是什麼？

<details>
<summary>點擊查看解答</summary>

1. `0x00000000`（看 `ORIGIN` 欄位）
2. 64 KB（看 `LENGTH = 0x00010000`，0x10000 = 65536 bytes = 64 KB）
3. FLASH（看 `.text :` 區段結尾的 `> FLASH`）
4. `.isr_vector`（看 `KEEP(*(.isr_vector))`）

</details>

---

### 練習 2：查看記憶體使用

```bash
make
arm-none-eabi-size gcc/uart_hello_world.axf
```

**任務**：
1. 記錄 text, data, bss 的大小
2. 計算 Flash 實際佔用（text + data）
3. 計算 SRAM 實際佔用（data + bss）

<details>
<summary>點擊查看範例解答</summary>

假設輸出是：
```
   text    data     bss     dec     hex
    512      16      64     592     250
```

則：
- Flash 佔用 = 512 + 16 = 528 bytes
- SRAM 佔用 = 16 + 64 = 80 bytes

</details>

---

### 練習 3：查看中斷向量表

```bash
cat startup_gcc.c | grep -A 50 "g_pfnVectors"
```

**任務**：
1. 數一數有多少個中斷向量
2. 找出 Reset_Handler 在第幾個位置
3. 找出 UART0_IRQHandler 在第幾個位置

---

### 練習 4：使用 GDB 查看記憶體

這個練習需要兩個終端：

**終端 1：啟動 QEMU GDB Server**
```bash
docker run --rm -d \
    -v /home/sbplab/jiawei/qemu/CMSIS_LM3S:/work:ro \
    -p 1234:1234 \
    --name qemu_gdb_server \
    cmsis-lm3s-qemu:latest \
    bash -c "cd /work/examples/uart_hello_world/gcc && \
             exec qemu-system-arm -M lm3s6965evb -nographic \
                  -kernel uart_hello_world.bin -s -S"
```

**終端 2：啟動 GDB**
```bash
docker run --rm -it \
    -v /home/sbplab/jiawei/qemu/CMSIS_LM3S:/work:ro \
    --network host \
    cmsis-lm3s-gdb:latest \
    bash -c "cd /work/examples/uart_hello_world/gcc && \
             gdb-multiarch uart_hello_world.axf"
```

**在 GDB 中執行**：
```gdb
(gdb) target remote localhost:1234
(gdb) x/16x 0x00000000         # 查看中斷向量表
(gdb) print/x &_text           # 查看符號位址
(gdb) print/x &_data
(gdb) print/x &_bss
(gdb) print/x &_stack_top
```

**任務**：
1. 記錄中斷向量表的前 4 個項目
2. 驗證 `_text`, `_data`, `_bss` 的位址是否與 `nm` 指令輸出一致

---

## 🎯 學習檢查點

完成本模組後，請確認你能：

**基礎概念**：
- [ ] 用自己的話解釋 Flash 與 RAM 的差異
- [ ] 說明為什麼需要兩種記憶體
- [ ] 解釋 LM3S6965 的記憶體映射（0x00000000 和 0x20000000）

**Linker Script**：
- [ ] 理解 MEMORY 區段的作用
- [ ] 理解 SECTIONS 區段的作用
- [ ] 說明 .text, .data, .bss 三個區段的用途和位置
- [ ] 解釋為什麼 .data 需要從 FLASH 複製到 SRAM
- [ ] 理解 `AT()` 的作用

**中斷向量表**：
- [ ] 解釋什麼是中斷向量表
- [ ] 理解中斷向量表的結構（為什麼在 0x00000000）
- [ ] 說明 WEAK 屬性的用途和好處
- [ ] 理解 KEEP() 的作用

**啟動流程**：
- [ ] 描述從上電到 main() 的完整流程（至少 4 個步驟）
- [ ] 解釋 Reset_Handler 的作用
- [ ] 理解為什麼要複製 .data
- [ ] 理解為什麼要清零 .bss

**堆疊**：
- [ ] 說明堆疊的 4 個主要用途
- [ ] 理解堆疊的成長方向（向下成長的意義）
- [ ] 知道什麼是 Stack Overflow

---

## 🔗 下一步

🎉 **恭喜完成模組 03！**

你現在已經理解了：
- 程式如何被載入記憶體
- Linker Script 如何規劃記憶體佈局
- CPU 如何從上電到執行你的程式
- 中斷向量表的運作機制

這些都是**非常底層但非常重要**的知識！很多嵌入式工程師工作多年都不一定完全理解這些細節。

接下來在 [模組 04：嵌入式系統入門](04-嵌入式系統入門.md) 中，我們將實際操作 LM3S6965 微控制器，學習：
- UART 通訊（讓微控制器「說話」）
- 暫存器操作（直接控制硬體）
- 實際的嵌入式程式開發

準備好了嗎？讓我們繼續前進！

---

**版本**：2.0
**更新日期**：2025-11-16
**更新內容**：增加大量白話文字解釋、生活化比喻、逐步引導說明
