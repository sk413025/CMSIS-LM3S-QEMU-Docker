# 模組 04：嵌入式系統入門

> 實際操作 LM3S6965：UART 通訊與暫存器操作

---

## 📌 學習目標

完成本模組後，你將能夠：
- ✅ 理解嵌入式系統與一般電腦的差異
- ✅ 認識 LM3S6965 微控制器規格
- ✅ 學會 UART 串列通訊原理
- ✅ 理解暫存器直接存取方式
- ✅ 實際執行並除錯 UART 範例

**對應專案檔案**:
- [`examples/uart_hello_world/uart_hello_world.c`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/uart_hello_world.c) - UART 範例程式
- [`lm3s/lm3s_cmsis.h`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/lm3s/lm3s_cmsis.h) - 硬體定義檔

---

## 🎯 學習之前：一個重要的觀念轉換

在前面的模組中，我們學習了很多「幕後」的知識：記憶體佈局、編譯過程、啟動流程。現在，**終於要開始實際操作硬體了！**

但在開始之前，我們需要先理解一個重要問題：

**嵌入式系統和你平常用的電腦有什麼不同？為什麼需要用完全不同的方式來思考和編程？**

想像一下：
- 你的手機能跑好幾天不用充電嗎？❌
- 你的電腦能在 -40°C 到 85°C 的環境下工作嗎？❌
- 你的筆電能在 0.1 秒內對緊急事件做出反應嗎？❌

但嵌入式系統可以！這就是為什麼它們被用在汽車、醫療設備、工業控制等領域。

讓我們來看看這兩者到底有什麼不同。

---

## 1. 嵌入式系統 vs 一般電腦

### 1.1 硬體規格比較

首先，讓我們看看硬體規格的差異：

```
┌────────────────────────────────────────────────────────┐
│           桌上型電腦 vs 嵌入式系統                        │
├────────────────────────────────────────────────────────┤
│                                                          │
│  桌上型電腦 (Desktop PC)                                │
│  ━━━━━━━━━━━━━━━━━━                                    │
│  CPU: Intel/AMD x86_64, 多核心, 3+ GHz                 │
│  RAM: 8-64 GB                                           │
│  儲存: 512GB-2TB SSD                                    │
│  OS: Windows/Linux/macOS                                │
│  電源: 100-500W                                         │
│  用途: 通用計算、上網、遊戲、開發                         │
│  成本: $500-$2000+                                      │
│                                                          │
│  ┌────────────────────────────────────┐                │
│  │  • 強大運算能力                     │                │
│  │  • 豐富資源                        │                │
│  │  • 通用性高                        │                │
│  │  • 耗電量大                        │                │
│  └────────────────────────────────────┘                │
│                                                          │
├────────────────────────────────────────────────────────┤
│                                                          │
│  嵌入式系統 (Embedded System) - LM3S6965                │
│  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━                       │
│  CPU: ARM Cortex-M3, 單核心, 50 MHz                    │
│  RAM: 64 KB                                             │
│  儲存: 256 KB Flash                                     │
│  OS: 無（裸機）或 RTOS                                   │
│  電源: <100 mW                                          │
│  用途: 專用控制（馬達、感測器、通訊）                     │
│  成本: $2-$10                                           │
│                                                          │
│  ┌────────────────────────────────────┐                │
│  │  • 低功耗                          │                │
│  │  • 即時反應                        │                │
│  │  • 專用功能                        │                │
│  │  • 成本低廉                        │                │
│  └────────────────────────────────────┘                │
│                                                          │
└────────────────────────────────────────────────────────┘
```

**讓我們仔細解讀這張對比圖**：

#### CPU 差異

**桌上型電腦**：
- **3+ GHz**（3,000,000,000 Hz）= 每秒可以執行 30 億次指令
- **多核心**：通常有 4-16 個核心，可以同時執行多個任務
- **x86_64 架構**：複雜指令集，功能強大但耗電

**LM3S6965**：
- **50 MHz**（50,000,000 Hz）= 每秒可以執行 5000 萬次指令
- **單核心**：一次只能做一件事
- **ARM Cortex-M3**：精簡指令集，省電高效

**比喻**：桌上型電腦就像是一個大型工廠，有很多條生產線同時運作；嵌入式系統則像是一個專精的工匠，只專注做一件事，但做得又快又省力。

**為什麼這樣設計？**
- 嵌入式系統通常只需要執行「特定任務」（例如：讀取感測器、控制馬達）
- 不需要跑 Chrome 瀏覽器、播放 4K 影片
- 50 MHz 對於大部分控制任務來說已經綽綽有餘

---

#### RAM 差異

**桌上型電腦**：8-64 GB（8,000-64,000 MB）
**LM3S6965**：64 KB（0.064 MB）

**差異有多大？**

桌上型電腦的 RAM 是 LM3S6965 的 **125,000 倍到 1,000,000 倍**！

用生活化的比喻：
- 如果 LM3S6965 的 64 KB RAM 是一張 A4 紙的容量
- 那麼 8 GB RAM 就相當於 125,000 張 A4 紙疊起來（約 12.5 公尺高）！

**為什麼 64 KB 就夠了？**

讓我們算一算：
```c
// 一個整數變數
int counter;           // 4 bytes

// 一個小陣列
float data[100];       // 100 × 4 = 400 bytes

// 一個通訊緩衝區
char uart_buffer[256]; // 256 bytes

// 總計：約 660 bytes，只用了 64 KB 的 1%！
```

嵌入式程式通常：
- 不需要儲存大量資料（有需要就用外部記憶體）
- 不需要載入複雜的程式（程式在 Flash 裡）
- 變數以「即時處理」為主，不囤積資料

---

#### 電源消耗

**桌上型電腦**：100-500W（瓦特）
**LM3S6965**：<100 mW（毫瓦）= 0.1W

**差異**：桌上型電腦耗電是 LM3S6965 的 **1000-5000 倍**！

**實際意義**：
- LM3S6965 可以用兩顆 AA 電池（3V, 2000 mAh）跑好幾個月
- 桌上型電腦... 你試試看用電池跑看看 😅

**為什麼省電這麼重要？**

想像這些應用場景：
- **穿戴裝置**（智慧手錶）：需要充電一次用好幾天
- **工業感測器**：裝在偏遠地區，不方便換電池
- **醫療植入物**（心律調節器）：換電池需要開刀！
- **汽車電子**：引擎熄火時也要能運作（讀取遙控鑰匙）

---

#### 作業系統

**桌上型電腦**：Windows/Linux/macOS
- 複雜的多工系統
- 記憶體管理、檔案系統、驅動程式
- 需要數百 MB 到數 GB 的空間

**LM3S6965**：無（裸機）或 RTOS
- **裸機**：你的程式直接跑在硬體上，沒有作業系統
- **RTOS**（即時作業系統）：超輕量的作業系統，只有幾十 KB

**裸機的意思是**：
```c
int main(void) {
    // 你的程式就是「整個系統」
    // 沒有其他程式在背景執行
    // 沒有檔案系統、沒有多工、沒有 GUI

    init_hardware();

    while(1) {
        // 主要邏輯
        read_sensor();
        control_motor();
        update_display();
    }
}
```

**好處**：
- ✅ 完全可預測：沒有背景程式突然佔用 CPU
- ✅ 省資源：不需要為作業系統保留記憶體
- ✅ 即時性強：沒有作業系統排程的延遲

**壞處**：
- ❌ 你要自己管理一切（沒有幫手）
- ❌ 程式碼要自己寫得很嚴謹

---

### 1.2 應用場景差異

**桌上型電腦的應用**：
- 上網瀏覽、收發郵件
- 文書處理、影片剪輯
- 遊戲娛樂
- 軟體開發
- **特色**：什麼都能做，但什麼都不專精

**嵌入式系統的應用**：
- **汽車**：引擎控制、ABS 煞車、安全氣囊觸發
- **家電**：洗衣機、冷氣、微波爐
- **醫療**：血糖機、心電圖機、呼吸器
- **工業**：PLC（可程式邏輯控制器）、機器人手臂
- **通訊**：路由器、手機基頻晶片
- **特色**：只做一件事，但做到極致

**為什麼需要專用系統？**

用安全氣囊為例：
- 偵測到撞擊後必須在 **10 毫秒內**（0.01 秒）彈出氣囊
- 如果用 Windows：「正在檢查更新中...」😱
- 如果用嵌入式系統：**保證在時限內完成**，沒有例外

這就是「即時性」（Real-Time）的重要性！

---

## 2. LM3S6965 微控制器

### 2.1 什麼是微控制器？

在進入 LM3S6965 的細節之前，讓我們先理解「微控制器」（Microcontroller）這個概念。

**微控制器 vs 微處理器**：

**微處理器（Microprocessor）**：
- 只有 CPU 核心
- 需要外接 RAM、ROM、周邊裝置
- 例子：Intel Core i7、AMD Ryzen

**微控制器（Microcontroller）**：
- CPU + RAM + ROM + 周邊裝置，**全部整合在一顆晶片裡**
- 一顆晶片就是一個完整的電腦系統
- 例子：LM3S6965、Arduino、ESP32

**比喻**：
- 微處理器像是「腦袋」，需要搭配身體（其他零件）才能運作
- 微控制器像是「完整的人」，腦袋、手腳、感官都在同一個身體裡

---

### 2.2 LM3S6965 架構圖

現在讓我們看看 LM3S6965 內部有哪些東西：

```
┌──────────────────────────────────────────────────────┐
│            LM3S6965 方塊圖                             │
│                                                        │
│  ┌────────────────────────────────────────────────┐  │
│  │         ARM Cortex-M3 Core                     │  │
│  │         50 MHz, 32-bit                         │  │
│  └──────────────┬─────────────────────────────────┘  │
│                 │                                     │
│    ┌────────────┴────────────┐                       │
│    │                          │                       │
│    ▼                          ▼                       │
│  ┌─────────┐             ┌─────────┐                 │
│  │ SRAM    │             │ Flash   │                 │
│  │ 64 KB   │             │ 256 KB  │                 │
│  └─────────┘             └─────────┘                 │
│                                                        │
│  周邊裝置:                                             │
│  ┌────────────────────────────────────────────┐      │
│  │ • UART × 3      (序列通訊)                  │      │
│  │ • SSI × 2       (SPI)                      │      │
│  │ • I2C × 2       (I²C)                      │      │
│  │ • GPIO × 8 組   (通用 I/O)                  │      │
│  │ • Timer × 4     (計時器)                    │      │
│  │ • ADC           (類比轉數位)                 │      │
│  │ • PWM           (脈寬調變)                   │      │
│  │ • CAN           (車用網路)                   │      │
│  │ • Ethernet      (乙太網路)                   │      │
│  └────────────────────────────────────────────┘      │
└──────────────────────────────────────────────────────┘
```

**讓我們逐個解釋這些元件**：

---

#### ARM Cortex-M3 Core（CPU 核心）

這是「大腦」，負責：
- 執行指令（運算、邏輯判斷）
- 讀寫記憶體
- 控制周邊裝置

**32-bit** 的意思：
- 一次可以處理 32 位元（4 bytes）的資料
- 暫存器是 32 位元寬度
- 記憶體位址空間是 2³² = 4 GB（雖然 LM3S6965 只用了一小部分）

**50 MHz** 的意思：
- 每秒執行 5000 萬個時脈週期
- 大部分指令只需要 1 個時脈週期
- 所以大約每秒可以執行 5000 萬條指令

---

#### SRAM（64 KB）

我們在模組 03 學過，這是「工作記憶體」：
- 執行時變數存放的地方
- 速度快，但斷電消失
- 位址範圍：0x20000000 ~ 0x2000FFFF

---

#### Flash（256 KB）

也在模組 03 學過，這是「程式儲存空間」：
- 程式碼、常數存放的地方
- 斷電不消失
- 位址範圍：0x00000000 ~ 0x0003FFFF

---

#### 周邊裝置（Peripherals）

這是 LM3S6965 的「手腳和感官」，讓它能與外界互動：

**UART（通用非同步收發器）× 3**
- **用途**：序列通訊，像是和電腦、GPS 模組、藍牙模組溝通
- **速度**：通常 9600 ~ 115200 bps（bits per second）
- **本模組重點**：我們會用 UART0 輸出 "Hello World"

**SSI（同步序列介面）× 2**
- **用途**：SPI 通訊，連接 SD 卡、LCD 螢幕、感測器
- **速度**：可達數 MHz

**I2C × 2**
- **用途**：連接多個感測器（溫度、壓力、加速度計）
- **特色**：只需要 2 條線（SCL, SDA）

**GPIO（通用輸入輸出）× 8 組**
- **用途**：連接按鈕、LED、繼電器
- **每組有多個腳位**：例如 Port A 有 8 個腳位（PA0~PA7）

**Timer（計時器）× 4**
- **用途**：產生週期性中斷、測量脈衝寬度、PWM 輸出

**ADC（類比轉數位轉換器）**
- **用途**：讀取類比訊號（電壓、溫度）轉換成數位值
- **解析度**：10-bit（0~1023）

**PWM（脈寬調變）**
- **用途**：控制馬達速度、LED 亮度

**CAN（控制器區域網路）**
- **用途**：車用通訊，連接車上各個 ECU（電子控制單元）

**Ethernet（乙太網路）**
- **用途**：網路連線，可以做成小型網頁伺服器

---

### 2.3 為什麼需要這麼多周邊？

你可能會想：「這麼小的晶片，為什麼需要這麼多功能？」

**答案**：因為嵌入式系統需要與「真實世界」互動！

想像你要做一個**智慧溫控風扇**：
- **ADC**：讀取溫度感測器（類比電壓）
- **Timer**：週期性檢查溫度（例如每秒一次）
- **PWM**：控制風扇轉速（佔空比越高轉越快）
- **GPIO**：讀取使用者按鈕、控制 LED 指示燈
- **UART**：輸出除錯訊息到電腦

如果沒有這些周邊，你需要：
- 外接 ADC 晶片（增加成本、電路複雜度）
- 外接 PWM 產生器
- 外接其他晶片...

**整合的好處**：
- ✅ 降低成本
- ✅ 簡化電路設計
- ✅ 減少功耗
- ✅ 提高可靠性（更少的焊接點 = 更少的故障點）

---

## 3. UART 串列通訊

### 3.1 為什麼需要 UART？

在深入 UART 技術之前，讓我們先理解**為什麼需要序列通訊**。

**問題場景**：微控制器要如何和外界溝通？

**方法 1：並列通訊（Parallel）**
- 同時傳送 8 個位元 = 需要 8 條線
- 加上控制線 = 總共需要 10+ 條線
- **缺點**：線太多、成本高、不適合長距離

**方法 2：序列通訊（Serial）**
- 一次傳送 1 個位元 = 只需要 1 條線（加上地線 = 2 條）
- **缺點**：速度較慢
- **優點**：線少、成本低、適合長距離

**比喻**：
- 並列通訊像是 8 線道高速公路，車流量大但建造成本高
- 序列通訊像是單線道道路，車流量小但建造便宜

**UART 就是一種序列通訊協定**，專門設計給嵌入式系統使用。

---

### 3.2 UART 是什麼？

**UART** = Universal Asynchronous Receiver/Transmitter
- **Universal**（通用）：廣泛支援，幾乎所有微控制器都有
- **Asynchronous**（非同步）：不需要時鐘訊號，雙方只需約定速率
- **Receiver/Transmitter**：可以收也可以發

讓我們看看 UART 的連接方式：

```
┌────────────────────────────────────────────────┐
│           UART 通訊示意圖                        │
│                                                 │
│  裝置 A (LM3S6965)      裝置 B (電腦)            │
│  ┌──────────┐          ┌──────────┐            │
│  │   UART0  │          │ USB-UART │            │
│  │          │          │ 轉換器    │            │
│  │   TX ────┼─────────→┼─ RX      │            │
│  │   RX ←───┼──────────┼─ TX      │            │
│  │   GND ───┼─────────→┼─ GND     │            │
│  └──────────┘          └──────────┘            │
│                                                 │
│  TX = Transmit (發送)                          │
│  RX = Receive  (接收)                          │
│                                                 │
└────────────────────────────────────────────────┘
```

**重要觀念**：
1. **TX 接 RX，RX 接 TX**（交叉連接）
   - A 的發送（TX）接到 B 的接收（RX）
   - A 的接收（RX）接到 B 的發送（TX）
   - 想想看：你說話時，對方要用耳朵聽；對方說話時，你用耳朵聽

2. **GND 必須共接**（共地）
   - 電壓是「相對的」
   - 沒有共同的參考點，無法判斷高電位/低電位

3. **全雙工（Full Duplex）**
   - 可以同時發送和接收
   - 就像打電話，雙方可以同時說話（雖然通常不會這樣做 😅）

---

### 3.3 UART 訊號格式

UART 傳輸資料時，不是隨便把 0 和 1 送出去就好，而是要遵循特定的格式：

```
┌──────────────────────────────────────────────────────┐
│          UART 傳輸一個位元組 'A' (0x41)                │
│                                                        │
│  空閒    起始  D0  D1  D2  D3  D4  D5  D6  D7  停止   │
│  ────┐  ┌───┬───┬───┬───┬───┬───┬───┬───┐  ┌────    │
│      │  │   │   │   │   │   │   │   │   │  │        │
│      └──┘   └───┘   └───────────┘   └───┘  └        │
│   1   0   1   0   0   0   0   0   1   0   1          │
│              ↑                       ↑                │
│             LSB                     MSB               │
│                                                        │
│  'A' = 0x41 = 0b01000001                              │
│  傳輸順序: LSB first (D0 → D7)                        │
│                                                        │
│  • 起始位元: 0 (下降緣觸發接收)                        │
│  • 資料位元: 8 bits                                   │
│  • 停止位元: 1 (回到高電位)                           │
│  • 無同步時鐘 → 雙方須約定相同傳輸速率 (Baud Rate)     │
│                                                        │
└──────────────────────────────────────────────────────┘
```

**讓我們逐步理解這張圖**：

---

#### 空閒狀態（Idle）

當沒有資料傳輸時，UART 線路保持在**高電位**（邏輯 1）。

**為什麼？** 這樣接收端可以偵測「下降緣」來判斷資料開始了。

---

#### 起始位元（Start Bit）

當要開始傳輸時，發送端先送出一個 **0**（低電位）。

**作用**：
1. 告訴接收端「注意！資料要來了」
2. 讓接收端同步時序（開始計時）

**為什麼需要起始位元？**

因為 UART 是「非同步」的：
- 沒有獨立的時鐘線
- 接收端不知道資料什麼時候會來
- 起始位元就是「開始訊號」

---

#### 資料位元（Data Bits）

接下來傳送 8 個位元的資料，代表一個位元組。

**傳輸順序**：LSB first（Least Significant Bit，最低位元先傳）

**例子**：字元 'A' = 0x41 = 0b**0**100000**1**
```
原始位元：  0  1  0  0  0  0  0  1
位置：     D7 D6 D5 D4 D3 D2 D1 D0
傳輸順序：  ←─────────────────────
實際順序：  1  0  0  0  0  0  1  0  (D0 先傳)
```

**為什麼 LSB first？**
- 歷史原因：早期硬體實作較簡單
- 接收端可以邊收邊處理，不用等全部收完

---

#### 停止位元（Stop Bit）

資料傳完後，送出一個 **1**（高電位）。

**作用**：
1. 標記「這個位元組傳完了」
2. 讓線路回到空閒狀態（高電位）
3. 給接收端一些「喘息時間」來處理資料

**可以有多個停止位元嗎？** 可以！常見設定：
- 1 個停止位元（最常用）
- 1.5 個停止位元（少見）
- 2 個停止位元（較老的標準）

---

#### 無時鐘訊號（Asynchronous）

**重點**：UART 沒有獨立的時鐘線！

**問題**：那接收端怎麼知道什麼時候該讀取每一個位元？

**答案**：雙方事先約定好「傳輸速率」（Baud Rate）

**常見的 Baud Rate**：
- 9600 bps（bits per second）= 每秒傳 9600 個位元
- 115200 bps = 每秒傳 115200 個位元（較常用）

**如何計算每個位元的時間**？

以 9600 bps 為例：
```
每個位元時間 = 1 / 9600 ≈ 104 微秒

傳輸一個位元組需要：
- 1 起始位元
- 8 資料位元
- 1 停止位元
= 10 位元 × 104 微秒 = 1.04 毫秒
```

**雙方時鐘必須準確**：
- 如果誤差太大（例如一方是 9600，另一方是 9700），會收到亂碼
- 通常誤差要控制在 ±2% 以內

---

#### 常見的 UART 設定：8-N-1

你常會看到這個術語：**8-N-1**

**意思**：
- **8**：8 個資料位元
- **N**：無（None）同位檢查位元（Parity bit）
- **1**：1 個停止位元

**還有其他組合嗎？**
- 8-E-1：8 資料位元，偶同位檢查（Even parity），1 停止位元
- 7-O-1：7 資料位元，奇同位檢查（Odd parity），1 停止位元

**同位檢查是什麼？**
- 在資料位元後面加一個檢查位元
- 用來偵測傳輸錯誤
- 現代通訊通常不用（因為有更好的錯誤檢查機制）

---

### 3.4 UART 傳輸實例

讓我們看一個完整的例子：傳送字串 "Hi"

```
字元 'H' = 0x48 = 0b01001000
字元 'i' = 0x69 = 0b01101001

時序圖：
  'H'                            'i'
  ┌─┬───┬───┬───┬───┬───┬───┬───┬───┬─┐ ┌─┬───┬───┬───┬───┬───┬───┬───┬───┬─┐
  │S│D0 │D1 │D2 │D3 │D4 │D5 │D6 │D7 │P│ │S│D0 │D1 │D2 │D3 │D4 │D5 │D6 │D7 │P│
  └─┴───┴───┴───┴───┴───┴───┴───┴───┴─┘ └─┴───┴───┴───┴───┴───┴───┴───┴───┴─┘

傳輸時間（9600 bps）：
- 每個字元：10 位元 × 104 微秒 = 1.04 毫秒
- 兩個字元：2.08 毫秒
```

**重要**：字元之間可以有任意長的「空閒時間」
- 可以連續發送（背對背）
- 也可以發送一個字元後等很久再發下一個
- 這就是「非同步」的意義：沒有固定的時序要求

---

## 4. UART 範例程式碼解析

### 4.1 程式碼概觀

現在讓我們看看實際的程式碼。這是一個非常簡單但完整的 UART 範例：

**檔案位置**: [`examples/uart_hello_world/uart_hello_world.c`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/uart_hello_world.c)

```c
// uart_hello_world.c
#include "lm3s/lm3s_cmsis.h"

void print_uart0(const char *s) {
    while(*s != '\0') {              // 字串結尾檢查
        UART0->DR = (unsigned int)(*s);  // 寫入 UART 資料暫存器
        s++;                         // 指標移到下一個字元
    }
}

int main(void)
{
    print_uart0("Hellow World?\n");  // 輸出字串

    while(1) {                       // 無窮迴圈
        // 嵌入式系統通常不會結束
    }
}
```

**這個程式看起來很簡單，但其實有很多細節！** 讓我們逐行解析。

---

### 4.2 標頭檔

```c
#include "lm3s/lm3s_cmsis.h"
```

這個標頭檔定義了：
- LM3S6965 所有周邊裝置的結構
- 記憶體位址對應
- 暫存器位元定義

**為什麼需要這個檔案？**

沒有它，你要這樣寫：
```c
// 痛苦的方式
*(volatile unsigned int *)0x4000C000 = 'H';  // 誰記得住這個位址？
```

有了它，可以這樣寫：
```c
// 可讀的方式
UART0->DR = 'H';  // 清楚表達：寫入 UART0 的資料暫存器
```

---

### 4.3 print_uart0 函數

```c
void print_uart0(const char *s) {
    while(*s != '\0') {              // 字串結尾檢查
        UART0->DR = (unsigned int)(*s);  // 寫入 UART 資料暫存器
        s++;                         // 指標移到下一個字元
    }
}
```

**逐行解釋**：

#### 第 1 行：函數宣告

```c
void print_uart0(const char *s)
```

- `void`：沒有返回值
- `print_uart0`：函數名稱
- `const char *s`：指向字串的指標
  - `const`：表示不會修改字串內容（唯讀）
  - `char *`：字元指標
  - `s`：參數名稱

**C 語言的字串是什麼？**

在 C 語言中，字串是「以 `\0` 結尾的字元陣列」：
```c
"Hi" 在記憶體中：
┌───┬───┬───┐
│'H'│'i'│'\0'│  \0 = 字串結束標記（值為 0）
└───┴───┴───┘
```

---

#### 第 2 行：while 迴圈

```c
while(*s != '\0')
```

**`*s` 是什麼意思？**
- `s` 是指標，存放記憶體位址
- `*s` 是「取值」（dereference），讀取該位址的內容

**例子**：
```c
char str[] = "Hi";
char *s = str;     // s 指向 'H'

*s      → 'H'      // 第一個字元
*(s+1)  → 'i'      // 第二個字元
*(s+2)  → '\0'     // 字串結束符
```

**迴圈邏輯**：
```
如果 *s 不是 '\0'  → 繼續迴圈
如果 *s 是 '\0'   → 結束迴圈（字串結束了）
```

---

#### 第 3 行：寫入 UART 暫存器

```c
UART0->DR = (unsigned int)(*s);
```

**這是整個程式的核心！** 讓我們仔細分析：

**`UART0` 是什麼？**

這是一個指標，指向 UART0 的暫存器組。定義在 `lm3s_cmsis.h`：
```c
#define UART0_BASE  0x4000C000          // UART0 的基底位址
#define UART0       ((UART_Type *)UART0_BASE)  // 轉換成結構指標
```

**`->` 是什麼？**

這是「指標成員存取」運算子：
```c
UART0->DR  等同於  (*UART0).DR
```

**`DR` 是什麼？**

DR = Data Register（資料暫存器），定義在結構中：
```c
typedef struct {
    __IO uint32_t DR;      // 0x000: 資料暫存器
    __IO uint32_t RSR;     // 0x004: 接收狀態
    // ... 其他暫存器
} UART_Type;
```

**`__IO` 是什麼？**
```c
#define __IO volatile
```

`volatile` 告訴編譯器：「這個變數可能會被硬體改變，不要最佳化！」

---

**實際發生了什麼？**

```c
UART0->DR = (unsigned int)(*s);
```

展開後等同於：
```c
*(volatile uint32_t *)(0x4000C000 + 0x000) = (unsigned int)(*s);
```

**步驟**：
1. 取得字元值：`*s` = 'H' = 0x48
2. 轉換成 unsigned int：0x00000048（32-bit）
3. 寫入位址 0x4000C000（UART0 的 DR 暫存器）

**硬體自動做的事**：
1. UART0 硬體偵測到 DR 暫存器被寫入
2. 把資料放進「發送緩衝區」（TX FIFO）
3. 開始序列化（轉換成序列格式）：
   ```
   起始位元 → D0 D1 D2 D3 D4 D5 D6 D7 → 停止位元
   ```
4. 透過 TX 腳位一個位元一個位元送出去

**你不需要**：
- ✅ 手動產生起始/停止位元（硬體自動做）
- ✅ 手動控制傳輸時序（硬體自動做）
- ✅ 等待傳輸完成（UART 有 FIFO 緩衝）

---

#### 第 4 行：移動指標

```c
s++;
```

把指標移到下一個字元：
```
第一次：s 指向 'H'  → s++ 後指向 'e'
第二次：s 指向 'e'  → s++ 後指向 'l'
...
最後：  s 指向 '\0' → 迴圈結束
```

---

### 4.4 main 函數

```c
int main(void)
{
    print_uart0("Hellow World?\n");  // 輸出字串

    while(1) {                       // 無窮迴圈
        // 嵌入式系統通常不會結束
    }
}
```

**為什麼這麼簡單就能輸出字串？**

**答案**：因為 UART0 在 Reset_Handler 或 SystemInit 時已經被初始化了！

**完整的 UART 初始化需要做什麼？**
1. 啟用 UART0 時鐘
2. 設定 Baud Rate（波特率）
3. 設定資料格式（8-N-1）
4. 啟用發送和接收

**但在這個簡單範例中**：
- QEMU 模擬器預設 UART0 已經啟用
- 所以可以直接使用

**實際專案中**：你需要自己初始化，例如：
```c
void uart0_init(void) {
    // 1. 啟用 UART0 時鐘
    SYSCTL->RCGC1 |= (1 << 0);  // 啟用 UART0

    // 2. 設定 Baud Rate = 115200
    // ... (計算並設定 IBRD, FBRD)

    // 3. 設定 8-N-1 格式
    UART0->LCRH = (0x3 << 5);  // 8 bits

    // 4. 啟用 TX/RX
    UART0->CTL |= (1 << 0) | (1 << 8) | (1 << 9);
}
```

---

### 4.5 暫存器直接存取的概念

在嵌入式系統中，我們常常需要「直接操作硬體暫存器」。讓我們深入理解這個概念：

```c
UART0->DR = (unsigned int)(*s);
  ↑     ↑
  │     └─ DR = Data Register (資料暫存器)
  └─────── UART0 = 基底位址指標
```

**展開後實際上是**：

```c
*(volatile uint32_t *)(0x4000C000 + 0x000) = data;
   ↑                   ↑            ↑
   │                   │            └─ DR 偏移量
   │                   └────────────── UART0 基底位址
   └────────────────────────────────── volatile (禁止編譯器最佳化)
```

---

#### 記憶體映射 I/O（Memory-Mapped I/O）

**什麼是記憶體映射 I/O？**

在 ARM Cortex-M3 系統中，**硬體暫存器被映射到記憶體位址空間**。

**意思是**：
- 讀寫「某個特定位址」= 讀寫「硬體暫存器」
- CPU 不區分「記憶體」和「硬體」
- 都是用同樣的指令：`LDR`（讀取）、`STR`（儲存）

**例子**：
```c
// 讀取 UART0 狀態
uint32_t status = UART0->FR;
// 實際是：讀取位址 0x4000C018 的內容

// 寫入 UART0 資料
UART0->DR = 'A';
// 實際是：寫入位址 0x4000C000 的內容
```

---

#### LM3S6965 記憶體映射表

```
┌──────────────────────────────────────────────────┐
│        LM3S6965 周邊暫存器映射                     │
├──────────────────────────────────────────────────┤
│                                                    │
│  0x40000000 - 0x40007FFF   GPIO Port A~H         │
│  0x4000C000 - 0x4000CFFF   UART0                 │
│  0x4000D000 - 0x4000DFFF   UART1                 │
│  0x4000E000 - 0x4000EFFF   UART2                 │
│  ...                                              │
│                                                    │
│  UART0 暫存器 (起始於 0x4000C000):                │
│  ┌──────────────────────────────────────┐        │
│  │ 偏移   暫存器    說明                 │        │
│  ├──────────────────────────────────────┤        │
│  │ 0x000  DR       資料暫存器            │        │
│  │ 0x018  FR       狀態暫存器            │        │
│  │ 0x024  IBRD     整數波特率除數        │        │
│  │ 0x028  FBRD     小數波特率除數        │        │
│  │ 0x02C  LCRH     線路控制              │        │
│  │ 0x030  CTL      控制暫存器            │        │
│  └──────────────────────────────────────┘        │
│                                                    │
└──────────────────────────────────────────────────┘
```

**讓我們理解這張表**：

#### UART0 基底位址：0x4000C000

所有 UART0 的暫存器都從這個位址開始。

#### DR（Data Register）- 偏移 0x000

**完整位址**：0x4000C000 + 0x000 = 0x4000C000

**功能**：
- **寫入**：發送資料（TX）
- **讀取**：接收資料（RX）

**例子**：
```c
// 發送字元 'A'
UART0->DR = 'A';

// 接收字元
char c = UART0->DR;
```

---

#### FR（Flag Register）- 偏移 0x018

**完整位址**：0x4000C000 + 0x018 = 0x4000C018

**功能**：查詢 UART 狀態

**常用的位元**：
- Bit 5：TXFF（TX FIFO Full）= 1 表示發送緩衝區滿了
- Bit 4：RXFE（RX FIFO Empty）= 1 表示沒有資料可接收
- Bit 3：BUSY（Busy）= 1 表示 UART 正在傳輸

**例子**：
```c
// 等待發送緩衝區有空間
while (UART0->FR & (1 << 5)) {
    // TXFF = 1，緩衝區滿，等待
}
UART0->DR = 'A';  // 現在可以安全發送
```

---

#### IBRD/FBRD（Baud Rate 除數）- 偏移 0x024, 0x028

**功能**：設定傳輸速率

**計算公式**：
```
BRD = 系統時脈 / (16 × Baud Rate)
IBRD = BRD 的整數部分
FBRD = (BRD 的小數部分 × 64) + 0.5
```

**例子**：設定 115200 bps（假設系統時脈 16 MHz）
```c
// BRD = 16,000,000 / (16 × 115200) = 8.6805...
// IBRD = 8
// FBRD = (0.6805 × 64) + 0.5 = 44

UART0->IBRD = 8;
UART0->FBRD = 44;
```

---

#### LCRH（Line Control）- 偏移 0x02C

**功能**：設定資料格式

**常用設定**：
- Bit 5-6：資料位元數（0x3 = 8 bits）
- Bit 4：FIFO 啟用
- Bit 1：同位檢查啟用

**例子**：設定 8-N-1
```c
UART0->LCRH = (0x3 << 5);  // 8 data bits, no parity, 1 stop bit
```

---

#### CTL（Control）- 偏移 0x030

**功能**：啟用/停用 UART

**常用設定**：
- Bit 0：UARTEN（UART 啟用）
- Bit 8：TXE（發送啟用）
- Bit 9：RXE（接收啟用）

**例子**：啟用 UART0
```c
UART0->CTL = (1 << 0) | (1 << 8) | (1 << 9);
// 同時啟用 UART、TX、RX
```

---

### 4.6 UART0 結構定義

現在讓我們看看 `lm3s_cmsis.h` 中如何定義 UART0：

```c
typedef struct {
    __IO uint32_t DR;      // 0x000: 資料暫存器
    __IO uint32_t RSR;     // 0x004: 接收狀態
    // ... 其他暫存器
    __IO uint32_t FR;      // 0x018: 旗標暫存器
    // ...
    __IO uint32_t IBRD;    // 0x024: 整數波特率除數
    __IO uint32_t FBRD;    // 0x028: 小數波特率除數
    __IO uint32_t LCRH;    // 0x02C: 線路控制
    __IO uint32_t CTL;     // 0x030: 控制暫存器
    // ...
} UART_Type;

#define UART0_BASE  0x4000C000
#define UART0       ((UART_Type *)UART0_BASE)
```

**這個設計的巧妙之處**：

#### 1. 結構成員對應暫存器偏移

```c
struct UART_Type {
    uint32_t DR;    // 偏移 0x000
    uint32_t RSR;   // 偏移 0x004（前一個 + 4 bytes）
    // ...
    uint32_t FR;    // 偏移 0x018
};
```

C 語言保證結構成員按順序排列，所以：
- `DR` 在偏移 0x000
- `RSR` 在偏移 0x004
- `FR` 在偏移 0x018
- ...

---

#### 2. 型別轉換讓存取更直觀

```c
#define UART0 ((UART_Type *)UART0_BASE)
```

**意思**：
- `UART0_BASE` = 0x4000C000（純數字）
- `(UART_Type *)` = 轉換成「指向 UART_Type 結構的指標」
- 現在可以用 `UART0->DR` 存取

**等同於**：
```c
UART0->DR
= ((UART_Type *)0x4000C000)->DR
= *(uint32_t *)(0x4000C000 + 0)
= 讀寫位址 0x4000C000
```

---

#### 3. volatile 確保正確性

```c
#define __IO volatile
```

**為什麼需要 volatile？**

**沒有 volatile 的問題**：
```c
// 假設沒有 volatile
uint32_t status = UART0->FR;  // 讀取狀態
while (status & TXFF) {       // 檢查 TX FIFO 是否滿
    // 等待
}

// 編譯器可能最佳化成：
uint32_t status = UART0->FR;
if (status & TXFF) {
    while (1) { }  // 無窮迴圈！
}
```

**編譯器的想法**：「`status` 沒有被修改，所以不用重複讀取」

**但實際上**：硬體隨時在改變 UART0->FR 的值！

**加上 volatile**：
```c
volatile uint32_t status = UART0->FR;
while (status & TXFF) {
    status = UART0->FR;  // 編譯器不會最佳化掉這行
}
```

編譯器被告知：「這個變數可能被外部因素改變（硬體），每次都要重新讀取」

---

## 5. 實際執行範例

### 5.1 編譯並執行

現在讓我們實際執行這個程式，看看它如何運作：

```bash
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world
make

# 使用 Docker 執行
docker run --rm \
    -v /home/sbplab/jiawei/qemu/CMSIS_LM3S:/work:ro \
    cmsis-lm3s-qemu:latest \
    bash -c "cd /work/examples/uart_hello_world/gcc && \
             timeout 3 qemu-system-arm -M lm3s6965evb -nographic \
                     -kernel uart_hello_world.bin"

# 輸出:
# Hellow World?
```

**命令解析**：

**`make`**：
- 編譯 C 程式碼
- 產生 `uart_hello_world.axf`（含除錯符號）
- 產生 `uart_hello_world.bin`（純二進位檔）

**`qemu-system-arm`**：
- QEMU ARM 系統模擬器

**`-M lm3s6965evb`**：
- 模擬 LM3S6965 評估板

**`-nographic`**：
- 不啟動圖形視窗，使用文字終端

**`-kernel uart_hello_world.bin`**：
- 載入程式到模擬器

**`timeout 3`**：
- 3 秒後自動停止（因為程式會無窮迴圈）

---

### 5.2 執行流程詳解

現在讓我們看看從按下 Enter 到看到輸出，中間發生了什麼：

```
┌──────────────────────────────────────────────────┐
│           UART 範例執行流程                        │
│                                                    │
│  1. QEMU 啟動                                     │
│     qemu-system-arm -M lm3s6965evb               │
│     ↓                                             │
│  2. 載入 uart_hello_world.bin 到 0x00000000      │
│     ↓                                             │
│  3. CPU 開始執行                                  │
│     • 讀取 0x00 → 設定 SP                         │
│     • 讀取 0x04 → 跳到 Reset_Handler             │
│     ↓                                             │
│  4. Reset_Handler                                 │
│     • 複製 .data                                  │
│     • 清零 .bss                                   │
│     • 呼叫 main()                                 │
│     ↓                                             │
│  5. main() 執行                                   │
│     print_uart0("Hellow World?\n");              │
│     ↓                                             │
│  6. print_uart0() 逐字元輸出                      │
│     while (*s != '\0') {                         │
│         UART0->DR = *s;  ← 寫入暫存器             │
│         s++;                                      │
│     }                                             │
│     ↓                                             │
│  7. UART0 硬體                                    │
│     • 讀取 DR 暫存器                              │
│     • 序列化資料 (8-N-1 格式)                     │
│     • 透過 TX 腳位發送                            │
│     ↓                                             │
│  8. QEMU 模擬                                     │
│     • 接收 UART 輸出                              │
│     • 顯示到終端機                                │
│     ↓                                             │
│  9. 你看到輸出                                    │
│     Hellow World?                                │
│     ↓                                             │
│  10. main() 進入 while(1)                        │
│      程式持續執行（不會結束）                      │
│                                                    │
└──────────────────────────────────────────────────┘
```

**讓我們詳細走過每一步**：

---

#### 步驟 1-3：啟動與初始化

這部分我們在模組 03 已經學過了：
1. QEMU 模擬 LM3S6965 硬體
2. 載入 .bin 檔案到 Flash（0x00000000）
3. CPU 從中斷向量表讀取 SP 和 PC

---

#### 步驟 4：Reset_Handler

也在模組 03 學過：
- 複製 .data 初始值
- 清零 .bss
- 呼叫 SystemInit()（初始化系統時脈）
- 呼叫 main()

---

#### 步驟 5-6：字串輸出

```c
print_uart0("Hellow World?\n");
```

**實際發生**：

**第 1 次迴圈**：
```c
*s = 'H'
UART0->DR = 'H';  // 寫入 0x48 到位址 0x4000C000
s++;
```

**第 2 次迴圈**：
```c
*s = 'e'
UART0->DR = 'e';  // 寫入 0x65
s++;
```

...依此類推，直到遇到 `'\n'` 和 `'\0'`

---

#### 步驟 7：UART0 硬體處理

每次寫入 `UART0->DR`，硬體自動做這些事：

1. **檢查 TX FIFO**（發送緩衝區）
   - 如果滿了，等待
   - 如果有空間，放入資料

2. **序列化**
   - 加入起始位元（0）
   - 將資料轉換成序列格式（LSB first）
   - 加入停止位元（1）

3. **發送**
   - 透過 TX 腳位，以約定的 Baud Rate 送出每個位元

**時序**（假設 9600 bps）：
```
每個字元：
- 1 起始位元
- 8 資料位元
- 1 停止位元
= 10 位元 × (1/9600) 秒 ≈ 1 毫秒

"Hellow World?\n" = 14 個字元
總時間 ≈ 14 毫秒
```

---

#### 步驟 8：QEMU 模擬

QEMU 做了什麼？

1. **模擬 UART0 硬體**
   - 監視 UART0->DR 暫存器的寫入
   - 模擬序列傳輸過程

2. **連接到終端機**
   - QEMU 把 UART0 輸出重導向到 stdout
   - 所以你可以在終端機看到輸出

**實體硬體上**：
- UART0 的 TX 腳位會輸出實際的電壓變化
- 需要連接 USB-UART 轉換器才能在電腦上看到

**QEMU 模擬器上**：
- 直接顯示到終端機，方便除錯

---

#### 步驟 9-10：輸出與無窮迴圈

輸出 "Hellow World?\n" 後，程式進入 `while(1)`，永遠不會結束。

**為什麼？**
- 嵌入式系統通常是「永遠執行」的
- 例如：溫度控制器要一直監控溫度，不能停

**實際專案的主迴圈**：
```c
int main(void) {
    init_hardware();

    while(1) {
        // 讀取感測器
        float temp = read_temperature();

        // 控制風扇
        if (temp > 30.0) {
            set_fan_speed(100);  // 全速
        } else {
            set_fan_speed(50);   // 半速
        }

        // 延遲 1 秒
        delay_ms(1000);
    }
}
```

---

## 📝 實作練習

### 練習 1：修改輸出字串

**任務**：修改程式，輸出你的名字和學號。

**步驟**：
1. 編輯 `uart_hello_world.c`
2. 修改這一行：
   ```c
   print_uart0("Hellow World?\n");
   ```
   改成：
   ```c
   print_uart0("My name is [你的名字], ID: [學號]\n");
   ```
3. 重新編譯：`make clean && make`
4. 執行並確認輸出

---

### 練習 2：輸出多行

**任務**：修改程式，輸出 3 行文字。

**提示**：
```c
print_uart0("Line 1\n");
print_uart0("Line 2\n");
print_uart0("Line 3\n");
```

**思考**：
- 為什麼需要 `\n`？
- 如果沒有 `\n` 會怎樣？

---

### 練習 3：使用 GDB 觀察執行過程

這個練習讓你「慢動作」觀察程式如何執行。

**終端 1：啟動 QEMU GDB Server**
```bash
docker run --rm -d \
    -v /home/sbplab/jiawei/qemu/CMSIS_LM3S:/work:ro \
    -p 1234:1234 \
    --name qemu_uart \
    cmsis-lm3s-qemu:latest \
    bash -c "cd /work/examples/uart_hello_world/gcc && \
             exec qemu-system-arm -M lm3s6965evb -nographic \
                  -kernel uart_hello_world.bin -s -S"
```

**終端 2：GDB**
```bash
docker run --rm -it \
    -v /home/sbplab/jiawei/qemu/CMSIS_LM3S:/work:ro \
    --network host \
    cmsis-lm3s-gdb:latest \
    bash -c "cd /work/examples/uart_hello_world/gcc && \
             gdb-multiarch uart_hello_world.axf"
```

**在 GDB 中執行**：

```gdb
# 連接到 QEMU
(gdb) target remote localhost:1234

# 在 main 設中斷點
(gdb) break main
(gdb) continue
Breakpoint 1, main () at uart_hello_world.c:10

# 在 print_uart0 設中斷點
(gdb) break print_uart0
(gdb) continue
Breakpoint 2, print_uart0 (s=0x...) at uart_hello_world.c:3

# 查看字串參數
(gdb) x/s $r0
0x...: "Hellow World?\n"

# 單步執行
(gdb) next   # 執行 while 條件判斷
(gdb) next   # 執行 UART0->DR = ...

# 查看 UART0->DR 的值
(gdb) x/x 0x4000C000
0x4000C000:  0x00000048    # 'H' = 0x48

# 繼續單步，觀察每個字元被送出
(gdb) next
(gdb) next
...
```

**觀察重點**：
1. `$r0` 暫存器存放函數的第一個參數（字串指標）
2. 每次執行 `UART0->DR = *s`，位址 0x4000C000 的值會改變
3. 指標 `s` 逐步遞增

---

### 練習 4：加入延遲

**任務**：在每個字元之間加入延遲，讓輸出變慢（方便觀察）。

**簡單的延遲函數**：
```c
void delay(void) {
    for (volatile int i = 0; i < 100000; i++) {
        // 空迴圈，單純消耗時間
    }
}

void print_uart0(const char *s) {
    while(*s != '\0') {
        UART0->DR = (unsigned int)(*s);
        s++;
        delay();  // 加入延遲
    }
}
```

**思考**：
- 為什麼要用 `volatile`？
- 如果不用 `volatile`，編譯器可能會怎麼最佳化？

---

## 🎯 學習檢查點

完成本模組後，請確認你能：

**概念理解**：
- [ ] 用自己的話說明嵌入式系統與桌上型電腦的 3 個主要差異
- [ ] 解釋為什麼嵌入式系統需要低功耗
- [ ] 說明「裸機」的意思

**LM3S6965 認識**：
- [ ] 說出 LM3S6965 的 CPU 頻率、RAM 大小、Flash 大小
- [ ] 列舉至少 5 種周邊裝置
- [ ] 解釋為什麼需要整合這麼多周邊

**UART 通訊**：
- [ ] 畫出 UART 連接圖（TX, RX, GND）
- [ ] 說明起始位元和停止位元的作用
- [ ] 解釋什麼是 8-N-1
- [ ] 理解 Baud Rate 的意義

**暫存器存取**：
- [ ] 解釋 `UART0->DR` 的實際意義
- [ ] 說明記憶體映射 I/O 的概念
- [ ] 理解為什麼需要 `volatile`

**程式碼理解**：
- [ ] 能讀懂 `print_uart0` 函數的邏輯
- [ ] 知道如何修改輸出字串
- [ ] 能用 GDB 觀察程式執行

---

## 🔗 下一步

🎉 **恭喜完成模組 04！**

你現在已經：
- 理解了嵌入式系統的特性
- 認識了 LM3S6965 微控制器
- 學會了 UART 通訊原理
- **實際操作了硬體暫存器**（這是嵌入式編程的核心！）

**這是一個重要的里程碑**！你已經從「理論」進入「實作」了。

接下來在 [模組 05：ARM 架構詳解](05-ARM架構詳解.md) 中，我們將深入探討：
- ARM Cortex-M3 的內部架構
- 暫存器組織
- 中斷和異常處理
- NVIC（巢狀向量中斷控制器）

這會幫助你更深入理解「CPU 如何運作」，為後面的進階主題打好基礎。

準備好了嗎？讓我們繼續深入 ARM 的世界！

---

**版本**：2.0
**更新日期**：2025-11-16
**更新內容**：增加大量白話文字解釋、生活化比喻、逐步引導說明
