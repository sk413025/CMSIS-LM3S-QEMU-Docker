# 模組 05：ARM 架構詳解

> 深入理解 ARM Cortex-M3 處理器架構

**對應專案檔案**: [`CMSIS/Include/core_cm3.h`](../CMSIS/Include/core_cm3.h)

## 📌 學習目標

- ✅ 認識 ARM 架構家族
- ✅ 理解 Cortex-M3 核心特性
- ✅ 學會使用暫存器（R0-R15, SP, LR, PC）
- ✅ 了解 NVIC 中斷控制器
- ✅ 理解 Thumb-2 指令集

---

## 開始之前：為什麼要理解處理器架構？

想像一下，你每天開車上下班，只要知道**怎麼發動、轉彎、煞車**就夠了。但如果你想成為**賽車手**或**汽車工程師**，你就必須深入了解**引擎如何運作、變速箱原理、懸吊系統設計**。

**嵌入式系統開發就像賽車**：
- 🚗 **一般開車** = 使用高階語言 API（Arduino、mbed）
- 🏎️ **賽車手** = 理解暫存器、中斷、記憶體佈局
- 🔧 **汽車工程師** = 設計處理器、最佳化指令集

**理解 ARM 架構的實際好處**：

1. **除錯更有效率**：當程式當機時，你能看懂 GDB 顯示的暫存器狀態
2. **效能最佳化**：知道哪些操作快、哪些操作慢
3. **正確處理中斷**：理解 NVIC 如何保存/恢復暫存器
4. **閱讀組合語言**：看得懂編譯器產生的機器碼
5. **硬體整合**：知道如何透過暫存器控制硬體

**本模組將回答的問題**：
- ❓ 為什麼 ARM 處理器分成 Cortex-A、Cortex-R、Cortex-M 三個家族？
- ❓ Cortex-M3 的「三階管線」是什麼？為什麼能加速執行？
- ❓ 為什麼有 16 個暫存器（R0-R15）？每個有什麼特殊用途？
- ❓ 中斷發生時，NVIC 如何自動保存現場？
- ❓ Thumb-2 指令集如何同時做到「省空間」和「高效能」？

讓我們開始探索 ARM 處理器的內部世界！

---

## 1. ARM 架構家族

### 1.1 ARM 公司的商業模式

在深入技術之前，先了解 **ARM 公司的特殊之處**：

**ARM 不製造晶片，只設計架構授權**（IP 授權模式）：

```
┌────────────────────────────────────────────────┐
│         ARM 公司的商業模式                      │
├────────────────────────────────────────────────┤
│                                                  │
│  傳統晶片公司 (例如 Intel):                     │
│  ┌──────────────────────────────────────┐      │
│  │ 設計 → 製造 → 銷售 (全部自己做)      │      │
│  └──────────────────────────────────────┘      │
│                                                  │
│  ARM 公司:                                      │
│  ┌──────────────────────────────────────┐      │
│  │ 只設計架構 → 授權給其他公司          │      │
│  └──────────────────────────────────────┘      │
│           ↓                                     │
│  ┌─────────────┬─────────────┬─────────┐      │
│  │ Apple       │ Qualcomm    │ Texas   │      │
│  │ (A 系列)    │ (驍龍)      │ Instruments │  │
│  │             │             │ (TI)     │      │
│  └─────────────┴─────────────┴─────────┘      │
│         各自製造自己的 ARM 晶片                 │
│                                                  │
└────────────────────────────────────────────────┘
```

**這就像**：ARM 設計「汽車引擎藍圖」，然後授權給 Toyota、Ford、BMW 各自製造自己的汽車。

**實際影響**：
- 全球 **95% 的智慧型手機**使用 ARM 處理器
- 你的 iPhone (Apple A17) = ARM Cortex-A 架構
- 你的 Android 手機 (高通驍龍) = ARM Cortex-A 架構
- 智慧手錶、藍牙耳機、IoT 裝置 = ARM Cortex-M 架構

---

### 1.2 ARM 三大家族：為什麼需要分類？

ARM 設計了**三個不同的處理器家族**，針對**不同的應用場景**最佳化。

**生活類比**：就像交通工具分成**貨車、跑車、機車**，雖然都是「車」，但設計目標完全不同：

```
┌──────────────────────────────────────────────────┐
│           ARM 處理器家族樹                         │
├──────────────────────────────────────────────────┤
│                                                    │
│  ┌─────────────────────────────────────────┐     │
│  │ Cortex-A (Application) 應用處理器        │     │
│  │ ━━━━━━━━━━━━━━━━━━━━━                  │     │
│  │ 類比: 大型貨車 🚛                        │     │
│  │   • 載重量大 (高效能)                    │     │
│  │   • 複雜的貨物管理系統 (記憶體管理單元)   │     │
│  │   • 可同時載多種貨物 (多工作業系統)       │     │
│  └─────────────────────────────────────────┘     │
│  特性:                                            │
│  • 高效能 (GHz 等級時脈)                          │
│  • 執行作業系統 (Linux, Android, iOS)             │
│  • 範例: Cortex-A72 (Raspberry Pi 4)             │
│  • 用途: 智慧型手機、平板、筆記型電腦              │
│  • 功耗: 數瓦 (需要風扇或散熱片)                  │
│                                                    │
│  ┌─────────────────────────────────────────┐     │
│  │ Cortex-R (Real-time) 即時處理器          │     │
│  │ ━━━━━━━━━━━━━━━━━━━━━━                 │     │
│  │ 類比: 救護車 🚑                          │     │
│  │   • 必須在固定時間內到達 (即時性)         │     │
│  │   • 高可靠性 (不能拋錨)                  │     │
│  │   • 確定性路線規劃 (可預測延遲)           │     │
│  └─────────────────────────────────────────┘     │
│  特性:                                            │
│  • 確定性即時反應 (微秒等級)                      │
│  • 高可靠性 (錯誤偵測與修正)                      │
│  • 用途: 汽車煞車系統、醫療設備、工業控制          │
│  • 容錯設計 (ECC 記憶體、雙核心鎖步)              │
│                                                    │
│  ┌─────────────────────────────────────────┐     │
│  │ Cortex-M (Microcontroller) 微控制器      │     │
│  │ ━━━━━━━━━━━━━━━━━━━━━━━━━━            │     │
│  │ 類比: 機車 🏍️                            │     │
│  │   • 省油 (低功耗)                        │     │
│  │   • 便宜 (成本低)                        │     │
│  │   • 操作簡單 (易於使用)                  │     │
│  │   • 靈活穿梭 (快速中斷反應)               │     │
│  └─────────────────────────────────────────┘     │
│  特性: ← 本專案使用的系列                         │
│  • 低功耗 (微瓦到毫瓦等級，可用電池供電數年)       │
│  • 成本低 (美金 $0.5 ~ $5)                       │
│  • 易於使用 (統一的 CMSIS 介面)                   │
│  • 系列: M0, M0+, M3, M4, M7, M33, M55           │
│  • 本專案使用: Cortex-M3 (50 MHz, 32-bit)        │
│  • 用途: IoT、穿戴裝置、感測器、家電控制           │
│                                                    │
└──────────────────────────────────────────────────┘
```

### 1.3 為什麼本專案選擇 Cortex-M3？

**Cortex-M 系列內部也有細分**：

| 型號 | 時脈 | 特色 | 應用場景 | 價格 |
|------|------|------|----------|------|
| **M0/M0+** | ~50 MHz | 超低功耗、超低成本 | 簡單感測器、藍牙裝置 | $0.5 |
| **M3** ← 本專案 | ~100 MHz | 平衡性能與功耗 | 工業控制、馬達控制 | $2 |
| **M4/M4F** | ~200 MHz | 加入 DSP + FPU | 音訊處理、馬達控制 | $3 |
| **M7** | ~500 MHz | 高效能 M 系列 | 影像處理、汽車儀表板 | $5 |

**本專案選擇 M3 的原因**：
1. ✅ **教學友善**：功能完整但不過於複雜
2. ✅ **廣泛使用**：工業界標準，學習後容易找工作
3. ✅ **QEMU 支援**：LM3S6965 是 QEMU 內建支援的開發板
4. ✅ **CMSIS-DSP 相容**：支援本專案的 FIR/IIR 濾波器範例

---

## 2. Cortex-M3 核心架構

### 2.1 什麼是「處理器核心」？

在深入架構前，先釐清**幾個容易混淆的名詞**：

```
┌────────────────────────────────────────────────┐
│         晶片的層次結構                          │
├────────────────────────────────────────────────┤
│                                                  │
│  1. ARM 架構 (Architecture)                    │
│     └─ 設計規範與指令集定義                     │
│        例如: ARMv7-M 架構                       │
│                                                  │
│  2. 處理器核心 (Processor Core)                │
│     └─ 具體實作 ARM 架構的 CPU 設計             │
│        例如: Cortex-M3 核心                     │
│                                                  │
│  3. 微控制器 (Microcontroller)                 │
│     └─ 核心 + 週邊 + 記憶體的完整晶片           │
│        例如: LM3S6965 (本專案使用)              │
│                                                  │
│  4. 開發板 (Development Board)                 │
│     └─ 微控制器 + 電源 + 除錯介面 + 連接埠      │
│        例如: LM3S6965EVB (QEMU 模擬的板子)      │
│                                                  │
└────────────────────────────────────────────────┘
```

**生活類比**：
- **ARM 架構** = 汽車安全規範（例如：必須有安全帶、氣囊）
- **Cortex-M3 核心** = 引擎設計藍圖（2.0L 渦輪增壓引擎）
- **LM3S6965 晶片** = 完整汽車（引擎 + 變速箱 + 座椅 + 音響）
- **LM3S6965EVB 開發板** = 展示中心的試駕車（配好油、接好電瓶，可直接試駕）

---

### 2.2 Cortex-M3 內部結構詳解

現在讓我們打開 Cortex-M3 的「引擎蓋」，看看裡面有什麼：

```
┌────────────────────────────────────────────────────┐
│          Cortex-M3 內部結構                         │
│                                                      │
│  ┌────────────────────────────────────────────┐    │
│  │  取指單元 (Fetch Unit)                      │    │
│  │  ━━━━━━━━━━━━━━━━━━━━                     │    │
│  │  工作: 從記憶體讀取指令                      │    │
│  │                                              │    │
│  │  [記憶體] → 讀取下一條指令 → [指令暫存器]    │    │
│  │                                              │    │
│  │  類比: 圖書館員從書架拿書給你                │    │
│  └────────────────────────────────────────────┘    │
│                    ↓                                │
│  ┌────────────────────────────────────────────┐    │
│  │  解碼單元 (Decode Unit)                     │    │
│  │  ━━━━━━━━━━━━━━━━━━━━━                    │    │
│  │  工作: 解析指令的意義                        │    │
│  │                                              │    │
│  │  例如: 0x2064 → "MOVS R0, #100"             │    │
│  │        (把數字 100 放入 R0 暫存器)           │    │
│  │                                              │    │
│  │  類比: 翻譯機將英文翻譯成中文                │    │
│  └────────────────────────────────────────────┘    │
│                    ↓                                │
│  ┌────────────────────────────────────────────┐    │
│  │  執行單元 (Execute Unit)                    │    │
│  │  ━━━━━━━━━━━━━━━━━━━━━                    │    │
│  │  工作: 實際執行指令                          │    │
│  │                                              │    │
│  │  ┌──────────────┐  ┌──────────────┐       │    │
│  │  │  ALU         │  │ Multiplier   │       │    │
│  │  │  (運算單元)   │  │ (乘法器)     │       │    │
│  │  │              │  │              │       │    │
│  │  │ 加減邏輯運算  │  │ 32×32=64     │       │    │
│  │  │ AND/OR/XOR   │  │ 單週期完成    │       │    │
│  │  └──────────────┘  └──────────────┘       │    │
│  │                                              │    │
│  │  類比: 計算機執行數學運算                    │    │
│  └────────────────────────────────────────────┘    │
│                    ↓                                │
│  ┌────────────────────────────────────────────┐    │
│  │  暫存器檔案 (Register File)                 │    │
│  │  ━━━━━━━━━━━━━━━━━━━━━━                   │    │
│  │  R0-R12 (通用暫存器) ← 工作用的記事本        │    │
│  │  R13 (SP)  堆疊指標  ← 記錄目前堆疊位置      │    │
│  │  R14 (LR)  返回位址  ← 記錄函數返回地址      │    │
│  │  R15 (PC)  程式計數器 ← 記錄下一條指令位址   │    │
│  │                                              │    │
│  │  類比: CPU 的草稿紙 (比記憶體快 100 倍)      │    │
│  └────────────────────────────────────────────┘    │
│                                                      │
│  ┌────────────────────────────────────────────┐    │
│  │  NVIC (中斷控制器)                          │    │
│  │  ━━━━━━━━━━━━━━━━━━━                      │    │
│  │  • 最多 240 個外部中斷                      │    │
│  │  • 8 級優先權 (0 最高, 7 最低)              │    │
│  │  • 自動保存/恢復暫存器                      │    │
│  │                                              │    │
│  │  類比: 秘書幫你管理來電順序                  │    │
│  └────────────────────────────────────────────┘    │
│                                                      │
└────────────────────────────────────────────────────┘
```

### 2.3 三階管線：為什麼能加速執行？

**問題**：如果 CPU 一次只做一件事，速度會很慢。

**解決方案**：使用「管線」(Pipeline) 技術，讓不同指令的不同階段**同時進行**。

**生活類比：洗衣服的流程**

**沒有管線（一次洗一批衣服）**：
```
┌────────────────────────────────────────────────┐
│  時間軸 →                                      │
├────────────────────────────────────────────────┤
│                                                  │
│  第1批衣服:                                     │
│  [洗衣 30分] → [脫水 10分] → [烘乾 40分]        │
│                                                  │
│  第2批衣服: (必須等第1批完成)                   │
│              [洗衣 30分] → [脫水 10分] → ...    │
│                                                  │
│  總時間: 80分 × 3批 = 240分鐘                   │
│                                                  │
└────────────────────────────────────────────────┘
```

**有管線（流水線作業）**：
```
┌────────────────────────────────────────────────┐
│  時間軸 (每格 10 分鐘) →                        │
├────────────────────────────────────────────────┤
│                                                  │
│  時間 0:  [第1批 洗衣]                          │
│  時間 30: [第1批 脫水] [第2批 洗衣]             │
│  時間 40: [第1批 烘乾] [第2批 脫水] [第3批 洗衣] │
│  時間 70:              [第2批 烘乾] [第3批 脫水] │
│  時間 80:                          [第3批 烘乾] │
│                                                  │
│  總時間: 120分鐘 (省了 50%！)                   │
│                                                  │
└────────────────────────────────────────────────┘
```

**Cortex-M3 的三階管線**：

```
┌────────────────────────────────────────────────┐
│       三階管線運作示意圖                        │
├────────────────────────────────────────────────┤
│                                                  │
│  時脈週期 →  1    2    3    4    5             │
│            ─────────────────────────           │
│  指令 1:   [F] [D] [E]                          │
│  指令 2:       [F] [D] [E]                      │
│  指令 3:           [F] [D] [E]                  │
│  指令 4:               [F] [D] [E]              │
│  指令 5:                   [F] [D] [E]          │
│                                                  │
│  F = Fetch (取指)                               │
│  D = Decode (解碼)                              │
│  E = Execute (執行)                             │
│                                                  │
│  效果: 5條指令只需 7個週期 (理想)               │
│        如果沒有管線需要 15個週期 (5×3)          │
│        加速比 = 15/7 ≈ 2.14 倍                  │
│                                                  │
└────────────────────────────────────────────────┘
```

**實際執行範例**：

假設有這段程式碼：
```c
int a = 10;
int b = 20;
int c = a + b;
```

對應的組合語言與管線執行：
```
┌────────────────────────────────────────────────┐
│  組合語言              管線狀態                 │
├────────────────────────────────────────────────┤
│                                                  │
│  MOVS R0, #10         [F] [D] [E]              │
│  MOVS R1, #20             [F] [D] [E]          │
│  ADDS R2, R0, R1              [F] [D] [E]      │
│                                                  │
│  週期 1: 指令1在取指                            │
│  週期 2: 指令1解碼, 指令2取指                   │
│  週期 3: 指令1執行, 指令2解碼, 指令3取指        │
│  週期 4: 指令2執行, 指令3解碼                   │
│  週期 5: 指令3執行                              │
│                                                  │
│  總共只需 5 個時脈週期                          │
│  (如果沒有管線需要 9 個週期)                    │
│                                                  │
└────────────────────────────────────────────────┘
```

**為什麼不做更多階段的管線？**

| 管線階段 | 優點 | 缺點 |
|---------|------|------|
| 3 階 (M3) | 簡單、低功耗、中斷反應快 | 效能普通 |
| 5 階 (Cortex-A5) | 效能較好 | 複雜度增加 |
| 13 階 (Intel Pentium 4) | 高時脈 | 分支預測失敗損失大、高功耗 |

**Cortex-M3 選擇 3 階的原因**：
1. ✅ **低功耗**：管線階段少 = 電路簡單 = 省電
2. ✅ **快速中斷**：管線短，清空管線的代價小
3. ✅ **成本低**：電路面積小，晶片便宜

---

## 3. 暫存器組：CPU 的草稿紙

### 3.1 為什麼需要暫存器？

**問題**：CPU 執行運算時，資料要放哪裡？

**答案**：放在**暫存器** (Registers) —— CPU 內部的超高速記憶體。

**速度比較（假設 CPU 是 50 MHz）**：

```
┌────────────────────────────────────────────────┐
│         記憶體階層的速度差異                    │
├────────────────────────────────────────────────┤
│                                                  │
│  暫存器 (Registers)        1 週期    20 ns     │
│  ═════════════════════════════════════════     │
│  最快！CPU 內部的「計算紙」                     │
│                                                  │
│  快取記憶體 (Cache)        2-10 週期  40-200 ns│
│  ───────────────────────────────────────       │
│  還不錯，但 M3 沒有                             │
│                                                  │
│  SRAM (本專案的 RAM)       數十週期   ~1000 ns  │
│  ───────────────────────────────────────       │
│  慢了 50 倍                                     │
│                                                  │
│  Flash (本專案的程式碼)    更慢       ~5000 ns  │
│  ───────────────────────────────────────       │
│  慢了 250 倍                                    │
│                                                  │
└────────────────────────────────────────────────┘
```

**生活類比**：
- **暫存器** = 你手上的計算紙（伸手就拿到，1秒）
- **SRAM** = 書桌抽屜的計算機（要彎腰開抽屜，10秒）
- **Flash** = 樓下便利商店的計算機（要下樓走過去，5分鐘）

**結論**：盡量把常用的資料放在暫存器，程式會快很多！

---

### 3.2 Cortex-M3 的暫存器配置

Cortex-M3 提供 **16 個 32-bit 暫存器**：

```
┌──────────────────────────────────────────────────┐
│         Cortex-M3 暫存器 (每個 32-bit)            │
├──────────────────────────────────────────────────┤
│                                                    │
│  通用暫存器 (General Purpose Registers)           │
│  ┌────────────────────────────────────────┐      │
│  │ R0  │ 第1個參數 / 返回值               │      │
│  │     │ 函數呼叫時: func(R0, R1, R2, R3) │      │
│  │     │ 函數返回時: return R0;          │      │
│  ├─────┼──────────────────────────────────┤      │
│  │ R1  │ 第2個參數                        │      │
│  ├─────┼──────────────────────────────────┤      │
│  │ R2  │ 第3個參數                        │      │
│  ├─────┼──────────────────────────────────┤      │
│  │ R3  │ 第4個參數                        │      │
│  ├─────┼──────────────────────────────────┤      │
│  │ R4  │ 區域變數 (Callee-saved)          │      │
│  │ R5  │ 函數內部如果要用這些暫存器，      │      │
│  │ R6  │ 必須先保存到堆疊，返回前恢復      │      │
│  │ R7  │                                  │      │
│  │ R8  │                                  │      │
│  │ R9  │                                  │      │
│  │ R10 │                                  │      │
│  │ R11 │                                  │      │
│  ├─────┼──────────────────────────────────┤      │
│  │ R12 │ 臨時變數 (Caller-saved)          │      │
│  │     │ 呼叫函數前會被破壞，不需保存      │      │
│  └─────┴──────────────────────────────────┘      │
│                                                    │
│  特殊暫存器 (Special Purpose Registers)           │
│  ┌────────────────────────────────────────┐      │
│  │ R13 (SP)  │ Stack Pointer 堆疊指標     │      │
│  │           │ 指向目前堆疊的頂端          │      │
│  │           │ 推入: SP = SP - 4          │      │
│  │           │ 彈出: SP = SP + 4          │      │
│  ├───────────┼────────────────────────────┤      │
│  │ R14 (LR)  │ Link Register 返回位址     │      │
│  │           │ 儲存函數返回後要跳回的地址   │      │
│  │           │ 呼叫函數: BL func (LR=PC+4)│      │
│  │           │ 返回: BX LR                │      │
│  ├───────────┼────────────────────────────┤      │
│  │ R15 (PC)  │ Program Counter 程式計數器  │      │
│  │           │ 指向下一條要執行的指令位址   │      │
│  │           │ 自動遞增: PC = PC + 2/4    │      │
│  └───────────┴────────────────────────────┘      │
│                                                    │
│  狀態暫存器 (Program Status Registers)            │
│  ┌────────────────────────────────────────┐      │
│  │ xPSR │ 程式狀態暫存器 (32-bit)         │      │
│  │      │                                 │      │
│  │  31  30  29  28  27 ... 0              │      │
│  │  ┌─┬─┬─┬─┬─────────┐                 │      │
│  │  │N│Z│C│V│ 其他旗標 │                 │      │
│  │  └─┴─┴─┴─┴─────────┘                 │      │
│  │   │  │  │  │                           │      │
│  │   │  │  │  └─ V: 溢位旗標 (Overflow)   │      │
│  │   │  │  └──── C: 進位旗標 (Carry)      │      │
│  │   │  └─────── Z: 零旗標 (Zero)         │      │
│  │   └────────── N: 負數旗標 (Negative)   │      │
│  │                                         │      │
│  │  用途: 條件分支判斷                     │      │
│  │  例如: BEQ label (如果 Z=1 就跳轉)      │      │
│  └─────────────────────────────────────────┘      │
│                                                    │
└──────────────────────────────────────────────────┘
```

---

### 3.3 實際範例：函數呼叫的暫存器使用

讓我們看一個實際的 C 語言函數，了解暫存器如何運作：

**C 語言程式碼**：
```c
int add(int a, int b, int c, int d) {
    int result = a + b + c + d;
    return result;
}

int main(void) {
    int x = add(10, 20, 30, 40);
    print_uart0_hex(x);
    return 0;
}
```

**編譯成組合語言後**：

```asm
; ========================================
; int add(int a, int b, int c, int d)
; ========================================
add:
    ; 參數已經在 R0, R1, R2, R3 中
    ; R0 = a = 10
    ; R1 = b = 20
    ; R2 = c = 30
    ; R3 = d = 40

    ADDS R0, R0, R1    ; R0 = R0 + R1 = 10 + 20 = 30
    ADDS R0, R0, R2    ; R0 = R0 + R2 = 30 + 30 = 60
    ADDS R0, R0, R3    ; R0 = R0 + R3 = 60 + 40 = 100

    ; 返回值已經在 R0 (慣例)
    BX   LR            ; 返回 (跳到 LR 儲存的位址)

; ========================================
; int main(void)
; ========================================
main:
    PUSH {R4, LR}      ; 保存 R4 和返回位址

    ; 準備呼叫 add(10, 20, 30, 40)
    MOVS R0, #10       ; 第1個參數
    MOVS R1, #20       ; 第2個參數
    MOVS R2, #30       ; 第3個參數
    MOVS R3, #40       ; 第4個參數

    BL   add           ; 呼叫函數 (LR = 返回位址)
    ; 返回後 R0 = 100

    MOV  R4, R0        ; 保存結果到 R4 (x = 100)
    MOV  R0, R4        ; 準備傳給 print_uart0_hex
    BL   print_uart0_hex

    MOVS R0, #0        ; return 0
    POP  {R4, PC}      ; 恢復 R4, 並返回 (PC = LR)
```

**逐步解析執行流程**：

```
┌────────────────────────────────────────────────┐
│  步驟 1: main() 準備呼叫 add()                 │
├────────────────────────────────────────────────┤
│                                                  │
│  R0 = 10    ← 第1個參數                         │
│  R1 = 20    ← 第2個參數                         │
│  R2 = 30    ← 第3個參數                         │
│  R3 = 40    ← 第4個參數                         │
│  PC = 0x200 ← 指向 BL add 指令                  │
│  LR = ???   ← 尚未設定                          │
│                                                  │
└────────────────────────────────────────────────┘

┌────────────────────────────────────────────────┐
│  步驟 2: 執行 BL add (Branch with Link)        │
├────────────────────────────────────────────────┤
│                                                  │
│  LR = 0x204 ← 儲存返回位址 (PC + 4)            │
│  PC = add   ← 跳到 add 函數                     │
│                                                  │
│  (這樣 add() 執行完後知道要跳回 0x204)          │
│                                                  │
└────────────────────────────────────────────────┘

┌────────────────────────────────────────────────┐
│  步驟 3: add() 函數內部執行                    │
├────────────────────────────────────────────────┤
│                                                  │
│  ADDS R0, R0, R1  →  R0 = 10 + 20 = 30         │
│  ADDS R0, R0, R2  →  R0 = 30 + 30 = 60         │
│  ADDS R0, R0, R3  →  R0 = 60 + 40 = 100        │
│                                                  │
│  現在 R0 = 100 (返回值)                         │
│                                                  │
└────────────────────────────────────────────────┘

┌────────────────────────────────────────────────┐
│  步驟 4: BX LR (返回)                          │
├────────────────────────────────────────────────┤
│                                                  │
│  PC = LR = 0x204 ← 跳回 main()                 │
│  R0 = 100        ← 返回值保留在 R0              │
│                                                  │
└────────────────────────────────────────────────┘
```

**重點整理**：

| 暫存器 | 函數呼叫中的角色 | 誰負責保存？ |
|--------|------------------|--------------|
| **R0-R3** | 傳遞參數、返回值 | **Caller-saved** (呼叫方) |
| **R4-R11** | 區域變數 | **Callee-saved** (被呼叫方) |
| **R12** | 臨時變數 | **Caller-saved** |
| **LR (R14)** | 返回位址 | 硬體自動處理 |
| **SP (R13)** | 堆疊指標 | 硬體維護 |
| **PC (R15)** | 程式計數器 | 硬體自動遞增 |

**什麼是 Caller-saved 與 Callee-saved？**

```
┌────────────────────────────────────────────────┐
│         Caller-saved vs Callee-saved           │
├────────────────────────────────────────────────┤
│                                                  │
│  Caller-saved (R0-R3, R12)                     │
│  ━━━━━━━━━━━━━━━━━━━━                         │
│  規則: 呼叫方負責保存                           │
│                                                  │
│  main() {                                       │
│      int x = 100;  // 存在 R0                   │
│      foo();        // ⚠️ 呼叫後 R0 可能被改     │
│      // 如果還需要 x, 必須在呼叫前保存到堆疊     │
│  }                                              │
│                                                  │
│  Callee-saved (R4-R11)                         │
│  ━━━━━━━━━━━━━━━━━━━━━                        │
│  規則: 被呼叫方負責保存                         │
│                                                  │
│  void foo() {                                   │
│      PUSH {R4-R7}  // 使用前先保存              │
│      // ... 使用 R4-R7 ...                      │
│      POP {R4-R7}   // 返回前恢復                │
│  }                                              │
│                                                  │
└────────────────────────────────────────────────┘
```

---

### 3.4 堆疊指標 (SP) 的運作方式

**Stack Pointer (SP / R13)** 是最重要的特殊暫存器之一，讓我們深入理解它。

**生活類比**：想像堆疊是一疊盤子：
- **PUSH（推入）** = 在最上面放一個盤子
- **POP（彈出）** = 從最上面拿走一個盤子
- **SP** = 指向最上面那個盤子的標籤

```
┌────────────────────────────────────────────────┐
│         堆疊的 PUSH 與 POP 操作                 │
├────────────────────────────────────────────────┤
│                                                  │
│  ARM 堆疊特性: Full-Descending Stack           │
│  • Full: SP 指向最後寫入的資料                  │
│  • Descending: 往低位址成長                     │
│                                                  │
│  初始狀態: SP = 0x20010000                      │
│  ┌────────────────────┐                        │
│  │ 0x20010000         │ ← SP 指向這裡           │
│  ├────────────────────┤                        │
│  │ 0x2000FFFC         │                         │
│  ├────────────────────┤                        │
│  │ 0x2000FFF8         │                         │
│  └────────────────────┘                        │
│                                                  │
│  執行 PUSH {R0}  (假設 R0 = 0x12345678)        │
│  ┌────────────────────┐                        │
│  │ 0x20010000         │                         │
│  ├────────────────────┤                        │
│  │ 0x2000FFFC         │ ← SP 移到這裡           │
│  │ [0x12345678]       │ ← R0 的值寫入這裡       │
│  ├────────────────────┤                        │
│  │ 0x2000FFF8         │                         │
│  └────────────────────┘                        │
│  SP = SP - 4 = 0x2000FFFC                       │
│                                                  │
│  執行 PUSH {R1}  (假設 R1 = 0xAABBCCDD)        │
│  ┌────────────────────┐                        │
│  │ 0x20010000         │                         │
│  ├────────────────────┤                        │
│  │ 0x2000FFFC         │                         │
│  │ [0x12345678]       │ ← R0 (先前推入)         │
│  ├────────────────────┤                        │
│  │ 0x2000FFF8         │ ← SP 移到這裡           │
│  │ [0xAABBCCDD]       │ ← R1 的值寫入這裡       │
│  └────────────────────┘                        │
│  SP = SP - 4 = 0x2000FFF8                       │
│                                                  │
│  執行 POP {R1}                                  │
│  ┌────────────────────┐                        │
│  │ 0x20010000         │                         │
│  ├────────────────────┤                        │
│  │ 0x2000FFFC         │ ← SP 恢復到這裡         │
│  │ [0x12345678]       │ ← R0 還在               │
│  ├────────────────────┤                        │
│  │ 0x2000FFF8         │                         │
│  │ [0xAABBCCDD]       │ ← 資料還在但不再有效     │
│  └────────────────────┘                        │
│  R1 = 0xAABBCCDD (從堆疊讀出)                   │
│  SP = SP + 4 = 0x2000FFFC                       │
│                                                  │
└────────────────────────────────────────────────┘
```

**實際組合語言範例**：

```asm
; 函數進入時保存暫存器
func:
    PUSH {R4-R7, LR}   ; 保存 R4, R5, R6, R7, LR 到堆疊
                        ; SP = SP - 20 (5個暫存器 × 4 bytes)

    ; ... 函數主體 ...
    ; 可以隨意使用 R4-R7

    POP {R4-R7, PC}    ; 恢復 R4-R7, 並返回 (PC = LR)
                        ; SP = SP + 20
```

**對應的堆疊變化**：

```
┌────────────────────────────────────────────────┐
│  PUSH {R4-R7, LR} 的堆疊佈局                   │
├────────────────────────────────────────────────┤
│                                                  │
│  高位址                                         │
│  ┌────────────────────┐                        │
│  │ ... (舊資料)       │                         │
│  ├────────────────────┤ ← SP (執行前)           │
│  │ LR  (0x000003A4)   │ ← 返回位址              │
│  ├────────────────────┤                        │
│  │ R7  (0x00000000)   │                         │
│  ├────────────────────┤                        │
│  │ R6  (0x00000000)   │                         │
│  ├────────────────────┤                        │
│  │ R5  (0x00000000)   │                         │
│  ├────────────────────┤                        │
│  │ R4  (0x00000000)   │                         │
│  ├────────────────────┤ ← SP (執行後)           │
│  │ ... (未使用)       │                         │
│  └────────────────────┘                        │
│  低位址                                         │
│                                                  │
│  SP = SP - 20 (0x14) bytes                      │
│                                                  │
└────────────────────────────────────────────────┘
```

---

## 4. NVIC 中斷控制器

### 4.1 什麼是中斷？為什麼需要中斷？

**問題**：CPU 如何同時處理多件事？例如：
- 正在執行主程式
- UART 突然收到資料
- Timer 時間到了
- 按鈕被按下

**錯誤的解決方案：輪詢 (Polling)**

```c
// ❌ 糟糕的設計
while (1) {
    if (uart_has_data()) {
        process_uart();
    }
    if (timer_expired()) {
        process_timer();
    }
    if (button_pressed()) {
        process_button();
    }
    // 主要工作
    do_main_task();  // 很少時間執行主要工作！
}
```

**缺點**：
- 🐌 CPU 一直在檢查，浪費時間
- ⚡ 反應慢（可能錯過 UART 資料）
- 🔋 耗電（CPU 無法休眠）

**正確的解決方案：中斷 (Interrupt)**

```c
// ✅ 良好的設計
int main(void) {
    enable_uart_interrupt();
    enable_timer_interrupt();
    enable_button_interrupt();

    while (1) {
        do_main_task();  // 專心執行主要工作
        // 當硬體事件發生時，會自動跳到中斷處理器
    }
}

// 中斷處理器 (由硬體自動呼叫)
void UART_IRQHandler(void) {
    char c = UART0->DR;  // 讀取資料
    buffer[index++] = c;
    // 處理完自動返回主程式
}
```

**優點**：
- ⚡ 快速反應（微秒等級）
- 💤 CPU 可以休眠等待（省電）
- 🎯 主程式不受干擾

---

### 4.2 生活類比：中斷像門鈴

**場景**：你在家看書

```
┌────────────────────────────────────────────────┐
│         沒有中斷 (輪詢模式)                     │
├────────────────────────────────────────────────┤
│                                                  │
│  你每隔 1 分鐘就要:                             │
│  1. 放下書本                                    │
│  2. 走到門口看看有沒有客人                      │
│  3. 看看信箱有沒有信                            │
│  4. 看看窗外有沒有快遞                          │
│  5. 確認沒事後走回沙發                          │
│  6. 找到剛才看到第幾頁                          │
│  7. 繼續看書                                    │
│                                                  │
│  結果: 很累、很煩、書看得很慢                   │
│                                                  │
└────────────────────────────────────────────────┘

┌────────────────────────────────────────────────┐
│         有中斷 (門鈴模式)                       │
├────────────────────────────────────────────────┤
│                                                  │
│  你專心看書，門鈴響了:                          │
│  1. 聽到「叮咚」(中斷發生)                      │
│  2. 自動記住看到第幾頁 (NVIC 保存 PC)           │
│  3. 走去開門 (跳到中斷處理器)                   │
│  4. 處理完客人                                  │
│  5. 回到沙發，翻到剛才的頁面 (恢復 PC)          │
│  6. 繼續看書                                    │
│                                                  │
│  結果: 輕鬆、有效率、不會錯過客人                │
│                                                  │
└────────────────────────────────────────────────┘
```

**對應到 Cortex-M3**：

| 生活場景 | Cortex-M3 | 說明 |
|---------|-----------|------|
| 看書 | 執行 main() | 主程式 |
| 門鈴響 | UART 收到資料 | 硬體事件 |
| 記住頁碼 | NVIC 保存 PC, R0-R3 | 保存現場 |
| 去開門 | 跳到 UART_IRQHandler() | 執行中斷處理器 |
| 處理客人 | 讀取 UART 資料 | 處理硬體事件 |
| 回到沙發 | BX LR | 返回指令 |
| 翻到原本頁碼 | NVIC 恢復 PC, R0-R3 | 恢復現場 |
| 繼續看書 | 繼續執行 main() | 回到主程式 |

---

### 4.3 NVIC 的完整運作流程

**NVIC** = **Nested Vectored Interrupt Controller** (巢狀向量中斷控制器)

讓我們拆解這個名稱：
- **Nested（巢狀）**：高優先權中斷可以打斷低優先權中斷
- **Vectored（向量）**：每個中斷有固定的處理器位址（向量表）
- **Interrupt（中斷）**：硬體事件
- **Controller（控制器）**：管理所有中斷的硬體電路

```
┌────────────────────────────────────────────────┐
│        NVIC 中斷處理完整流程                    │
│       (以 UART 中斷為例)                        │
├────────────────────────────────────────────────┤
│                                                  │
│  【步驟 1】主程式正在執行                       │
│  ┌──────────────────────────────────────┐      │
│  │ main() {                             │      │
│  │     while(1) {                       │      │
│  │         count++;  ← 執行到這裡        │      │
│  │     }                                │      │
│  │ }                                    │      │
│  └──────────────────────────────────────┘      │
│  R0 = 123, R1 = 456, PC = 0x000002A8            │
│                                                  │
│  ════════════════════════════════════════       │
│  【步驟 2】硬體事件發生                         │
│  ════════════════════════════════════════       │
│  UART 收到字元 'A' (0x41)                       │
│  → UART 硬體設定中斷旗標                        │
│  → 送訊號給 NVIC: "UART 中斷請求"               │
│                                                  │
│  ════════════════════════════════════════       │
│  【步驟 3】NVIC 檢查是否接受中斷                │
│  ════════════════════════════════════════       │
│  NVIC 檢查:                                     │
│  ✓ UART 中斷有啟用嗎？ (NVIC_EnableIRQ)        │
│  ✓ 優先權夠高嗎？                               │
│  ✓ CPU 目前允許中斷嗎？ (PRIMASK = 0)          │
│                                                  │
│  全部 OK → 接受中斷！                           │
│                                                  │
│  ════════════════════════════════════════       │
│  【步驟 4】NVIC 自動保存現場 (硬體自動！)       │
│  ════════════════════════════════════════       │
│  推入堆疊 (PUSH):                               │
│  ┌────────────────────┐                        │
│  │ xPSR (狀態暫存器)   │ ← 先推                  │
│  ├────────────────────┤                        │
│  │ PC   (0x000002A8)  │ ← 返回位址              │
│  ├────────────────────┤                        │
│  │ LR   (0x000001A4)  │                         │
│  ├────────────────────┤                        │
│  │ R12  (0x00000000)  │                         │
│  ├────────────────────┤                        │
│  │ R3   (0x00000000)  │                         │
│  ├────────────────────┤                        │
│  │ R2   (0x00000000)  │                         │
│  ├────────────────────┤                        │
│  │ R1   (456)         │                         │
│  ├────────────────────┤                        │
│  │ R0   (123)         │ ← 後推                  │
│  └────────────────────┘ ← SP 指向這裡           │
│                                                  │
│  注意: R4-R11 不會自動保存                      │
│        (如果中斷處理器要用，必須手動 PUSH)       │
│                                                  │
│  ════════════════════════════════════════       │
│  【步驟 5】從向量表查詢處理器位址                │
│  ════════════════════════════════════════       │
│  向量表 (Vector Table) 位於 0x00000000:        │
│  ┌─────────┬────────────────────────┐          │
│  │ 位址     │ 內容                   │          │
│  ├─────────┼────────────────────────┤          │
│  │ 0x0000  │ 初始 SP 值             │          │
│  │ 0x0004  │ Reset_Handler 位址     │          │
│  │ 0x0008  │ NMI_Handler 位址       │          │
│  │ ...     │ ...                    │          │
│  │ 0x0030  │ UART0_IRQHandler 位址  │ ← 讀這裡 │
│  │         │ = 0x000004B0           │          │
│  └─────────┴────────────────────────┘          │
│                                                  │
│  ════════════════════════════════════════       │
│  【步驟 6】跳到中斷處理器                       │
│  ════════════════════════════════════════       │
│  PC = 0x000004B0 (UART0_IRQHandler)             │
│  LR = 0xFFFFFFF9 (特殊返回值，表示從中斷返回)   │
│                                                  │
│  執行:                                          │
│  ┌──────────────────────────────────────┐      │
│  │ void UART0_IRQHandler(void) {        │      │
│  │     char c = UART0->DR;  // 讀取資料 │      │
│  │     // c = 'A' (0x41)                │      │
│  │     process_char(c);                 │      │
│  │     // 清除中斷旗標 (自動)            │      │
│  │ }                                    │      │
│  └──────────────────────────────────────┘      │
│                                                  │
│  ════════════════════════════════════════       │
│  【步驟 7】中斷處理器返回                       │
│  ════════════════════════════════════════       │
│  執行 BX LR (或函數結尾自動返回)                │
│  LR = 0xFFFFFFF9 → NVIC 識別為中斷返回          │
│                                                  │
│  ════════════════════════════════════════       │
│  【步驟 8】NVIC 自動恢復現場 (硬體自動！)       │
│  ════════════════════════════════════════       │
│  從堆疊彈出 (POP):                              │
│  R0   = 123                                     │
│  R1   = 456                                     │
│  R2   = 0                                       │
│  R3   = 0                                       │
│  R12  = 0                                       │
│  LR   = 0x000001A4 (恢復原本的 LR)              │
│  PC   = 0x000002A8 (恢復原本的 PC)              │
│  xPSR = (恢復狀態旗標)                          │
│                                                  │
│  ════════════════════════════════════════       │
│  【步驟 9】繼續執行主程式                       │
│  ════════════════════════════════════════       │
│  ┌──────────────────────────────────────┐      │
│  │ main() {                             │      │
│  │     while(1) {                       │      │
│  │         count++;  ← 從這裡繼續！      │      │
│  │     }                                │      │
│  │ }                                    │      │
│  └──────────────────────────────────────┘      │
│                                                  │
│  整個過程只花費 12 個時脈週期！                  │
│  (50 MHz → 0.24 微秒)                           │
│                                                  │
└────────────────────────────────────────────────┘
```

---

### 4.4 中斷優先權與巢狀中斷

**問題**：如果正在處理 UART 中斷時，Timer 中斷也來了怎麼辦？

**答案**：看優先權！

```
┌────────────────────────────────────────────────┐
│         NVIC 優先權系統                         │
├────────────────────────────────────────────────┤
│                                                  │
│  Cortex-M3 支援 8 級優先權 (0-7)                │
│  • 0 = 最高優先權                               │
│  • 7 = 最低優先權                               │
│                                                  │
│  ┌──────────────────────────────────────┐      │
│  │ 優先權 0  ← HardFault (系統錯誤)     │      │
│  │ 優先權 1  ← Timer (重要！)           │      │
│  │ 優先權 2  ← UART (普通)              │      │
│  │ 優先權 3  ← Button (不急)            │      │
│  └──────────────────────────────────────┘      │
│                                                  │
└────────────────────────────────────────────────┘
```

**巢狀中斷範例**：

```
┌────────────────────────────────────────────────┐
│  時間軸 →                                      │
├────────────────────────────────────────────────┤
│                                                  │
│  main() ────────────────┐       ┌───────────   │
│                         │       │               │
│  UART_IRQ (優先權2) ────┼───┐   │               │
│                         │   │   │               │
│  Timer_IRQ (優先權1) ───┼───┼─┐ │               │
│                         ↓   ↓ ↓ ↓               │
│  1. 執行 main()                                 │
│  2. UART 中斷 → 跳到 UART_IRQHandler()          │
│  3. 執行中... 突然 Timer 中斷來了！             │
│  4. 因為 Timer 優先權(1) > UART(2)              │
│     → 暫停 UART, 跳到 Timer_IRQHandler()        │
│  5. Timer 處理完 → 返回 UART_IRQHandler()       │
│  6. UART 處理完 → 返回 main()                   │
│                                                  │
│  結果: Timer 插隊處理！                         │
│                                                  │
└────────────────────────────────────────────────┘
```

**如果優先權相同**：
- **先到先處理** (First-Come-First-Served)
- 正在處理的中斷不會被打斷
- 新的中斷等待（Pending 狀態）

**設定優先權的程式碼**：

```c
#include "lm3s_cmsis.h"

void setup_interrupts(void) {
    // 設定優先權
    NVIC_SetPriority(UART0_IRQn, 2);  // UART 優先權 = 2
    NVIC_SetPriority(TIMER0A_IRQn, 1); // Timer 優先權 = 1 (更高)

    // 啟用中斷
    NVIC_EnableIRQ(UART0_IRQn);
    NVIC_EnableIRQ(TIMER0A_IRQn);
}
```

---

## 5. Thumb-2 指令集

### 5.1 為什麼需要不同的指令集？

在理解 Thumb-2 之前，先看 ARM 處理器的演化歷史：

```
┌────────────────────────────────────────────────┐
│         ARM 指令集演化史                        │
├────────────────────────────────────────────────┤
│                                                  │
│  ┌─────────────────────────────────────┐       │
│  │ ARM 指令集 (32-bit)                 │       │
│  │ ━━━━━━━━━━━━━━━━━                  │       │
│  │ 優點: 功能強大、效能好               │       │
│  │ 缺點: 佔空間 (每條指令 4 bytes)      │       │
│  │                                     │       │
│  │ 範例:                               │       │
│  │ E2800001  ADD R0, R0, #1  (4 bytes) │       │
│  └─────────────────────────────────────┘       │
│              ↓ 1995 年                          │
│  ┌─────────────────────────────────────┐       │
│  │ Thumb 指令集 (16-bit)               │       │
│  │ ━━━━━━━━━━━━━━━━━━                 │       │
│  │ 優點: 省空間 (每條指令 2 bytes)      │       │
│  │ 缺點: 功能受限、效能較差              │       │
│  │                                     │       │
│  │ 範例:                               │       │
│  │ 3001      ADD R0, #1      (2 bytes) │       │
│  └─────────────────────────────────────┘       │
│              ↓ 2003 年                          │
│  ┌─────────────────────────────────────┐       │
│  │ Thumb-2 指令集 (16 + 32-bit 混合)   │       │
│  │ ━━━━━━━━━━━━━━━━━━━━━━━━          │       │
│  │ 優點: 兼顧空間與效能 ← 本專案使用   │       │
│  │ • 簡單指令用 16-bit (省空間)         │       │
│  │ • 複雜指令用 32-bit (保持效能)       │       │
│  │                                     │       │
│  │ Cortex-M 系列只支援 Thumb-2         │       │
│  └─────────────────────────────────────┘       │
│                                                  │
└────────────────────────────────────────────────┘
```

**為什麼省空間這麼重要？**

嵌入式系統的 Flash 記憶體很小（本專案只有 256 KB）：
- **ARM 指令集**：10,000 條指令 = 40 KB
- **Thumb-2 指令集**：10,000 條指令 = 28 KB（省 30%！）

**節省的 12 KB 可以**：
- 多放 3000 行程式碼
- 或降低晶片成本（更小的 Flash）

---

### 5.2 Thumb-2 的運作原理

Thumb-2 如何同時做到「省空間」和「高效能」？

**答案**：**動態混合** 16-bit 和 32-bit 指令！

```
┌────────────────────────────────────────────────┐
│      Thumb-2 指令編碼示意圖                     │
├────────────────────────────────────────────────┤
│                                                  │
│  ┌──────────────────────────────────────┐      │
│  │ 16-bit 指令 (常用操作)               │      │
│  │ ━━━━━━━━━━━━━━━━━                   │      │
│  │ ┌───────────────────┐                │      │
│  │ │ 15-11 │ 10-8 │ 7-0│                │      │
│  │ ├───────┼──────┼────┤                │      │
│  │ │ Opcode│  Rn  │ Rd │                │      │
│  │ └───────┴──────┴────┘                │      │
│  │                                      │      │
│  │ 範例: MOVS R0, #100                  │      │
│  │ 編碼: 0x2064                         │      │
│  │ ┌────┬────┐                          │      │
│  │ │0010│0064│ = 2 bytes                │      │
│  │ └────┴────┘                          │      │
│  └──────────────────────────────────────┘      │
│                                                  │
│  ┌──────────────────────────────────────┐      │
│  │ 32-bit 指令 (複雜操作)               │      │
│  │ ━━━━━━━━━━━━━━━━━━                  │      │
│  │ ┌─────────────────────────────┐      │      │
│  │ │ 31-27 │ 26-16 │ 15-0        │      │      │
│  │ ├───────┼───────┼─────────────┤      │      │
│  │ │111... │ Op1   │ Op2         │      │      │
│  │ └───────┴───────┴─────────────┘      │      │
│  │                                      │      │
│  │ 範例: LDR R0, [R1, #100]             │      │
│  │ 編碼: 0xF8D10064                     │      │
│  │ ┌────┬────┬────┬────┐                │      │
│  │ │F8D1│0064│    │    │ = 4 bytes      │      │
│  │ └────┴────┴────┴────┘                │      │
│  └──────────────────────────────────────┘      │
│                                                  │
│  CPU 如何區分？                                 │
│  → 看前幾個 bit:                                │
│    • 如果是 111... 開頭 → 32-bit 指令           │
│    • 否則 → 16-bit 指令                         │
│                                                  │
└────────────────────────────────────────────────┘
```

---

### 5.3 實際程式碼的空間節省範例

讓我們比較同一段 C 程式碼編譯成不同指令集的大小：

**C 語言程式碼**：
```c
int sum(int a, int b) {
    return a + b;
}

int main(void) {
    int x = sum(10, 20);
    return 0;
}
```

**編譯成 Thumb-2**：

```asm
; sum() 函數
sum:
    ADDS R0, R0, R1    ; 16-bit 指令, 2 bytes
    BX   LR            ; 16-bit 指令, 2 bytes
; 總計: 4 bytes

; main() 函數
main:
    PUSH {LR}          ; 16-bit 指令, 2 bytes
    MOVS R0, #10       ; 16-bit 指令, 2 bytes
    MOVS R1, #20       ; 16-bit 指令, 2 bytes
    BL   sum           ; 32-bit 指令, 4 bytes (因為跳轉距離遠)
    MOVS R0, #0        ; 16-bit 指令, 2 bytes
    POP  {PC}          ; 16-bit 指令, 2 bytes
; 總計: 14 bytes

; 總大小: 4 + 14 = 18 bytes
```

**如果使用純 ARM 指令集**：

```asm
; sum() 函數
sum:
    ADD R0, R0, R1     ; 32-bit 指令, 4 bytes
    BX  LR             ; 32-bit 指令, 4 bytes
; 總計: 8 bytes

; main() 函數
main:
    PUSH {LR}          ; 32-bit 指令, 4 bytes
    MOV  R0, #10       ; 32-bit 指令, 4 bytes
    MOV  R1, #20       ; 32-bit 指令, 4 bytes
    BL   sum           ; 32-bit 指令, 4 bytes
    MOV  R0, #0        ; 32-bit 指令, 4 bytes
    POP  {PC}          ; 32-bit 指令, 4 bytes
; 總計: 24 bytes

; 總大小: 8 + 24 = 32 bytes
```

**節省空間計算**：
- ARM 指令集: 32 bytes
- Thumb-2 指令集: 18 bytes
- **節省: (32-18)/32 = 43.75%！**

**實際專案統計（本專案的 uart_hello_world.c）**：

使用 `arm-none-eabi-size` 查看：
```bash
$ arm-none-eabi-size uart_hello_world.elf
   text    data     bss     dec     hex filename
   1234      56     128    1418     58a uart_hello_world.elf
```

- **text (程式碼)**: 1234 bytes
- 如果用純 ARM 指令集，預估會是: ~1800 bytes
- **Thumb-2 節省了約 566 bytes！**

在 256 KB Flash 中，這可以讓你多放很多功能！

---

## 📝 實作練習

### 練習 1：使用 GDB 查看暫存器狀態

讓我們用 GDB 實際觀察 ARM 暫存器：

```bash
# 1. 啟動 QEMU (在 Docker 容器內)
cd /root/qemu/CMSIS_LM3S/examples/uart_hello_world
qemu-system-arm -M lm3s6965evb -kernel uart_hello_world.bin -nographic -s -S &

# 2. 啟動 GDB
arm-none-eabi-gdb uart_hello_world.elf

# 3. 連接到 QEMU
(gdb) target remote localhost:1234

# 4. 在 main 設定中斷點
(gdb) break main
Breakpoint 1 at 0x298: file uart_hello_world.c, line 25.

# 5. 繼續執行到 main
(gdb) continue
Breakpoint 1, main () at uart_hello_world.c:25

# 6. 查看所有暫存器
(gdb) info registers
r0             0x0      0
r1             0x0      0
r2             0x0      0
r3             0x0      0
r4             0x0      0
r5             0x0      0
r6             0x0      0
r7             0x0      0
r8             0x0      0
r9             0x0      0
r10            0x0      0
r11            0x0      0
r12            0x0      0
sp             0x2000fff8       0x2000fff8
lr             0x1ad    429
pc             0x298    0x298 <main+4>
xPSR           0x61000000       1627389952

# 7. 查看特定暫存器（十六進位）
(gdb) print/x $r0
$1 = 0x0

(gdb) print/x $sp
$2 = 0x2000fff8

(gdb) print/x $pc
$3 = 0x298

# 8. 單步執行並觀察暫存器變化
(gdb) next
(gdb) info registers r0
r0             0xa      10
```

**預期輸出解釋**：
- **SP = 0x2000FFF8**：堆疊從 RAM 尾端開始（0x20010000 - 8）
- **LR = 0x1AD**：Reset_Handler 呼叫 main() 後的返回位址
- **PC = 0x298**：目前執行到 main() 的第 4 個 byte
- **xPSR = 0x61000000**：處於 Thread 模式

---

### 練習 2：觀察函數呼叫的暫存器傳遞

修改 `uart_hello_world.c` 加入測試函數：

```c
// 加入這個測試函數
int add_four(int a, int b, int c, int d) {
    return a + b + c + d;
}

int main(void) {
    init_uart0();

    int result = add_four(10, 20, 30, 40);
    print_uart0("Result: ");
    print_uart0_hex(result);
    print_uart0("\n");

    while(1) { }
    return 0;
}
```

**使用 GDB 追蹤**：

```bash
# 在 add_four 設中斷點
(gdb) break add_four
(gdb) continue

# 查看參數（應該在 R0-R3）
(gdb) print $r0
$1 = 10
(gdb) print $r1
$2 = 20
(gdb) print $r2
$3 = 30
(gdb) print $r3
$4 = 40

# 單步執行加法
(gdb) stepi
(gdb) print $r0
$5 = 30    # 10 + 20

(gdb) stepi
(gdb) print $r0
$6 = 60    # 30 + 30

(gdb) stepi
(gdb) print $r0
$7 = 100   # 60 + 40 = 最終結果

# 返回後檢查返回值
(gdb) finish
(gdb) print $r0
$8 = 100   # 返回值在 R0
```

---

### 練習 3：檢視組合語言與 Thumb-2 指令

```bash
# 反組譯 main 函數
(gdb) disassemble main
Dump of assembler code for function main:
   0x00000294 <+0>:     push    {r4, lr}      # 16-bit 指令
   0x00000296 <+2>:     bl      0x250 <init_uart0>  # 32-bit
   0x0000029a <+6>:     movs    r0, #10       # 16-bit
   0x0000029c <+8>:     movs    r1, #20       # 16-bit
   0x0000029e <+10>:    movs    r2, #30       # 16-bit
   0x000002a0 <+12>:    movs    r3, #40       # 16-bit
   0x000002a2 <+14>:    bl      0x280 <add_four>  # 32-bit
   ...

# 查看機器碼
(gdb) x/10i main
   0x294 <main>:        b500            push    {lr}
   0x296 <main+2>:      f7ff ffdb       bl      0x250 <init_uart0>
   0x29a <main+6>:      200a            movs    r0, #10
   0x29c <main+8>:      2114            movs    r1, #20
   ...
```

**觀察重點**：
- `b500` = 2 bytes → 16-bit 指令
- `f7ff ffdb` = 4 bytes → 32-bit 指令
- 簡單的 `MOVS` 用 16-bit，跳轉用 32-bit

---

## 🎯 學習檢查點

完成本模組後，你應該能夠：

- [ ] **ARM 家族**：說明 Cortex-A、Cortex-R、Cortex-M 的差異與應用場景
- [ ] **處理器架構**：解釋 Fetch-Decode-Execute 三階管線如何加速執行
- [ ] **暫存器使用**：
  - 說出 R0-R3 用於參數傳遞，R0 用於返回值
  - 解釋 SP、LR、PC 的特殊用途
  - 理解 Caller-saved 與 Callee-saved 的差異
- [ ] **NVIC 中斷**：
  - 描述中斷發生時的 8 個步驟
  - 解釋 NVIC 如何自動保存/恢復暫存器
  - 理解中斷優先權與巢狀中斷
- [ ] **Thumb-2 指令集**：
  - 說明為什麼需要 Thumb-2（兼顧空間與效能）
  - 理解 16-bit 與 32-bit 指令的混合使用
  - 計算 Thumb-2 的空間節省比例
- [ ] **實作技能**：
  - 使用 GDB 查看暫存器狀態
  - 追蹤函數呼叫的參數傳遞
  - 閱讀反組譯的組合語言

## 🔗 下一步

[模組 06：訊號處理基礎](06-訊號處理基礎.md) - 從 CPU 架構進入數位訊號處理的世界

---

## 📚 延伸閱讀

**官方文件**：
- [ARM Cortex-M3 技術參考手冊](https://developer.arm.com/documentation/ddi0337/)
- [CMSIS 核心函式庫文件](https://arm-software.github.io/CMSIS_5/)

**本專案相關檔案**：
- [`CMSIS/Include/core_cm3.h`](../CMSIS/Include/core_cm3.h) - Cortex-M3 暫存器定義
- [`startup_gcc.c`](../startup_gcc.c) - 查看實際的向量表與 Reset_Handler
- [`lm3s_cmsis.h`](../lm3s_cmsis.h) - LM3S6965 週邊暫存器定義

**除錯指令快速參考**：
```bash
# GDB 常用指令
info registers          # 查看所有暫存器
print/x $r0            # 查看 R0 (十六進位)
print/d $r0            # 查看 R0 (十進位)
info frame             # 查看目前 stack frame
backtrace              # 查看呼叫堆疊
disassemble function   # 反組譯函數
x/10i $pc              # 查看 PC 位址的 10 條指令
```

---
**版本**: 2.0 | **日期**: 2025-11-16 | **作者**: ARM Cortex-M3 教學團隊
