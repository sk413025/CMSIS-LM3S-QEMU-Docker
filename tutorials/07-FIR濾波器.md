# 模組 07：FIR 濾波器

> 實作 FIR 低通濾波器：從理論到 CMSIS-DSP

**對應專案檔案**: [examples/arm_fir_example/arm_fir_example_f32.c](../examples/arm_fir_example/arm_fir_example_f32.c)

## 📌 學習目標
- ✅ 理解 FIR 濾波器數學原理（卷積運算）
- ✅ 使用 CMSIS-DSP FIR 函數
- ✅ 分析實際 FIR 範例程式
- ✅ 計算 SNR 評估濾波效能
- ✅ 理解區塊處理與狀態緩衝區

---

## 開始之前：為什麼需要 FIR 濾波器？

想像你正在開發一個**智慧音箱**：

```
🎤 麥克風接收的訊號：
┌────────────────────────────────────┐
│ 你的語音 (200-3000 Hz) ✓ 需要的   │
│ 空調噪音 (50-120 Hz)   ✗ 不要的   │
│ 電磁干擾 (50 Hz, 100 Hz) ✗ 不要的 │
│ 高頻雜訊 (> 4000 Hz)   ✗ 不要的   │
└────────────────────────────────────┘
```

**問題**：如何**只保留語音**，去除其他干擾？

**解答**：使用 **FIR 濾波器**！

### FIR vs IIR：為什麼選擇 FIR？

| 特性 | FIR | IIR |
|------|-----|-----|
| **穩定性** | ✅ 絕對穩定 | ⚠️ 可能不穩定 |
| **線性相位** | ✅ 可達成（對稱係數） | ❌ 難以達成 |
| **計算量** | ⚠️ 較大 | ✅ 較小 |
| **設計難度** | ✅ 簡單 | ⚠️ 複雜 |

**本專案選擇 FIR 的原因**：
- ✅ 絕對穩定（沒有回授路徑）
- ✅ 線性相位（所有頻率延遲相同，不會造成波形失真）
- ✅ 容易設計（使用 MATLAB `fir1()` 函數）

---

## 1. FIR 濾波器原理

### 1.1 什麼是「有限脈衝響應」？

**FIR = Finite Impulse Response**

想像你在**湖面上丟一顆石頭**：
```
t=0:  💧 丟石頭
t=1:  〰️ 產生波紋
t=2:  〰️〰️ 波紋擴散
t=3:  〰️〰️〰️ 波紋繼續擴散
t=4:  〰️〰️ 波紋逐漸消失
t=5:  〰️ 波紋幾乎消失
t=6:  💧 水面恢復平靜 ← "有限"時間後，響應結束
```

**FIR 濾波器就像這樣**：
- 輸入一個脈衝 → 輸出會持續一段時間
- 但**有限時間後**會結束（不像 IIR 會無限持續）

### 1.2 FIR 數學公式

```
y[n] = b₀×x[n] + b₁×x[n-1] + b₂×x[n-2] + ... + b₂₈×x[n-28]
│      │         │            │                     │
│      │         │            │                     └─ 28 個樣本之前的輸入
│      │         │            └─ 2 個樣本之前的輸入
│      │         └─ 1 個樣本之前的輸入
│      └─ 現在的輸入
└─ 現在的輸出
```

**白話解釋**：
- `y[n]` = 現在的輸出
- `x[n]` = 現在的輸入
- `x[n-1]` = 上一個樣本的輸入
- `x[n-2]` = 上上一個樣本的輸入
- `b₀, b₁, b₂, ...` = **濾波器係數**（決定每個樣本的權重）

**這就是「卷積」(Convolution)**！

### 1.3 卷積運算：生活中的例子

**例子 1：計算移動平均成績**

假設你有 5 次考試成績：`[80, 70, 90, 85, 95]`

**3 點移動平均**（取最近 3 次的平均）：
```
係數 b = [1/3, 1/3, 1/3]  ← 每個樣本權重相同

第 3 次平均 = 1/3×80 + 1/3×70 + 1/3×90 = 80
第 4 次平均 = 1/3×70 + 1/3×90 + 1/3×85 = 81.67
第 5 次平均 = 1/3×90 + 1/3×85 + 1/3×95 = 90
```

**這就是最簡單的 FIR 低通濾波器**！

**例子 2：加權移動平均**

如果你認為**最近的成績更重要**：
```
係數 b = [0.5, 0.3, 0.2]  ← 最近的權重最大

第 3 次加權平均 = 0.5×90 + 0.3×70 + 0.2×80 = 82
                  │        │        └─ 最早的 (權重 0.2)
                  │        └─ 中間的 (權重 0.3)
                  └─ 最新的 (權重 0.5)
```

**FIR 濾波器就是這樣**：透過**調整係數權重**，決定要保留哪些頻率！

### 1.4 FIR 濾波器結構圖

```
       x[n]     x[n-1]   x[n-2]   x[n-3]  ...  x[n-28]
        │         │        │        │           │
        │    ┌────┴────┐   │   ┌────┴────┐     │
        │    │  z⁻¹    │   │   │  z⁻¹    │     │
        │    │ (延遲)  │   │   │ (延遲)  │     │
        │    └────┬────┘   │   └────┬────┘     │
        ↓         ↓        ↓        ↓           ↓
       ×b₀       ×b₁      ×b₂      ×b₃   ...  ×b₂₈
        │         │        │        │           │
        └────┬────┴────┬───┴────┬───┴───── ... ┘
             │         │        │
             ↓         ↓        ↓
            [  +   +   +   +  ...  +  ] → y[n]
                    累加器
```

**關鍵元件**：
1. **延遲線**（z⁻¹）：儲存過去的樣本
2. **乘法器**（×b₀, ×b₁, ...）：每個樣本乘以係數
3. **累加器**（+）：將所有乘積相加

### 1.5 延遲線運作過程

想像一條**輸送帶**，有 29 個位置：

```
時間 t=0 (第一個樣本進來):
┌─────┬─────┬─────┬─────┬─────┬─────┬───┬─────┐
│ 0.5 │  0  │  0  │  0  │  0  │  0  │...│  0  │
└─────┴─────┴─────┴─────┴─────┴─────┴───┴─────┘
  ↑
 x[0]

時間 t=1 (第二個樣本進來):
┌─────┬─────┬─────┬─────┬─────┬─────┬───┬─────┐
│ 0.3 │ 0.5 │  0  │  0  │  0  │  0  │...│  0  │
└─────┴─────┴─────┴─────┴─────┴─────┴───┴─────┘
  ↑     ↑
 x[1] x[0]

時間 t=2 (第三個樣本進來):
┌─────┬─────┬─────┬─────┬─────┬─────┬───┬─────┐
│-0.2 │ 0.3 │ 0.5 │  0  │  0  │  0  │...│  0  │
└─────┴─────┴─────┴─────┴─────┴─────┴───┴─────┘
  ↑     ↑     ↑
 x[2] x[1] x[0]
```

**每次新樣本進來**：
1. 所有舊樣本**往右移一格**
2. 新樣本放在**最左邊**
3. 最右邊的舊樣本**被丟棄**

---

## 2. 專案 FIR 範例規格

### 2.1 設計目標

```
┌──────────────────────────────────────────────┐
│         FIR 低通濾波器規格                    │
├──────────────────────────────────────────────┤
│ 📥 輸入訊號:                                  │
│   • 1 kHz 正弦波 (語音模擬)                   │
│   • 15 kHz 正弦波 (高頻雜訊)                  │
│                                               │
│ ⚙️ 系統參數:                                  │
│   • 取樣頻率 (fs): 48,000 Hz                  │
│   • Nyquist 頻率: 24,000 Hz (fs/2)           │
│   • 濾波器長度: 29 點 (NUM_TAPS)              │
│   • 截止頻率 (fc): 6,000 Hz                   │
│   • 區塊大小: 32 樣本 (BLOCK_SIZE)            │
│   • 測試長度: 320 樣本 (TEST_LENGTH_SAMPLES)  │
│                                               │
│ 🔧 設計工具:                                  │
│   • MATLAB fir1(28, 6/24)                    │
│   • 視窗法 (Hamming Window)                   │
│                                               │
│ 📊 預期結果:                                  │
│   ✅ 保留: 1 kHz 訊號                         │
│   ❌ 濾除: 15 kHz 訊號                        │
│   📈 SNR > 140 dB (非常好的結果)              │
└──────────────────────────────────────────────┘
```

### 2.2 為什麼選擇這些參數？

**Q1: 為什麼取樣頻率是 48 kHz？**

根據 Nyquist 定理：`fs ≥ 2 × fmax`

```
我們要處理的最高頻率: 15 kHz
最小取樣頻率: 2 × 15 kHz = 30 kHz

實際選擇: 48 kHz
原因:
  ✅ 遠超過 Nyquist 要求 (30 kHz)
  ✅ 音訊標準頻率 (CD: 44.1 kHz, DVD: 48 kHz)
  ✅ 有足夠的過渡帶 (transition band)
```

**Q2: 為什麼濾波器長度是 29？**

```
濾波器長度越長 → 頻率選擇性越好，但計算量越大

29 點的優點:
  ✅ 提供足夠陡峭的截止特性
  ✅ 計算量合理 (29 次乘法 + 28 次加法)
  ✅ 對稱結構 (14 個係數重複) → 可優化計算
  ✅ 延遲可接受 (14 個樣本 = 0.29 ms)
```

**Q3: 為什麼截止頻率是 6 kHz？**

```
頻率分布:
    0 ────── 1 kHz ────── 6 kHz ──────── 15 kHz ──────── 24 kHz
    │         │           │              │               │
   DC      保留區      截止點        濾除區         Nyquist

設計考量:
  ✅ 1 kHz 遠低於 6 kHz → 完全通過
  ✅ 15 kHz 遠高於 6 kHz → 大幅衰減
  ✅ 有足夠的過渡帶 (6-15 kHz)
```

### 2.3 頻率響應圖解

```
增益 (Gain)
  1.0 │ ████████████╗
      │             ║        通帶 (Passband)
      │             ║        0 - 6 kHz
  0.5 │             ╚═══╗    ← 截止頻率 (6 kHz)
      │                 ║
      │                 ║    過渡帶 (Transition Band)
      │                 ║    6 - 10 kHz
      │                 ╚════════════╗
  0.0 │                              ╚═══════════
      │                               阻帶 (Stopband)
      │                               > 10 kHz
      └────┴────┴────┴────┴────┴────┴────┴────> 頻率
           0    6   10   15   20   24 kHz
                ↑              ↑
             1 kHz         15 kHz
            (保留)        (濾除)
```

---

## 3. 濾波器係數解析

### 3.1 MATLAB 設計過程

**步驟 1：使用 fir1() 函數**
```matlab
% 參數說明:
%   28 = 階數 (order) = 長度 - 1 = 29 - 1
%   6/24 = 正規化截止頻率 = fc/fnyquist = 6000/24000
h = fir1(28, 6/24);
```

**步驟 2：時間反轉（CMSIS-DSP 要求）**
```matlab
h_reversed = fliplr(h);  % 左右翻轉
```

**為什麼需要反轉？**

CMSIS-DSP 的卷積運算方向：
```
數學定義:      y[n] = Σ h[k] × x[n-k]
CMSIS-DSP:     y[n] = Σ h[k] × x[n+k] (反向掃描輸入)

因此係數需要先反轉，結果才會相同！
```

### 3.2 係數值分析

```c
const float32_t firCoeffs32[NUM_TAPS] = {
  -0.0018225230f,  // b[0]  ┐
  -0.0015879294f,  // b[1]  │
  +0.0000000000f,  // b[2]  │
  +0.0036977508f,  // b[3]  │
  +0.0080754303f,  // b[4]  │
  +0.0085302217f,  // b[5]  │
  -0.0000000000f,  // b[6]  │
  -0.0173976984f,  // b[7]  │
  -0.0341458607f,  // b[8]  │
  -0.0333591565f,  // b[9]  │
  +0.0000000000f,  // b[10] │ 前半部
  +0.0676308395f,  // b[11] │
  +0.1522061835f,  // b[12] │
  +0.2229246956f,  // b[13] │
  +0.2504960933f,  // b[14] ← 中心點 (最大值)
  +0.2229246956f,  // b[15] │
  +0.1522061835f,  // b[16] │
  +0.0676308395f,  // b[17] │
  +0.0000000000f,  // b[18] │
  -0.0333591565f,  // b[19] │ 後半部
  -0.0341458607f,  // b[20] │
  -0.0173976984f,  // b[21] │
  -0.0000000000f,  // b[22] │
  +0.0085302217f,  // b[23] │
  +0.0080754303f,  // b[24] │
  +0.0036977508f,  // b[25] │
  +0.0000000000f,  // b[26] │
  -0.0015879294f,  // b[27] │
  -0.0018225230f   // b[28] ┘
};
```

**觀察 1：對稱性**
```
b[0]  = b[28] = -0.0018225230
b[1]  = b[27] = -0.0015879294
b[2]  = b[26] = +0.0000000000
...
b[13] = b[15] = +0.2229246956
b[14] = 中心點 = +0.2504960933 (最大)
```

**這是線性相位 FIR 的特徵**！

**觀察 2：中心最大，兩側遞減**
```
視覺化:
           ╱╲
          ╱  ╲
         ╱    ╲
   ─────╱      ╲─────
  ╱              ╲
 ╱                ╲
╱                  ╲

這是低通濾波器的 sinc 函數特性 (經過視窗加權)
```

**觀察 3：總和接近 1**
```
Σ b[k] ≈ 1.0

這確保通帶增益為 1 (訊號不會被放大或縮小)
```

### 3.3 群延遲 (Group Delay)

因為對稱性，所有頻率的延遲相同：

```
群延遲 = (N-1)/2 = (29-1)/2 = 14 個樣本

時間延遲 = 14 / 48000 = 0.2917 ms

這就是「線性相位」的好處：
  ✅ 所有頻率成分延遲相同
  ✅ 不會造成相位失真
  ✅ 波形形狀保持不變
```

---

## 4. 程式碼完整解析

### 4.1 巨集定義

```c
#define TEST_LENGTH_SAMPLES  320    // 測試樣本總數
#define SNR_THRESHOLD_F32    140.0f // SNR 門檻 (dB)
#define BLOCK_SIZE            32    // 每次處理樣本數
#define NUM_TAPS              29    // 濾波器係數數量
```

**為什麼區塊大小是 32？**

```
區塊處理的優點:
  ✅ 記憶體效率：不需要一次載入全部 320 個樣本
  ✅ 即時處理：可以邊接收邊處理
  ✅ 快取友善：32 個 float (128 bytes) 適合 L1 cache

總共處理次數:
  numBlocks = 320 / 32 = 10 次
```

### 4.2 資料結構

**輸入訊號（外部定義）**:
```c
extern float32_t testInput_f32_1kHz_15kHz[TEST_LENGTH_SAMPLES];
// 包含 1 kHz + 15 kHz 的混合正弦波
// 由 arm_fir_lpf_data.c 提供
```

**輸出緩衝區**:
```c
static float32_t testOutput[TEST_LENGTH_SAMPLES];
// 存放濾波後的結果
```

**狀態緩衝區（超級重要！）**:
```c
static float32_t firStateF32[BLOCK_SIZE + NUM_TAPS - 1];
//                            32        + 29       - 1 = 60

為什麼需要 60 個元素？
  • NUM_TAPS (29) = 濾波器需要的歷史樣本
  • BLOCK_SIZE (32) = 當前區塊的樣本
  • -1 = 避免重複計算

結構:
  [上一個區塊的最後 28 個樣本][當前區塊的 32 個樣本]
  └────────── 29-1 ──────────┘└────────── 32 ─────────┘
```

**狀態緩衝區視覺化**:

```
第 1 個區塊處理前:
┌──────────────────────┬──────────────────────────────────┐
│ 0 0 0 ... 0 (28個)   │ x[0] x[1] ... x[31] (32個)       │
└──────────────────────┴──────────────────────────────────┘
  歷史區 (初始為0)        當前區塊

第 1 個區塊處理後:
┌──────────────────────┬──────────────────────────────────┐
│ x[4] x[5] ... x[31]  │ x[32] x[33] ... x[63] (待載入)   │
└──────────────────────┴──────────────────────────────────┘
  保留最後28個樣本        下一個區塊

第 2 個區塊處理前:
┌──────────────────────┬──────────────────────────────────┐
│ x[4] x[5] ... x[31]  │ x[32] x[33] ... x[63]            │
└──────────────────────┴──────────────────────────────────┘
  從上一個區塊延續        新的32個樣本
```

### 4.3 FIR 實例結構

```c
typedef struct {
    uint16_t numTaps;      // 係數數量 (29)
    float32_t *pState;     // 狀態緩衝區指標
    float32_t *pCoeffs;    // 係數陣列指標
} arm_fir_instance_f32;
```

**記憶體佈局**:
```
實例 S:
┌─────────────────────────────────────┐
│ numTaps = 29                        │
│ pState  ──────┐                     │
│ pCoeffs ────┐ │                     │
└─────────────│─│─────────────────────┘
              │ │
              │ └─────> [狀態緩衝區 (60個元素)]
              │
              └───────> [係數陣列 (29個元素)]
```

### 4.4 main() 函數完整流程

```c
int32_t main(void)
{
  uint32_t i;
  arm_fir_instance_f32 S;          // ① 宣告 FIR 實例
  arm_status status;               // ② 狀態變數
  float32_t  *inputF32, *outputF32; // ③ 輸入輸出指標

  // ===== 步驟 1: 初始化指標 =====
  inputF32 = &testInput_f32_1kHz_15kHz[0];
  outputF32 = &testOutput[0];

  // ===== 步驟 2: 初始化 FIR 濾波器 =====
  arm_fir_init_f32(
    &S,                    // FIR 實例
    NUM_TAPS,              // 29
    (float32_t *)&firCoeffs32[0],  // 係數陣列
    &firStateF32[0],       // 狀態緩衝區
    blockSize              // 32
  );

  // ===== 步驟 3: 區塊處理 =====
  for(i=0; i < numBlocks; i++)  // 執行 10 次
  {
    arm_fir_f32(
      &S,                           // FIR 實例
      inputF32 + (i * blockSize),   // 輸入: &input[i*32]
      outputF32 + (i * blockSize),  // 輸出: &output[i*32]
      blockSize                     // 32
    );
  }

  // ===== 步驟 4: 計算 SNR =====
  snr = arm_snr_f32(
    &refOutput[0],      // 參考訊號 (MATLAB 計算)
    &testOutput[0],     // 實際輸出
    TEST_LENGTH_SAMPLES // 320
  );

  // ===== 步驟 5: 驗證結果 =====
  if (snr < SNR_THRESHOLD_F32) {  // 140 dB
    status = ARM_MATH_TEST_FAILURE;
  } else {
    status = ARM_MATH_SUCCESS;
  }

  // ===== 步驟 6: 輸出結果 =====
  if(status != ARM_MATH_SUCCESS) {
    print_uart0("BAD\n");
  } else {
    print_uart0("GOOD\n");
  }

  while(1);  // 無窮迴圈
}
```

### 4.5 區塊處理詳細過程

**第 1 次迴圈 (i=0)**:
```c
arm_fir_f32(&S,
            inputF32 + 0,   // &input[0]
            outputF32 + 0,  // &output[0]
            32);

處理樣本:
  輸入: x[0], x[1], ..., x[31]
  輸出: y[0], y[1], ..., y[31]

每個輸出的計算:
  y[0] = b[0]×x[0] + b[1]×0 + ... + b[28]×0
         (只有 x[0] 有值，其他都是 0)

  y[1] = b[0]×x[1] + b[1]×x[0] + b[2]×0 + ...

  ...

  y[31] = b[0]×x[31] + b[1]×x[30] + ... + b[28]×x[3]
```

**第 2 次迴圈 (i=1)**:
```c
arm_fir_f32(&S,
            inputF32 + 32,   // &input[32]
            outputF32 + 32,  // &output[32]
            32);

處理樣本:
  輸入: x[32], x[33], ..., x[63]
  輸出: y[32], y[33], ..., y[63]

關鍵:
  y[32] = b[0]×x[32] + b[1]×x[31] + ... + b[28]×x[4]
          │            └──────────────────┘
          │            從狀態緩衝區取得！
          └── 當前區塊的第一個樣本
```

**這就是狀態緩衝區的作用**：保留上一個區塊的樣本，讓濾波器可以連續處理！

---

## 5. CMSIS-DSP FIR 函數詳解

### 5.1 arm_fir_init_f32()

**函數原型**:
```c
void arm_fir_init_f32(
    arm_fir_instance_f32 *S,  // FIR 實例
    uint16_t numTaps,          // 係數數量
    float32_t *pCoeffs,        // 係數陣列
    float32_t *pState,         // 狀態緩衝區
    uint32_t blockSize         // 區塊大小
);
```

**功能**：初始化 FIR 濾波器實例

**內部動作**：
```c
void arm_fir_init_f32(...) {
    // 1. 儲存參數到實例
    S->numTaps = numTaps;
    S->pCoeffs = pCoeffs;
    S->pState = pState;

    // 2. 清空狀態緩衝區
    for(i = 0; i < (blockSize + numTaps - 1); i++) {
        pState[i] = 0.0f;
    }
}
```

**呼叫範例**:
```c
arm_fir_instance_f32 S;
float32_t coeffs[29] = {...};
float32_t state[60];  // 32 + 29 - 1

arm_fir_init_f32(&S, 29, coeffs, state, 32);
```

### 5.2 arm_fir_f32()

**函數原型**:
```c
void arm_fir_f32(
    arm_fir_instance_f32 *S,  // FIR 實例
    float32_t *pSrc,           // 輸入資料指標
    float32_t *pDst,           // 輸出資料指標
    uint32_t blockSize         // 樣本數
);
```

**功能**：執行 FIR 濾波運算

**簡化版實作**:
```c
void arm_fir_f32(
    arm_fir_instance_f32 *S,
    float32_t *pSrc,
    float32_t *pDst,
    uint32_t blockSize)
{
    float32_t *pState = S->pState;
    float32_t *pCoeffs = S->pCoeffs;
    uint16_t numTaps = S->numTaps;
    uint32_t i, tapCnt;
    float32_t sum;

    // ===== 步驟 1: 複製新樣本到狀態緩衝區 =====
    for(i = 0; i < blockSize; i++) {
        pState[numTaps - 1 + i] = pSrc[i];
    }

    // ===== 步驟 2: 計算每個輸出樣本 =====
    for(i = 0; i < blockSize; i++) {
        sum = 0.0f;

        // 卷積運算
        for(tapCnt = 0; tapCnt < numTaps; tapCnt++) {
            sum += pCoeffs[tapCnt] * pState[i + tapCnt];
        }

        pDst[i] = sum;
    }

    // ===== 步驟 3: 移動狀態緩衝區 =====
    for(i = 0; i < numTaps - 1; i++) {
        pState[i] = pState[blockSize + i];
    }
}
```

**視覺化卷積運算**（計算 y[0]）:

```
狀態緩衝區: [0  0  0 ... 0  x[0] x[1] ... x[31]]
                              ↑
                           i=0 位置

係數:       [b[0] b[1] b[2] ... b[28]]

對齊計算:
  b[0]  × pState[0]     = b[0]  × 0
  b[1]  × pState[1]     = b[1]  × 0
  ...
  b[28] × pState[28]    = b[28] × 0
  ────────────────────────────────
  sum = 0 (幾乎為 0，因為大部分是 0)

y[0] = sum
```

**視覺化卷積運算**（計算 y[31]）:

```
狀態緩衝區: [0 ... 0  x[0] x[1] ... x[31]]
                       ↑
                    i=31 位置

對齊計算:
  b[0]  × pState[31]    = b[0]  × x[31]
  b[1]  × pState[32]    = b[1]  × x[30]
  ...
  b[28] × pState[59]    = b[28] × x[3]
  ─────────────────────────────────────
  sum = 完整的 29 點卷積

y[31] = sum (第一個有完整計算的輸出)
```

**關鍵觀察**：
- 前 28 個輸出（y[0] ~ y[27]）受到**暫態響應**影響
- 從 y[28] 開始才是**穩態響應**

### 5.3 效能分析

**每個樣本的運算量**:
```
乘法: 29 次
加法: 28 次
總計: 57 次浮點運算

Cortex-M3 (無硬體浮點):
  每個乘法: ~20 個 CPU 週期
  每個加法: ~15 個 CPU 週期

  總週期: 29×20 + 28×15 = 580 + 420 = 1000 週期

假設 CPU 時脈 50 MHz:
  每個樣本時間: 1000 / 50,000,000 = 20 μs
  最大處理速率: 1 / 20μs = 50,000 Hz

我們的取樣率 48 kHz < 50 kHz ✓ (勉強可以)
```

**注意**：這是簡化計算，實際還有迴圈開銷、記憶體存取等。

**如果有硬體浮點單元（Cortex-M4F）**:
```
每個乘法: ~1 個週期
每個加法: ~1 個週期

總週期: 29 + 28 = 57 週期
每個樣本時間: 57 / 50,000,000 = 1.14 μs
最大處理速率: ~877 kHz (輕鬆處理 48 kHz)
```

---

## 6. SNR 計算詳解

### 6.1 什麼是 SNR？

**SNR = Signal-to-Noise Ratio = 信號雜訊比**

```
         訊號功率
SNR = ──────────── (線性比值)
         雜訊功率

SNR (dB) = 10 × log₁₀(訊號功率 / 雜訊功率)
```

**白話解釋**：
- SNR 高 → 訊號乾淨，雜訊少
- SNR 低 → 訊號被雜訊掩蓋

**常見 SNR 值**:
```
  0 dB  → 訊號與雜訊一樣強 (完全聽不清楚)
 20 dB  → 訊號是雜訊的 100 倍 (勉強聽得到)
 40 dB  → 訊號是雜訊的 10,000 倍 (清楚)
 60 dB  → 訊號是雜訊的 1,000,000 倍 (非常清楚)
140 dB  → 訊號是雜訊的 10^14 倍 (幾乎完美)
```

### 6.2 arm_snr_f32() 函數

**函數原型**:
```c
float32_t arm_snr_f32(
    float32_t *pRef,    // 參考訊號 (理想輸出)
    float32_t *pTest,   // 測試訊號 (實際輸出)
    uint32_t buffSize   // 樣本數
);
```

**內部實作**:
```c
float32_t arm_snr_f32(
    float32_t *pRef,
    float32_t *pTest,
    uint32_t buffSize)
{
    float32_t signalPower = 0.0f;
    float32_t noisePower = 0.0f;
    float32_t diff;
    uint32_t i;

    // ===== 步驟 1: 計算訊號功率 =====
    for(i = 0; i < buffSize; i++) {
        signalPower += pRef[i] * pRef[i];
    }

    // ===== 步驟 2: 計算雜訊功率 =====
    for(i = 0; i < buffSize; i++) {
        diff = pRef[i] - pTest[i];  // 誤差
        noisePower += diff * diff;   // 誤差平方
    }

    // ===== 步驟 3: 計算 SNR =====
    if(noisePower > 0.0f) {
        return 10.0f * log10f(signalPower / noisePower);
    } else {
        return 0.0f;  // 避免除以 0
    }
}
```

### 6.3 計算範例

假設有 4 個樣本：

```
i    pRef[i]   pTest[i]   diff      diff²
0    0.5        0.51      -0.01     0.0001
1    0.8        0.79       0.01     0.0001
2   -0.3       -0.31       0.01     0.0001
3    0.0        0.01      -0.01     0.0001

步驟 1: 訊號功率
  signalPower = 0.5² + 0.8² + (-0.3)² + 0.0²
              = 0.25 + 0.64 + 0.09 + 0.0
              = 0.98

步驟 2: 雜訊功率
  noisePower = 0.0001 + 0.0001 + 0.0001 + 0.0001
             = 0.0004

步驟 3: SNR
  SNR = 10 × log₁₀(0.98 / 0.0004)
      = 10 × log₁₀(2450)
      = 10 × 3.389
      = 33.89 dB
```

### 6.4 專案中的 SNR

```c
snr = arm_snr_f32(&refOutput[0], &testOutput[0], 320);

if (snr < SNR_THRESHOLD_F32) {  // 140.0 dB
    status = ARM_MATH_TEST_FAILURE;
} else {
    status = ARM_MATH_SUCCESS;
    print_uart0("GOOD\n");
}
```

**為什麼門檻是 140 dB？**

```
140 dB 代表:
  訊號功率 / 雜訊功率 = 10^(140/10) = 10^14

這意味著:
  ✅ 實際輸出幾乎等於理想輸出
  ✅ 浮點運算誤差極小
  ✅ 濾波器實作正確

實際執行結果通常 > 200 dB (完美)
```

---

## 7. 編譯與執行

### 7.1 編譯專案

```bash
# 進入範例目錄
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/arm_fir_example

# 編譯
make

# 預期輸出:
#   CC    arm_fir_example_f32.c
#   CC    arm_fir_lpf_data.c
#   CC    startup_gcc.c
#   LD    arm_fir_example_f32.axf
#   OBJCOPY arm_fir_example_f32.bin
```

**編譯產生的檔案**:
```
gcc/
├── arm_fir_example_f32.axf    ← ELF 可執行檔 (含除錯資訊)
├── arm_fir_example_f32.bin    ← 二進位檔 (燒錄用)
├── arm_fir_example_f32.o      ← 主程式物件檔
├── arm_fir_lpf_data.o         ← 測試資料物件檔
└── startup_gcc.o              ← 啟動程式物件檔
```

### 7.2 執行模擬

```bash
# 使用 Docker + QEMU 執行
docker run --rm \
    -v /home/sbplab/jiawei/qemu/CMSIS_LM3S:/work:ro \
    cmsis-lm3s-qemu:latest \
    bash -c "cd /work/examples/arm_fir_example/gcc && \
             timeout 3 qemu-system-arm -M lm3s6965evb -nographic \
                     -kernel arm_fir_example_f32.bin"

# 預期輸出:
# GOOD
```

**指令解析**:
```
docker run --rm              移除容器執行後
  -v /path:/work:ro          掛載專案目錄 (唯讀)
  cmsis-lm3s-qemu:latest     使用 Docker 映像
  bash -c "..."              執行命令

qemu-system-arm              ARM 模擬器
  -M lm3s6965evb             模擬 LM3S6965 開發板
  -nographic                 無圖形介面 (僅序列埠)
  -kernel xxx.bin            載入二進位檔

timeout 3                    3 秒後強制結束 (避免無窮迴圈卡住)
```

### 7.3 結果驗證

**成功輸出**:
```
GOOD
```

**失敗輸出**:
```
BAD
```

**可能的失敗原因**:
1. 濾波器係數錯誤
2. 狀態緩衝區大小不正確
3. 區塊大小設定錯誤
4. 輸入資料損壞
5. SNR 門檻設定過高

---

## 8. 實作練習

### 8.1 練習 1：使用 GDB 觀察濾波過程

**目標**：觀察第一個區塊的處理過程

**步驟**:

```bash
# 1. 啟動 QEMU 除錯模式
docker run --rm \
    -v /home/sbplab/jiawei/qemu/CMSIS_LM3S:/work:ro \
    -p 1234:1234 \
    cmsis-lm3s-qemu:latest \
    bash -c "cd /work/examples/arm_fir_example/gcc && \
             qemu-system-arm -M lm3s6965evb -nographic \
                     -kernel arm_fir_example_f32.axf -s -S"

# 2. 另開終端，啟動 GDB
docker run --rm -it \
    -v /home/sbplab/jiawei/qemu/CMSIS_LM3S:/work:ro \
    --network host \
    cmsis-lm3s-gdb:latest \
    bash -c "cd /work/examples/arm_fir_example/gcc && \
             arm-none-eabi-gdb arm_fir_example_f32.axf"

# 3. GDB 命令
(gdb) target remote localhost:1234
(gdb) break arm_fir_f32          # 在 FIR 函數設中斷點
(gdb) continue

# 4. 查看參數
(gdb) print blockSize
$1 = 32

(gdb) print *S
$2 = {
  numTaps = 29,
  pState = 0x20000xxx,
  pCoeffs = 0x20000yyy
}

# 5. 查看輸入資料 (前 8 個樣本)
(gdb) x/8f pSrc
0x20000xxx:  0.000000   0.130526   0.258819   0.382683
0x20000xxx:  0.500000   0.608761   0.707107   0.793353

# 6. 執行一次濾波
(gdb) finish

# 7. 查看輸出資料 (前 8 個樣本)
(gdb) x/8f pDst
0x20000xxx: -0.000000  -0.000207  -0.000471  -0.000719
0x20000xxx: -0.000910  -0.001014  -0.001013  -0.000893

# 觀察: 輸出值很小，因為還在暫態響應階段
```

**預期結果**：
- 前幾個輸出非常小（暫態）
- 後面輸出逐漸變大（趨向穩態）

### 8.2 練習 2：查看濾波器係數

```bash
(gdb) print S.numTaps
$1 = 29

(gdb) x/29f S.pCoeffs
0x20000xxx: -0.00182252  -0.00158793   0.00000000   0.00369775
0x20000xxx:  0.00807543   0.00853022  -0.00000000  -0.01739770
0x20000xxx: -0.03414586  -0.03335916   0.00000000   0.06763084
0x20000xxx:  0.15220618   0.22292470   0.25049609   0.22292470
0x20000xxx:  0.15220618   0.06763084   0.00000000  -0.03335916
0x20000xxx: -0.03414586  -0.01739770  -0.00000000   0.00853022
0x20000xxx:  0.00807543   0.00369775   0.00000000  -0.00158793
0x20000xxx: -0.00182252

# 驗證對稱性
(gdb) print S.pCoeffs[0] == S.pCoeffs[28]
$2 = 1  # True

(gdb) print S.pCoeffs[14]  # 中心點 (最大值)
$3 = 0.25049609
```

### 8.3 練習 3：手動計算一個輸出樣本

**目標**：手動計算 y[28]（第一個完整的輸出）

**步驟**:

1. **獲取輸入樣本** x[0] ~ x[28]:
```bash
(gdb) set $i = 0
(gdb) while ($i < 29)
    print testInput_f32_1kHz_15kHz[$i]
    set $i = $i + 1
  end
```

2. **獲取係數** b[0] ~ b[28]:
```bash
(gdb) x/29f firCoeffs32
```

3. **手動計算**:
```python
# 用 Python 計算
import numpy as np

x = [0.000, 0.131, 0.259, ...]  # 從 GDB 複製
b = [-0.00182, -0.00159, 0.0, ...]  # 從 GDB 複製

y_28 = sum(b[k] * x[28-k] for k in range(29))
print(f"y[28] = {y_28}")
```

4. **對比 GDB 結果**:
```bash
(gdb) print testOutput[28]
```

**預期**：手算值與 GDB 值應該非常接近（浮點誤差在 1e-6 內）

### 8.4 練習 4：修改截止頻率

**挑戰**：將截止頻率從 6 kHz 改為 3 kHz

**步驟**:

1. **使用 MATLAB 重新設計**:
```matlab
% 新的正規化截止頻率: 3 kHz / 24 kHz = 0.125
h = fir1(28, 3/24);
h_reversed = fliplr(h);

% 顯示係數 (C 語言格式)
fprintf('const float32_t firCoeffs32[NUM_TAPS] = {\n');
for i = 1:29
    fprintf('  %+.10ff', h_reversed(i));
    if i < 29
        fprintf(',');
    end
    if mod(i, 4) == 0
        fprintf('\n');
    end
end
fprintf('\n};\n');
```

2. **替換專案中的係數**:

編輯 [arm_fir_example_f32.c](../examples/arm_fir_example/arm_fir_example_f32.c)，替換 `firCoeffs32` 陣列。

3. **重新編譯並執行**:
```bash
make clean
make
# 執行 QEMU...
```

**預期結果**：
- SNR 會降低（因為 3 kHz 接近 1 kHz，會稍微衰減）
- 15 kHz 仍會被濾除

---

## 9. 常見問題與除錯

### 9.1 常見錯誤

**錯誤 1：輸出全為 0**

```
原因:
  ✗ 忘記初始化 FIR
  ✗ 係數陣列為 0
  ✗ 輸入訊號為 0

檢查:
  (gdb) print S.numTaps
  (gdb) x/29f S.pCoeffs
  (gdb) x/32f inputF32
```

**錯誤 2：SNR 很低（< 50 dB）**

```
原因:
  ✗ 係數順序錯誤（沒有反轉）
  ✗ 狀態緩衝區大小錯誤
  ✗ 區塊大小設定錯誤

檢查:
  (gdb) print sizeof(firStateF32) / sizeof(float32_t)
  應該是: 60 (32 + 29 - 1)
```

**錯誤 3：程式當機（HardFault）**

```
原因:
  ✗ 指標錯誤
  ✗ 陣列越界
  ✗ 堆疊溢位

檢查:
  (gdb) backtrace
  (gdb) info registers
  (gdb) x/10x $sp
```

### 9.2 效能最佳化技巧

**技巧 1：使用對稱性減少運算**

```c
// 一般實作: 29 次乘法
for(k = 0; k < 29; k++) {
    sum += b[k] * x[n-k];
}

// 利用對稱性: 15 次乘法
for(k = 0; k < 14; k++) {
    sum += b[k] * (x[n-k] + x[n-(28-k)]);
}
sum += b[14] * x[n-14];  // 中心點

省下: 14 次乘法 (~48% 運算量)
```

**技巧 2：使用定點運算**

```c
// 浮點: arm_fir_f32()
// 定點 Q15: arm_fir_q15()
// 定點 Q31: arm_fir_q31()

Q15 優點:
  ✅ 運算速度快 3-5 倍
  ✅ 記憶體減半 (16-bit vs 32-bit)
  ⚠️ 動態範圍較小
  ⚠️ 需要手動縮放
```

**技巧 3：使用快速卷積（FFT-based）**

```
當濾波器長度 > 64:
  時域卷積: O(N × M)
  頻域卷積: O(N × log N)

但專案中 N=29 < 64，時域卷積更快
```

---

## 10. 深入理解：為什麼 FIR 能濾波？

### 10.1 頻域觀點

**時域卷積 = 頻域相乘**

```
時域:  y[n] = x[n] ⊗ h[n]  (卷積)
          ↓ Fourier Transform
頻域:  Y(f) = X(f) × H(f)  (相乘)
```

**濾波器頻率響應 H(f)**:

```
H(f) 就是濾波器係數的傅立葉轉換

低通濾波器:
  H(f) = 1   當 f < fc (通過)
  H(f) = 0   當 f > fc (阻擋)

實際上是:
  H(f) ≈ 1   當 f < fc
  H(f) ≈ 0   當 f > fc
  H(f) = 0.5 當 f = fc (截止點)
```

**輸入訊號 X(f)**:

```
1 kHz 正弦波:
  X(f) = δ(f - 1000) + δ(f + 1000)

15 kHz 正弦波:
  X(f) = δ(f - 15000) + δ(f + 15000)

混合訊號:
  X(f) = δ(f - 1000) + δ(f + 1000) +
         δ(f - 15000) + δ(f + 15000)
```

**輸出訊號 Y(f)**:

```
Y(f) = X(f) × H(f)

對於 1 kHz: H(1000) ≈ 1   → 完全通過
對於 15 kHz: H(15000) ≈ 0  → 完全阻擋

所以:
  Y(f) ≈ δ(f - 1000) + δ(f + 1000)

只剩下 1 kHz！
```

### 10.2 直觀解釋

**濾波器係數像是「頻率選擇器」**:

```
低頻訊號 (1 kHz):
  變化慢 → 相鄰樣本值接近

  x[n]   = [0.0, 0.1, 0.2, 0.3, 0.4, ...]
  x[n-1] = [?,   0.0, 0.1, 0.2, 0.3, ...]

  差異小 → 濾波器係數「喜歡」這種平滑的訊號
  → 通過

高頻訊號 (15 kHz):
  變化快 → 相鄰樣本值差異大

  x[n]   = [ 0.0,  0.9, -0.8,  0.7, -0.6, ...]
  x[n-1] = [?,    0.0,  0.9, -0.8,  0.7, ...]

  劇烈震盪 → 正負係數相乘後「互相抵消」
  → 阻擋
```

**類比**：

想像你在**計算學生的平均成績**：

```
學生 A (穩定型):
  成績: [80, 82, 81, 83, 80] → 平均 81.2 ✓

學生 B (不穩定型):
  成績: [100, 20, 95, 15, 100] → 平均 66 ✗

移動平均濾波器:
  喜歡穩定的訊號 (低頻)
  不喜歡震盪的訊號 (高頻)
```

---

## 11. 進階主題

### 11.1 視窗函數的影響

**為什麼需要視窗？**

```
理想低通濾波器 (Brick-wall):
  H(f) = 1  for |f| < fc
  H(f) = 0  for |f| > fc

問題:
  時域對應 sinc 函數: h(t) = sinc(2πfct)
  長度無限！實際上無法實現

解決:
  截斷 sinc 函數 → 只取有限長度
  但直接截斷會產生 Gibbs 現象 (頻域震盪)
```

**視窗函數**:

```
Hamming Window (fir1 預設):
  w[n] = 0.54 - 0.46 × cos(2πn/(N-1))

效果:
  平滑地截斷 sinc 函數
  減少 Gibbs 現象
  但過渡帶變寬
```

**其他視窗**:

| 視窗 | 主瓣寬度 | 旁瓣衰減 | 適用場景 |
|------|---------|---------|---------|
| Rectangular | 窄 | 低 (-13 dB) | 不推薦 |
| Hamming | 中 | 中 (-43 dB) | 一般用途 ✓ |
| Blackman | 寬 | 高 (-58 dB) | 高精度 |
| Kaiser | 可調 | 可調 | 專業設計 |

### 11.2 線性相位的重要性

**相位失真 vs 振幅失真**:

```
輸入: 方波 (基頻 + 3次諧波 + 5次諧波 + ...)

情況 1: 只有振幅失真
  基頻: 振幅 1.0, 相位 0°
  3次:  振幅 0.2, 相位 0°   (被衰減但相位不變)
  5次:  振幅 0.1, 相位 0°
  → 波形形狀改變，但邊緣對齊 ✓

情況 2: 有相位失真
  基頻: 振幅 1.0, 相位 0°
  3次:  振幅 0.3, 相位 -30° (相位偏移!)
  5次:  振幅 0.3, 相位 -60°
  → 波形嚴重變形，邊緣錯位 ✗
```

**FIR 線性相位的好處**:

```
所有頻率延遲相同:
  τ = (N-1)/2 = 14 個樣本

時域:
  y[n] = x[n - 14]  (所有頻率)

好處:
  ✅ 波形形狀保持
  ✅ 適合音訊、影像處理
  ✅ 適合脈衝訊號
```

### 11.3 FIR vs IIR 詳細比較

| 特性 | FIR | IIR |
|------|-----|-----|
| **穩定性** | ✅ 絕對穩定 (無極點) | ⚠️ 需檢查極點位置 |
| **線性相位** | ✅ 容易實現 (對稱係數) | ❌ 幾乎不可能 |
| **計算複雜度** | ⚠️ 高 (長濾波器) | ✅ 低 (短濾波器) |
| **記憶體需求** | ⚠️ 大 (儲存所有係數) | ✅ 小 (少數係數) |
| **設計難度** | ✅ 簡單 (視窗法、頻率取樣) | ⚠️ 複雜 (極零點配置) |
| **量化敏感度** | ✅ 低 | ⚠️ 高 (可能變不穩定) |
| **適用場景** | 音訊、影像、通訊 | 控制系統、音效 |

**何時選擇 FIR**:
- ✅ 需要線性相位（音訊、影像）
- ✅ 穩定性要求高（醫療、安全）
- ✅ 有足夠的計算資源

**何時選擇 IIR**:
- ✅ 計算資源有限
- ✅ 需要陡峭的截止特性
- ✅ 不在乎相位失真（功率譜分析）

---

## 🎯 學習檢查點

完成本模組後，你應該能夠：

### 理論理解
- [ ] 解釋什麼是 FIR 濾波器的卷積運算
- [ ] 說明延遲線的運作原理
- [ ] 理解為什麼對稱係數能達成線性相位
- [ ] 計算濾波器的群延遲
- [ ] 解釋 Nyquist 定理在濾波器設計中的應用

### CMSIS-DSP 使用
- [ ] 會使用 `arm_fir_init_f32()` 初始化濾波器
- [ ] 會使用 `arm_fir_f32()` 執行濾波運算
- [ ] 理解狀態緩衝區的大小計算 (`blockSize + numTaps - 1`)
- [ ] 理解區塊處理的概念與優點

### 實作能力
- [ ] 能夠編譯並執行 FIR 範例
- [ ] 會使用 GDB 觀察濾波過程
- [ ] 能夠手動計算卷積結果並驗證
- [ ] 會使用 MATLAB `fir1()` 設計濾波器
- [ ] 能夠修改係數並重新編譯

### 效能分析
- [ ] 計算每個樣本的運算量（乘法、加法次數）
- [ ] 估算 CPU 週期數
- [ ] 理解 SNR 的意義與計算方法
- [ ] 會使用 `arm_snr_f32()` 驗證結果

### 進階理解
- [ ] 理解時域卷積與頻域相乘的關係
- [ ] 知道視窗函數的作用
- [ ] 能夠比較 FIR 與 IIR 的優缺點
- [ ] 知道如何優化 FIR 濾波器效能

---

## 🔗 下一步

恭喜你完成 FIR 濾波器的學習！

**接下來**:
- [模組 08：IIR 濾波器](08-IIR濾波器.md) - 學習遞迴濾波器
- [模組 12：CMSIS-DSP 函式庫](12-CMSIS-DSP函式庫.md) - 探索更多 DSP 函數

**實戰應用**:
- 語音降噪
- 音訊等化器
- 心電圖濾波
- 振動分析

---

**版本**: 2.0 | **日期**: 2025-11-16 | **作者**: Claude Code Teaching Assistant
