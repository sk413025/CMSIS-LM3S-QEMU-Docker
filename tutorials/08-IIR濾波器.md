# 模組 08：IIR 濾波器

> 理解無限脈衝響應濾波器與 Biquad 級聯結構

**對應 CMSIS-DSP 函數**: [arm_biquad_cascade_df2T_f32.c](../CMSIS/DSP_Lib/Source/FilteringFunctions/arm_biquad_cascade_df2T_f32.c)

## 📌 學習目標
- ✅ 理解 IIR 濾波器原理（回授機制）
- ✅ 認識 Biquad 級聯結構
- ✅ 深入比較 FIR 與 IIR 的權衡
- ✅ 了解穩定性問題與解決方案
- ✅ 學習 Direct Form II Transposed 實作

---

## 開始之前：為什麼需要 IIR 濾波器？

想像你正在設計一個**低功耗穿戴式裝置**（智慧手環）：

```
⚡ 電池容量: 200 mAh (續航 7 天)
💾 記憶體: 32 KB SRAM
🔋 CPU: 8 MHz (低功耗模式)

任務: 即時濾波心率訊號 (100 Hz 取樣)
```

**挑戰**：

```
使用 FIR 濾波器 (29 點):
  記憶體: 29 × 4 bytes = 116 bytes (係數)
          60 × 4 bytes = 240 bytes (狀態)
          總計: 356 bytes

  運算: 29 次乘法 + 28 次加法 = 57 次運算/樣本
        @ 100 Hz → 5,700 次運算/秒

使用 IIR 濾波器 (2 級 Biquad):
  記憶體: 10 × 4 bytes = 40 bytes (係數)
          4 × 4 bytes = 16 bytes (狀態)
          總計: 56 bytes ✓ (省 84%)

  運算: 10 次乘法 + 8 次加法 = 18 次運算/樣本
        @ 100 Hz → 1,800 次運算/秒 ✓ (省 68%)
```

**這就是為什麼需要 IIR**：在資源受限的系統中，IIR 提供**相同的濾波效果，但使用更少資源**！

### IIR vs FIR：快速比較

| 特性 | FIR | IIR |
|------|-----|-----|
| **記憶體** | ❌ 大 (29 taps = 356 bytes) | ✅ 小 (2 stages = 56 bytes) |
| **運算量** | ❌ 大 (57 ops/sample) | ✅ 小 (18 ops/sample) |
| **功耗** | ❌ 高 | ✅ 低 |
| **穩定性** | ✅ 絕對穩定 | ⚠️ 需檢查極點 |
| **相位** | ✅ 線性相位 | ❌ 非線性相位 |
| **設計** | ✅ 簡單 | ⚠️ 較複雜 |

**本模組將教你**：
- ✅ 何時使用 IIR（資源受限、對相位不敏感）
- ✅ 如何確保穩定性（Biquad 級聯、極點檢查）
- ✅ 如何使用 CMSIS-DSP Biquad 函數

---

## 1. IIR 濾波器原理

### 1.1 什麼是「無限脈衝響應」？

**IIR = Infinite Impulse Response**

想像你在**峽谷中大喊一聲**：

```
FIR 濾波器（開闊草原）:
t=0:  你喊 "Hello!"
t=1:  回音 "Hello..."
t=2:  回音 "ello..."
t=3:  回音 "lo..."
t=4:  回音 "o..."
t=5:  (靜音) ← 回音結束 (有限時間)

IIR 濾波器（峽谷迴音）:
t=0:  你喊 "Hello!"
t=1:  回音 "Hello..." (第一次反射)
t=2:  回音 "Hello..." + "ello..." (第二次反射)
t=3:  回音 "ello..." + "lo..." (持續反射)
t=4:  回音 "lo..." + "o..." (越來越小)
t=5:  回音 "o..." + ... (越來越小)
...   (理論上永遠不會完全靜音) ← 無限持續
```

**關鍵差異**：
- **FIR**：沒有回授 → 脈衝響應在有限時間內結束
- **IIR**：有回授 → 脈衝響應理論上無限持續（但逐漸衰減）

### 1.2 IIR 數學公式

**一般形式**:
```
y[n] = b₀×x[n] + b₁×x[n-1] + b₂×x[n-2] + ...
       - a₁×y[n-1] - a₂×y[n-2] - ...

       └──── 前饋 (Feedforward) ────┘
                     └──── 回授 (Feedback) ────┘
```

**白話解釋**：
```
現在的輸出 = 現在和過去的輸入 × 權重
            + 過去的輸出 × 權重
            │              │
            │              └─ 回授：這就是 IIR 的核心！
            └─ 前饋：跟 FIR 一樣
```

**與 FIR 對比**:

```
FIR:  y[n] = b₀×x[n] + b₁×x[n-1] + b₂×x[n-2] + ...
             (只用過去的輸入)

IIR:  y[n] = b₀×x[n] + b₁×x[n-1] + b₂×x[n-2] + ...
             - a₁×y[n-1] - a₂×y[n-2] - ...
             (加上過去的輸出！)
```

### 1.3 回授機制：生活中的例子

**例子 1：複利計算（正回授）**

```
初始存款: $1000
年利率: 5%

無回授（單利）:
  第 1 年: 1000 + 1000×0.05 = 1050
  第 2 年: 1000 + 1000×0.05 = 1050
  第 3 年: 1000 + 1000×0.05 = 1050
  (每年利息相同)

有回授（複利）:
  第 1 年: 1000 × (1 + 0.05) = 1050
  第 2 年: 1050 × (1 + 0.05) = 1102.5  ← 用前一年的結果
  第 3 年: 1102.5 × (1 + 0.05) = 1157.6  ← 持續回授
  (利息越來越多！)

這就是回授的威力！
```

**例子 2：雪崩效應（不穩定的回授）**

```
山頂小雪球:
  第 1 秒: 體積 V
  第 2 秒: 體積 V + V×0.5 = 1.5V  ← 收集更多雪
  第 3 秒: 體積 1.5V + 1.5V×0.5 = 2.25V
  第 4 秒: 體積 2.25V + 2.25V×0.5 = 3.375V
  ...
  (指數成長 → 失控！) ← 不穩定的回授

這就是 IIR 可能不穩定的原因！
```

### 1.4 IIR 濾波器結構圖

**Direct Form II Transposed (最常用)**:

```
                  前饋路徑
               ↓         ↓
     x[n] ──→(+)───×b₀──→(+)───→ y[n]
              ↑           ↑
              │           │
            [d₁] ←─ ─ ─ ─┤
              ↑           │ 回授路徑
              │           │
       ×b₁ ← │ → ×a₁     │
              │           │
            [d₂] ←─ ─ ─ ─┤
              ↑           │
              │           │
       ×b₂ ← │ → ×a₂     │
              │           │
              └───────────┘

關鍵觀察:
  • d₁, d₂ = 狀態變數 (delay states)
  • b₀, b₁, b₂ = 前饋係數 (feedforward)
  • a₁, a₂ = 回授係數 (feedback)
  • 輸出 y[n] 會被送回去影響下一次計算！
```

**差分方程式**:
```
y[n] = b₀×x[n] + d₁
d₁ = b₁×x[n] + a₁×y[n] + d₂
d₂ = b₂×x[n] + a₂×y[n]

執行順序:
  1. 計算 y[n] (用當前 x[n] 和舊的 d₁)
  2. 更新 d₁ (用 x[n], y[n], 舊的 d₂)
  3. 更新 d₂ (用 x[n], y[n])
```

### 1.5 單一樣本處理範例

假設：`b₀=1.0, b₁=0.5, b₂=0.2, a₁=-0.8, a₂=0.3`

**初始狀態**: `d₁=0, d₂=0`

```
時間 n=0, 輸入 x[0]=1.0:
  步驟 1: y[0] = b₀×x[0] + d₁
               = 1.0×1.0 + 0
               = 1.0

  步驟 2: d₁ = b₁×x[0] + a₁×y[0] + d₂
             = 0.5×1.0 + (-0.8)×1.0 + 0
             = 0.5 - 0.8
             = -0.3

  步驟 3: d₂ = b₂×x[0] + a₂×y[0]
             = 0.2×1.0 + 0.3×1.0
             = 0.2 + 0.3
             = 0.5

  新狀態: d₁=-0.3, d₂=0.5

時間 n=1, 輸入 x[1]=0:
  步驟 1: y[1] = b₀×x[1] + d₁
               = 1.0×0 + (-0.3)
               = -0.3  ← 即使輸入為 0，輸出不為 0！

  步驟 2: d₁ = b₁×x[1] + a₁×y[1] + d₂
             = 0.5×0 + (-0.8)×(-0.3) + 0.5
             = 0 + 0.24 + 0.5
             = 0.74

  步驟 3: d₂ = b₂×x[1] + a₂×y[1]
             = 0.2×0 + 0.3×(-0.3)
             = -0.09

  新狀態: d₁=0.74, d₂=-0.09

時間 n=2, 輸入 x[2]=0:
  步驟 1: y[2] = b₀×x[2] + d₁
               = 1.0×0 + 0.74
               = 0.74  ← 還是有輸出！

  (持續計算，輸出會逐漸衰減但不會立即為 0)
```

**觀察**：
- ✅ 即使輸入變成 0，輸出還會持續一段時間
- ✅ 這就是「無限脈衝響應」的意義
- ✅ 回授係數 a₁, a₂ 決定響應持續多久

---

## 2. Biquad（二階節）結構

### 2.1 什麼是 Biquad？

**Biquad = Bi-Quadratic = 二次方 = 二階濾波器**

```
轉移函數:
         b₀ + b₁z⁻¹ + b₂z⁻²
H(z) = ─────────────────────
         1 + a₁z⁻¹ + a₂z⁻²

         分子 2 階 (z⁻²)
         分母 2 階 (z⁻²)
         → 二階濾波器
```

**為什麼叫 "Biquad"？**
- 分子和分母都是**二次多項式**
- 有 2 個極點 (poles) 和 2 個零點 (zeros)

### 2.2 為什麼使用 Biquad 而非高階直接實作？

**問題：8 階 IIR 濾波器設計**

```
方法 1: 直接實作 8 階濾波器
  H(z) = (b₀ + b₁z⁻¹ + ... + b₈z⁻⁸) / (1 + a₁z⁻¹ + ... + a₈z⁻⁸)

  問題:
    ❌ 係數對量化誤差極度敏感
    ❌ 浮點運算誤差累積
    ❌ 可能變不穩定
    ❌ 難以調試

方法 2: 4 個 Biquad 級聯
  H(z) = H₁(z) × H₂(z) × H₃(z) × H₄(z)

  每個 Hᵢ(z) 都是 2 階 Biquad

  優點:
    ✅ 每級獨立 → 容易穩定
    ✅ 係數敏感度低
    ✅ 數值誤差小
    ✅ 容易調試每一級
    ✅ 可以分別設計每一級（高通、低通、帶通...）
```

### 2.3 Biquad 級聯結構

**類比：淨水器**

```
自來水 → [粗濾網] → [活性碳] → [逆滲透膜] → [礦物質添加] → 純淨水
          (第1級)    (第2級)    (第3級)      (第4級)

每一級負責不同任務:
  • 粗濾網: 去除大顆粒雜質
  • 活性碳: 去除氯氣、異味
  • 逆滲透膜: 去除重金屬、細菌
  • 礦物質: 添加有益礦物質

IIR 級聯也是一樣:
  x[n] → [Biquad 1] → [Biquad 2] → [Biquad 3] → [Biquad 4] → y[n]
         (低頻極點)   (高頻零點)   (帶通)      (增益調整)

每一級負責頻率響應的一部分！
```

**級聯結構圖**:

```
  x[n] ─┬→ [Biquad 1] ─┬→ [Biquad 2] ─┬→ [Biquad 3] ─┬→ y[n]
        │   H₁(z)      │   H₂(z)      │   H₃(z)      │
        │               │               │               │
      5 個係數        5 個係數        5 個係數
      (b₀,b₁,b₂,      (b₀,b₁,b₂,      (b₀,b₁,b₂,
       a₁,a₂)          a₁,a₂)          a₁,a₂)
        │               │               │
      2 個狀態        2 個狀態        2 個狀態
      (d₁,d₂)        (d₁,d₂)        (d₁,d₂)

總係數數量: 3 × 5 = 15 個
總狀態數量: 3 × 2 = 6 個
```

### 2.4 階數與級數的關係

```
濾波器階數 → Biquad 級數 → 係數數量 → 狀態數量
─────────────────────────────────────────────
    2 階         1 級          5           2
    4 階         2 級         10           4
    6 階         3 級         15           6
    8 階         4 級         20           8
    9 階*        5 級*        25          10

*註: 9 階用 5 個 Biquad，其中一個設為 1 階:
     b₂=0, a₂=0 → 變成 1 階濾波器
```

**計算公式**:
```
奇數階數 N:
  級數 = ⌈N/2⌉ (向上取整)
  例: 9 階 → ⌈9/2⌉ = 5 級

偶數階數 N:
  級數 = N/2
  例: 8 階 → 8/2 = 4 級

係數總數 = 級數 × 5
狀態總數 = 級數 × 2
```

---

## 3. CMSIS-DSP Biquad 函數詳解

### 3.1 資料結構

```c
typedef struct {
    uint8_t numStages;       // Biquad 級數
    float32_t *pState;       // 狀態變數陣列
    float32_t *pCoeffs;      // 係數陣列
} arm_biquad_casd_df2T_instance_f32;
```

**記憶體佈局**:

```
實例 S:
┌────────────────────────────────────────┐
│ numStages = 3                          │
│ pState  ─────┐                         │
│ pCoeffs ───┐ │                         │
└────────────│─│─────────────────────────┘
             │ │
             │ └───> [狀態陣列]
             │       ┌─────┬─────┬─────┬─────┬─────┬─────┐
             │       │ d₁₁ │ d₂₁ │ d₁₂ │ d₂₂ │ d₁₃ │ d₂₃ │
             │       └─────┴─────┴─────┴─────┴─────┴─────┘
             │         級1         級2         級3
             │       (6 個元素 = 3 級 × 2 狀態)
             │
             └─────> [係數陣列]
                     ┌────┬────┬────┬────┬────┬────┬────┬──...
                     │ b₀₁│ b₁₁│ b₂₁│ a₁₁│ a₂₁│ b₀₂│ b₁₂│ ...
                     └────┴────┴────┴────┴────┴────┴────┴──...
                       級1 (5個係數)      級2 (5個係數) ...
                     (15 個元素 = 3 級 × 5 係數)
```

**係數排列順序（重要！）**:
```
對於每一級:
  [b₀, b₁, b₂, a₁, a₂]

  前饋係數 (3個): b₀, b₁, b₂
  回授係數 (2個): a₁, a₂

完整陣列 (3 級):
  [b₀₁, b₁₁, b₂₁, a₁₁, a₂₁,   ← 級 1
   b₀₂, b₁₂, b₂₂, a₁₂, a₂₂,   ← 級 2
   b₀₃, b₁₃, b₂₃, a₁₃, a₂₃]   ← 級 3
```

**狀態排列順序**:
```
對於每一級:
  [d₁, d₂]

完整陣列 (3 級):
  [d₁₁, d₂₁,   ← 級 1 的狀態
   d₁₂, d₂₂,   ← 級 2 的狀態
   d₁₃, d₂₃]   ← 級 3 的狀態
```

### 3.2 初始化函數

**函數原型**:
```c
void arm_biquad_cascade_df2T_init_f32(
    arm_biquad_casd_df2T_instance_f32 *S,  // Biquad 實例
    uint8_t numStages,                      // 級數
    float32_t *pCoeffs,                     // 係數陣列
    float32_t *pState                       // 狀態陣列
);
```

**內部動作**:
```c
void arm_biquad_cascade_df2T_init_f32(...) {
    // 1. 儲存參數
    S->numStages = numStages;
    S->pCoeffs = pCoeffs;
    S->pState = pState;

    // 2. 清空狀態緩衝區
    uint32_t stateSize = 2 * numStages;  // 每級 2 個狀態
    for(i = 0; i < stateSize; i++) {
        pState[i] = 0.0f;
    }
}
```

**使用範例**:
```c
// 2 級 Biquad (4 階濾波器)
#define NUM_STAGES 2

// 係數陣列 (2 級 × 5 係數 = 10 個元素)
float32_t biquadCoeffs[NUM_STAGES * 5] = {
    // 級 1: 低通 Biquad
    1.0f,  0.5f,  0.2f,  -0.8f,  0.3f,
    // 級 2: 高通 Biquad
    0.8f, -0.6f,  0.3f,  -0.9f,  0.4f
};

// 狀態陣列 (2 級 × 2 狀態 = 4 個元素)
float32_t biquadState[NUM_STAGES * 2];

// Biquad 實例
arm_biquad_casd_df2T_instance_f32 S;

// 初始化
arm_biquad_cascade_df2T_init_f32(&S, NUM_STAGES, biquadCoeffs, biquadState);
```

### 3.3 濾波函數

**函數原型**:
```c
void arm_biquad_cascade_df2T_f32(
    arm_biquad_casd_df2T_instance_f32 *S,  // Biquad 實例
    float32_t *pSrc,                        // 輸入資料
    float32_t *pDst,                        // 輸出資料
    uint32_t blockSize                      // 樣本數
);
```

**簡化版實作**:
```c
void arm_biquad_cascade_df2T_f32(
    arm_biquad_casd_df2T_instance_f32 *S,
    float32_t *pSrc,
    float32_t *pDst,
    uint32_t blockSize)
{
    float32_t *pState = S->pState;
    float32_t *pCoeffs = S->pCoeffs;
    float32_t *pIn = pSrc;
    float32_t *pOut = pDst;
    uint8_t stage = S->numStages;

    // ===== 對每一級進行處理 =====
    do {
        // 取得當前級的係數
        float32_t b0 = *pCoeffs++;
        float32_t b1 = *pCoeffs++;
        float32_t b2 = *pCoeffs++;
        float32_t a1 = *pCoeffs++;
        float32_t a2 = *pCoeffs++;

        // 取得當前級的狀態
        float32_t d1 = pState[0];
        float32_t d2 = pState[1];

        // ===== 處理整個區塊 =====
        uint32_t sample = blockSize;
        while(sample > 0) {
            float32_t Xn = *pIn++;   // 讀取輸入

            // Direct Form II Transposed
            float32_t Yn = b0 * Xn + d1;   // 計算輸出
            d1 = b1 * Xn + a1 * Yn + d2;   // 更新 d1
            d2 = b2 * Xn + a2 * Yn;        // 更新 d2

            *pOut++ = Yn;  // 寫入輸出
            sample--;
        }

        // 儲存當前級的新狀態
        pState[0] = d1;
        pState[1] = d2;
        pState += 2;

        // 下一級的輸入 = 這一級的輸出
        pIn = pDst;
        pOut = pDst;

    } while(--stage);
}
```

**執行流程視覺化**（2 級 Biquad，3 個樣本）:

```
輸入: [x[0], x[1], x[2]]

═══════ 級 1 處理 ═══════
x[0] → Biquad 1 → t[0]
x[1] → Biquad 1 → t[1]
x[2] → Biquad 1 → t[2]

中間結果: [t[0], t[1], t[2]]

═══════ 級 2 處理 ═══════
t[0] → Biquad 2 → y[0]
t[1] → Biquad 2 → y[1]
t[2] → Biquad 2 → y[2]

輸出: [y[0], y[1], y[2]]
```

### 3.4 單一樣本通過 2 級 Biquad 範例

假設係數：
```
級 1: b₀=1.0, b₁=0.5, b₂=0.2, a₁=-0.8, a₂=0.3
級 2: b₀=0.9, b₁=-0.4, b₂=0.1, a₁=-0.7, a₂=0.2
```

**處理 x[0] = 1.0**:

```
─────── 級 1 (初始: d₁=0, d₂=0) ───────
輸入: x[0] = 1.0

  y₁ = b₀×x[0] + d₁
     = 1.0×1.0 + 0
     = 1.0

  d₁ = b₁×x[0] + a₁×y₁ + d₂
     = 0.5×1.0 + (-0.8)×1.0 + 0
     = 0.5 - 0.8
     = -0.3

  d₂ = b₂×x[0] + a₂×y₁
     = 0.2×1.0 + 0.3×1.0
     = 0.5

級 1 輸出: t[0] = 1.0
級 1 新狀態: d₁=-0.3, d₂=0.5

─────── 級 2 (初始: d₁=0, d₂=0) ───────
輸入: t[0] = 1.0 (來自級 1)

  y₂ = b₀×t[0] + d₁
     = 0.9×1.0 + 0
     = 0.9

  d₁ = b₁×t[0] + a₁×y₂ + d₂
     = (-0.4)×1.0 + (-0.7)×0.9 + 0
     = -0.4 - 0.63
     = -1.03

  d₂ = b₂×t[0] + a₂×y₂
     = 0.1×1.0 + 0.2×0.9
     = 0.1 + 0.18
     = 0.28

級 2 輸出: y[0] = 0.9
級 2 新狀態: d₁=-1.03, d₂=0.28

═══════════════════════════════════════
最終輸出: y[0] = 0.9
```

### 3.5 效能分析

**每個樣本的運算量（單一 Biquad）**:
```
乘法: 5 次 (b₀, b₁, b₂, a₁, a₂)
加法: 4 次 (3 次加法 + 1 次減法視為加法)
總計: 9 次浮點運算

N 級 Biquad:
  乘法: 5N 次
  加法: 4N 次
  總計: 9N 次浮點運算
```

**與 FIR 比較**（相同濾波效果）:

```
FIR 低通濾波器 (29 點):
  乘法: 29 次
  加法: 28 次
  總計: 57 次運算

IIR Biquad (2 級):
  乘法: 5×2 = 10 次
  加法: 4×2 = 8 次
  總計: 18 次運算

省下: (57-18)/57 = 68% 運算量！
```

**記憶體比較**:

```
FIR (29 點):
  係數: 29 × 4 bytes = 116 bytes
  狀態: 60 × 4 bytes = 240 bytes
  總計: 356 bytes

IIR (2 級 Biquad):
  係數: 10 × 4 bytes = 40 bytes
  狀態: 4 × 4 bytes = 16 bytes
  總計: 56 bytes

省下: (356-56)/356 = 84% 記憶體！
```

---

## 4. 穩定性問題

### 4.1 為什麼 IIR 可能不穩定？

**回授放大效應**：

想像一個**麥克風對著喇叭**：

```
正常情況（穩定）:
  麥克風收音 → 放大 0.8 倍 → 喇叭播放 → 麥克風收音 → ...

  第 1 次: 音量 1.0
  第 2 次: 音量 1.0 × 0.8 = 0.8
  第 3 次: 音量 0.8 × 0.8 = 0.64
  第 4 次: 音量 0.64 × 0.8 = 0.51
  ...
  (逐漸衰減 → 穩定) ✓

異常情況（不穩定）:
  麥克風收音 → 放大 1.2 倍 → 喇叭播放 → 麥克風收音 → ...

  第 1 次: 音量 1.0
  第 2 次: 音量 1.0 × 1.2 = 1.2
  第 3 次: 音量 1.2 × 1.2 = 1.44
  第 4 次: 音量 1.44 × 1.2 = 1.73
  ...
  (指數成長 → 尖叫聲！) ✗

IIR 濾波器也一樣:
  • 回授係數太大 → 不穩定
  • 回授係數適中 → 穩定
```

### 4.2 數學判斷：極點位置

**Z 平面上的極點分析**:

```
Z 平面 (複數平面):
        虛軸 (Im)
           ↑
           │
           │    ╱─────╲
           │   ╱   1   ╲    ← 單位圓 (|z|=1)
           │  │    ●    │
    ───────┼──┼────●────┼────> 實軸 (Re)
          -1  │    ●    │  1
           │   ╲       ╱
           │    ╲─────╱
           │

極點 (poles) = 轉移函數 H(z) 分母的根

穩定性判斷:
  ✓ 所有極點在單位圓內 (|z| < 1) → 穩定
  ✗ 有極點在單位圓上 (|z| = 1) → 臨界穩定
  ✗ 有極點在單位圓外 (|z| > 1) → 不穩定
```

**範例**：

```
Biquad 轉移函數:
         b₀ + b₁z⁻¹ + b₂z⁻²
H(z) = ─────────────────────
         1 + a₁z⁻¹ + a₂z⁻²

分母 = 1 + a₁z⁻¹ + a₂z⁻² = 0
     → z² + a₁z + a₂ = 0 (兩個極點)

穩定條件 (Jury test):
  |a₂| < 1
  |a₁| < 1 + a₂

如果滿足 → 保證極點在單位圓內 → 穩定 ✓
```

**實際例子**:

```
情況 1: a₁=-0.8, a₂=0.3
  檢查: |0.3| = 0.3 < 1 ✓
        |-0.8| = 0.8 < 1+0.3 = 1.3 ✓
  結論: 穩定 ✓

情況 2: a₁=-0.8, a₂=1.2
  檢查: |1.2| = 1.2 > 1 ✗
  結論: 不穩定 ✗

情況 3: a₁=-2.0, a₂=0.3
  檢查: |0.3| = 0.3 < 1 ✓
        |-2.0| = 2.0 > 1+0.3 = 1.3 ✗
  結論: 不穩定 ✗
```

### 4.3 確保穩定性的方法

**方法 1：使用經過驗證的設計工具**

```matlab
% MATLAB Signal Processing Toolbox
% 自動確保穩定性

% 設計 4 階 Butterworth 低通濾波器
[z, p, k] = butter(4, 0.2);  % 0.2 = 正規化頻率
[sos, g] = zp2sos(z, p, k);  % 轉成 Biquad 級聯

% sos = Second-Order Sections (Biquad 係數)
% MATLAB 保證所有極點在單位圓內！
```

**方法 2：使用 Biquad 級聯而非高階直接型**

```
為什麼 Biquad 更穩定？

高階直接型 (8 階):
  H(z) = N(z) / D(z)
  D(z) = 1 + a₁z⁻¹ + ... + a₈z⁻⁸

  問題:
    • 係數微小變化 → 極點位置大幅改變
    • 量化誤差 → 可能變不穩定
    • 8 個極點同時處理 → 難以控制

Biquad 級聯 (4 級):
  H(z) = H₁(z) × H₂(z) × H₃(z) × H₄(z)

  優點:
    • 每級只有 2 個極點 → 容易控制
    • 係數敏感度低
    • 一級不穩定不會影響其他級
    • 可以分別驗證每一級
```

**方法 3：係數量化檢查**

```c
// 在嵌入式系統中，檢查係數是否滿足穩定條件
bool check_biquad_stability(float a1, float a2) {
    // Jury 穩定性判斷
    if (fabs(a2) >= 1.0f) {
        return false;  // 不穩定
    }
    if (fabs(a1) >= (1.0f + a2)) {
        return false;  // 不穩定
    }
    return true;  // 穩定
}

// 使用範例
float a1 = -0.8f;
float a2 = 0.3f;

if (!check_biquad_stability(a1, a2)) {
    print_uart0("警告: Biquad 係數不穩定！\n");
}
```

**方法 4：狀態變數飽和檢查**

```c
// 避免狀態變數溢位
void saturate_states(float32_t *pState, uint32_t numStates) {
    const float32_t MAX_STATE = 1e6f;  // 設定上限

    for(uint32_t i = 0; i < numStates; i++) {
        if (pState[i] > MAX_STATE) {
            pState[i] = MAX_STATE;
        } else if (pState[i] < -MAX_STATE) {
            pState[i] = -MAX_STATE;
        }
    }
}
```

---

## 5. FIR vs IIR 完整比較

### 5.1 特性比較表

| 特性 | FIR | IIR | 說明 |
|------|-----|-----|------|
| **穩定性** | ✅ 絕對穩定 | ⚠️ 需檢查極點 | FIR 無回授 → 無條件穩定 |
| **線性相位** | ✅ 容易達成 | ❌ 幾乎不可能 | 對稱係數 → 線性相位 |
| **係數數量** | ❌ 多 (29+) | ✅ 少 (10~20) | 同樣效果，IIR 需要少很多係數 |
| **記憶體** | ❌ 大 (356 bytes) | ✅ 小 (56 bytes) | IIR 省 ~84% |
| **運算量** | ❌ 大 (57 ops) | ✅ 小 (18 ops) | IIR 省 ~68% |
| **功耗** | ❌ 高 | ✅ 低 | 運算少 → 功耗低 |
| **設計難度** | ✅ 簡單 | ⚠️ 複雜 | MATLAB fir1() vs butter() + zp2sos() |
| **量化敏感度** | ✅ 低 | ⚠️ 高 | 係數誤差對 IIR 影響大 |
| **群延遲** | ✅ 常數 | ❌ 頻率相關 | FIR 所有頻率延遲相同 |
| **暫態響應** | ✅ 有限 | ⚠️ 理論無限 | FIR: N 個樣本後結束 |
| **脈衝響應** | 有限 | 無限 (逐漸衰減) | 定義上的差異 |

### 5.2 應用場景選擇

**選擇 FIR 的場景**:

```
✅ 音訊處理
   理由: 需要線性相位避免相位失真
   例: MP3 編碼器、音訊混音器、等化器

✅ 影像處理
   理由: 需要線性相位保持影像細節
   例: 影像銳化、邊緣偵測、降噪

✅ 通訊系統
   理由: 需要精確的脈衝響應控制
   例: 匹配濾波器、基頻成形濾波器

✅ 醫療設備
   理由: 穩定性要求極高，不容許任何不穩定風險
   例: 心電圖濾波、腦波分析

✅ 安全關鍵系統
   理由: 絕對穩定性
   例: 航空電子、核電廠控制
```

**選擇 IIR 的場景**:

```
✅ 低功耗穿戴裝置
   理由: 電池續航優先，可接受非線性相位
   例: 智慧手環心率監測、計步器

✅ 記憶體受限系統
   理由: SRAM 只有幾 KB
   例: 8-bit 微控制器、物聯網感測器

✅ 即時控制系統
   理由: 運算量小，延遲低
   例: 馬達控制、溫度控制、PID 控制器

✅ 功率譜分析
   理由: 只關心振幅，不在乎相位
   例: 頻譜分析儀、能量偵測器

✅ 音效合成
   理由: 需要諧振效果（高 Q 值濾波器）
   例: 合成器、音效插件、迴音效果
```

### 5.3 實際數據比較（低通濾波器）

**設計目標**: 48 kHz 取樣，6 kHz 截止，-40 dB 阻帶衰減

```
═══════════════════════════════════════════════════════
          FIR                 IIR (Butterworth)
───────────────────────────────────────────────────────
階數      29 階               4 階 (2 級 Biquad)
係數      29 個               10 個 (2×5)
狀態      60 個               4 個 (2×2)
記憶體    356 bytes           56 bytes
運算/樣本  57 ops              18 ops
群延遲    14 樣本 (恆定)       頻率相關 (~3-5 樣本)
穩定性    絕對穩定            需檢查 (但通常穩定)
相位      線性                非線性
設計      fir1(28, 0.25)      butter(4, 0.25)
───────────────────────────────────────────────────────
```

**頻率響應比較**:

```
頻率      FIR 增益   FIR 相位    IIR 增益   IIR 相位
0 Hz      1.0        0°          1.0        0°
1 kHz     1.0        -105°       1.0        -15°
3 kHz     1.0        -315°       1.0        -45°
6 kHz     0.5        -630°       0.707      -90°
10 kHz    0.1        -1050°      0.2        -150°
15 kHz    0.01       -1575°      0.05       -225°
───────────────────────────────────────────────────────
觀察:
  • 增益響應類似
  • FIR 相位線性 (斜率固定)
  • IIR 相位非線性 (頻率越高變化越大)
```

---

## 6. 設計 IIR 濾波器（使用 MATLAB）

### 6.1 Butterworth 低通濾波器

```matlab
%% 設計參數
fs = 48000;          % 取樣頻率 (Hz)
fc = 6000;           % 截止頻率 (Hz)
order = 4;           % 濾波器階數

%% 設計濾波器
fc_norm = fc / (fs/2);  % 正規化頻率 (0.25)

% 方法 1: 使用 butter (返回極零點)
[z, p, k] = butter(order, fc_norm);

% 轉換成 Biquad 級聯形式
[sos, g] = zp2sos(z, p, k);

%% sos 矩陣格式:
% 每一行 = [b0, b1, b2, a0, a1, a2]
% a0 總是 1，所以實際係數是 [b0, b1, b2, a1, a2]

%% 顯示係數 (C 語言格式)
fprintf('// %d 階 Butterworth, fc = %d Hz\n', order, fc);
fprintf('float32_t biquadCoeffs[%d] = {\n', size(sos,1)*5);

for stage = 1:size(sos,1)
    fprintf('  // 級 %d\n', stage);
    fprintf('  %.10ff, %.10ff, %.10ff, %.10ff, %.10ff', ...
            sos(stage,1), sos(stage,2), sos(stage,3), ...
            -sos(stage,5), -sos(stage,6));  % 注意負號！
    if stage < size(sos,1)
        fprintf(',\n');
    else
        fprintf('\n');
    end
end
fprintf('};\n');

%% 為什麼係數要加負號？
% MATLAB: y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2]
%               - a1*y[n-1] - a2*y[n-2]  (負號)
%
% CMSIS:  y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2]
%               + a1*y[n-1] + a2*y[n-2]  (正號)
%
% 因此: CMSIS_a1 = -MATLAB_a1
%       CMSIS_a2 = -MATLAB_a2
```

### 6.2 檢查穩定性

```matlab
%% 繪製極零圖
figure;
zplane(z, p);
title('極零圖 (Pole-Zero Plot)');
grid on;

%% 檢查所有極點是否在單位圓內
pole_magnitudes = abs(p);
if all(pole_magnitudes < 1)
    fprintf('✓ 所有極點在單位圓內 → 穩定\n');
else
    fprintf('✗ 有極點在單位圓外 → 不穩定！\n');
end

%% 顯示極點位置
for i = 1:length(p)
    fprintf('極點 %d: %.4f %+.4fi, 模 = %.4f\n', ...
            i, real(p(i)), imag(p(i)), abs(p(i)));
end
```

### 6.3 視覺化頻率響應

```matlab
%% 繪製頻率響應
figure;
freqz(sos, 2048, fs);

% 或使用 fvtool (濾波器視覺化工具)
fvtool(sos, 'Fs', fs);
```

---

## 7. 實作練習

### 7.1 練習 1：手動計算 Biquad

**目標**：手動計算單一 Biquad 處理 3 個樣本

**給定**:
```
係數: b₀=1.0, b₁=0.5, b₂=0.2, a₁=-0.8, a₂=0.3
輸入: x = [1.0, 0.5, 0.0]
初始狀態: d₁=0, d₂=0
```

**步驟**:

1. **計算 y[0]**:
```
y[0] = b₀×x[0] + d₁ = 1.0×1.0 + 0 = 1.0
d₁ = b₁×x[0] + a₁×y[0] + d₂ = 0.5×1.0 + (-0.8)×1.0 + 0 = -0.3
d₂ = b₂×x[0] + a₂×y[0] = 0.2×1.0 + 0.3×1.0 = 0.5

新狀態: d₁=-0.3, d₂=0.5
```

2. **計算 y[1]**:
```
y[1] = b₀×x[1] + d₁ = 1.0×0.5 + (-0.3) = 0.2
d₁ = b₁×x[1] + a₁×y[1] + d₂ = 0.5×0.5 + (-0.8)×0.2 + 0.5 = 0.59
d₂ = b₂×x[1] + a₂×y[1] = 0.2×0.5 + 0.3×0.2 = 0.16

新狀態: d₁=0.59, d₂=0.16
```

3. **計算 y[2]**:
```
y[2] = b₀×x[2] + d₁ = 1.0×0.0 + 0.59 = 0.59
d₁ = b₁×x[2] + a₁×y[2] + d₂ = 0.5×0.0 + (-0.8)×0.59 + 0.16 = -0.312
d₂ = b₂×x[2] + a₂×y[2] = 0.2×0.0 + 0.3×0.59 = 0.177

新狀態: d₁=-0.312, d₂=0.177
```

**答案**: `y = [1.0, 0.2, 0.59]`

### 7.2 練習 2：穩定性判斷

判斷以下 Biquad 係數是否穩定：

```
情況 A: a₁ = -1.5, a₂ = 0.7
  |a₂| = 0.7 < 1 ✓
  |a₁| = 1.5 vs (1 + a₂) = 1.7
  1.5 < 1.7 ✓
  結論: 穩定

情況 B: a₁ = -0.5, a₂ = 1.1
  |a₂| = 1.1 > 1 ✗
  結論: 不穩定

情況 C: a₁ = -2.5, a₂ = 0.4
  |a₂| = 0.4 < 1 ✓
  |a₁| = 2.5 vs (1 + a₂) = 1.4
  2.5 > 1.4 ✗
  結論: 不穩定
```

### 7.3 練習 3：使用 MATLAB 設計濾波器

**任務**: 設計 6 階 Chebyshev Type I 低通濾波器

```matlab
%% 參數
fs = 48000;
fc = 8000;
ripple = 0.5;  % 通帶漣波 (dB)

%% 設計
fc_norm = fc / (fs/2);
[z, p, k] = cheby1(6, ripple, fc_norm);
[sos, g] = zp2sos(z, p, k);

%% 驗證穩定性
if all(abs(p) < 1)
    disp('穩定');
else
    disp('不穩定');
end

%% 顯示級數
fprintf('需要 %d 級 Biquad\n', size(sos, 1));
```

---

## 8. 常見問題與陷阱

### 8.1 係數符號錯誤

**問題**: MATLAB 與 CMSIS-DSP 的符號慣例不同

```
MATLAB:
  y[n] = b0*x[n] + ... - a1*y[n-1] - a2*y[n-2]  (負號)

CMSIS-DSP:
  y[n] = b0*x[n] + ... + a1*y[n-1] + a2*y[n-2]  (正號)

解決:
  從 MATLAB 複製係數時，a1 和 a2 要加負號！

  MATLAB:     [b0, b1, b2, 1, a1, a2]
  CMSIS-DSP:  [b0, b1, b2, -a1, -a2]  ← 注意這裡
```

### 8.2 狀態變數溢位

**問題**: 回授可能導致狀態變數越來越大

```c
// 檢查狀態變數是否異常
void check_biquad_overflow(arm_biquad_casd_df2T_instance_f32 *S) {
    float32_t *pState = S->pState;
    uint32_t numStates = 2 * S->numStages;

    for(uint32_t i = 0; i < numStates; i++) {
        if (fabs(pState[i]) > 1e6f) {
            print_uart0("警告: 狀態變數溢位！\n");
            pState[i] = 0.0f;  // 重置
        }
    }
}
```

### 8.3 量化誤差累積

**問題**: 定點運算時，誤差會累積

```
浮點 (float32_t):
  精度: ~7 位有效數字
  範圍: ±3.4 × 10³⁸
  → 通常足夠

定點 Q15 (int16_t):
  範圍: -1.0 ~ +0.9999
  精度: 1/32768 ≈ 0.00003
  → 可能不夠！

建議:
  • Cortex-M3 無 FPU → 使用 Q31 (int32_t)
  • Cortex-M4F 有 FPU → 使用 float32_t
```

---

## 🎯 學習檢查點

完成本模組後，你應該能夠：

### 理論理解
- [ ] 解釋什麼是「無限脈衝響應」
- [ ] 說明 IIR 的回授機制
- [ ] 理解為什麼 IIR 可能不穩定
- [ ] 知道如何判斷穩定性（極點位置）
- [ ] 比較 FIR 與 IIR 的優缺點

### Biquad 結構
- [ ] 理解為什麼使用 Biquad 級聯
- [ ] 知道 Direct Form II Transposed 結構
- [ ] 會計算需要幾級 Biquad
- [ ] 理解係數排列順序

### CMSIS-DSP 使用
- [ ] 會使用 `arm_biquad_cascade_df2T_init_f32()`
- [ ] 會使用 `arm_biquad_cascade_df2T_f32()`
- [ ] 理解狀態緩衝區大小 (2 × numStages)
- [ ] 理解係數陣列大小 (5 × numStages)

### 實作能力
- [ ] 能夠手動計算 Biquad 輸出
- [ ] 會檢查係數穩定性
- [ ] 會使用 MATLAB 設計 IIR 濾波器
- [ ] 會轉換 MATLAB 係數到 CMSIS-DSP 格式

### 應用判斷
- [ ] 知道何時選擇 FIR
- [ ] 知道何時選擇 IIR
- [ ] 能夠估算記憶體與運算量
- [ ] 會權衡穩定性與效能

---

## 🔗 下一步

恭喜你完成 IIR 濾波器的學習！

**接下來**:
- [模組 09：Docker 容器技術](09-Docker容器技術.md) - 建立開發環境
- [模組 12：CMSIS-DSP 函式庫](12-CMSIS-DSP函式庫.md) - 探索更多 DSP 函數

**進階主題**:
- 其他 IIR 類型（Chebyshev, Elliptic）
- 自適應濾波器
- 多速率訊號處理
- 格型濾波器 (Lattice Filter)

**實戰應用**:
- 心率變異性分析 (HRV)
- 音訊等化器
- 主動降噪 (ANC)
- 數位振盪器

---

**版本**: 2.0 | **日期**: 2025-11-16 | **作者**: Claude Code Teaching Assistant
