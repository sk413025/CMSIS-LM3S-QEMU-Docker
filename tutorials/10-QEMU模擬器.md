# 模組 10：QEMU 模擬器

> 使用 QEMU 模擬 ARM 硬體環境，無需實體開發板即可開發與測試

**對應專案檔案**:
- [`run-examples.sh`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/run-examples.sh) - 自動化執行腳本
- [`uart_hello_world.ld`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/uart_hello_world.ld) - 記憶體配置檔

**閱讀時間**: 約 40 分鐘
**難度**: ⭐⭐☆☆☆ (中等)

---

## 📌 學習目標

完成本模組後，你將能夠：
- ✅ 理解硬體模擬的原理與優勢
- ✅ 學會使用 QEMU 模擬 ARM Cortex-M3 處理器
- ✅ 掌握 QEMU 的各種參數與使用方式
- ✅ 模擬 LM3S6965EVB 開發板環境
- ✅ 理解 QEMU 與 GDB 的整合除錯
- ✅ 解讀記憶體配置與 QEMU 的映射關係
- ✅ 使用 QEMU Monitor 進行系統診斷

---

## 開始之前：為什麼需要 QEMU？

想像你正在**開發一個新型智慧手錶的韌體**：

### 傳統做法的困境

```
┌─────────────────────────────────────────┐
│ 沒有 QEMU 的傳統嵌入式開發流程           │
├─────────────────────────────────────────┤
│                                          │
│ Step 1: 撰寫程式碼                       │
│   ↓                                      │
│ Step 2: 編譯成二進位檔 (5 秒)           │
│   ↓                                      │
│ Step 3: 透過 JTAG/SWD 燒錄到開發板 (20秒)│
│   ↓                                      │
│ Step 4: 重置開發板 (3 秒)               │
│   ↓                                      │
│ Step 5: 觀察結果... 發現 Bug！           │
│   ↓                                      │
│ Step 6: 修改程式碼                       │
│   ↓                                      │
│ (重複 Step 1-6... 一天 100 次)          │
│                                          │
│ 時間成本: 每次測試 ~30 秒               │
│ 一天 100 次 = 50 分鐘浪費在燒錄等待！    │
│                                          │
│ 其他問題:                                │
│   ❌ 需要購買開發板 (NT$ 1,500+)         │
│   ❌ 實體連接線容易接觸不良              │
│   ❌ 開發板可能因錯誤程式碼損壞          │
│   ❌ 多人開發時開發板數量不足            │
│   ❌ CI/CD 無法自動化測試                │
│   ❌ 學生需自費購買才能練習              │
└─────────────────────────────────────────┘
```

### QEMU 解決方案

```
┌─────────────────────────────────────────┐
│ 使用 QEMU 的現代開發流程                 │
├─────────────────────────────────────────┤
│                                          │
│ Step 1: 撰寫程式碼                       │
│   ↓                                      │
│ Step 2: 編譯成二進位檔 (5 秒)           │
│   ↓                                      │
│ Step 3: qemu-system-arm 直接執行 (1 秒) │
│   ↓                                      │
│ Step 4: 立即看到結果！                   │
│   ↓                                      │
│ (發現 Bug → 修改 → 重新編譯 → 執行)     │
│                                          │
│ 時間成本: 每次測試 ~6 秒                │
│ 一天 100 次 = 10 分鐘                    │
│ 省下 40 分鐘！效率提升 80%！             │
│                                          │
│ 其他優勢:                                │
│   ✓ 完全免費，無硬體成本                 │
│   ✓ 軟體模擬，永遠不會損壞               │
│   ✓ 可同時執行多個模擬實例               │
│   ✓ 容易整合到 CI/CD 自動化測試          │
│   ✓ 學生在家也能練習                     │
│   ✓ 快照/還原功能，方便重現 Bug          │
└─────────────────────────────────────────┘
```

### 真實案例：學生實驗課

> **情境**: 一門嵌入式系統課程有 40 位學生
>
> **方案 A (購買實體開發板)**:
> - 成本: 40 片 × NT$ 1,500 = **NT$ 60,000**
> - 問題: 學生借用歸還、損壞維修、版本不一致
>
> **方案 B (使用 QEMU)**:
> - 成本: **NT$ 0** (完全免費)
> - 好處: 每位學生在自己電腦上執行，環境完全一致
> - 省下: **NT$ 60,000** + 無數管理時間

**這就是為什麼我們需要 QEMU！**

---

## 1. QEMU 是什麼？

### 名稱由來

**QEMU** = **Q**uick **EMU**lator (快速模擬器)

> 發音: "KEW-mew" 或 "KEW-em-you"

### 核心概念

QEMU 是一個**開源的硬體虛擬化軟體**，可以：

1. **模擬完整的電腦系統** (CPU、記憶體、周邊裝置)
2. **支援多種 CPU 架構** (x86, ARM, RISC-V, MIPS...)
3. **執行為該架構編譯的程式**

### 生活類比：飛行模擬器

想像你想學開飛機：

```
┌──────────────────────────────────┐
│ 真實飛機 (實體開發板)            │
├──────────────────────────────────┤
│ • 租用成本: NT$ 100,000/小時     │
│ • 風險: 墜機可能喪命             │
│ • 練習次數: 有限                 │
│ • 環境限制: 需要好天氣           │
└──────────────────────────────────┘

┌──────────────────────────────────┐
│ 飛行模擬器 (QEMU)                │
├──────────────────────────────────┤
│ • 成本: NT$ 0                    │
│ • 風險: 完全安全，隨意嘗試       │
│ • 練習次數: 無限                 │
│ • 環境: 可模擬暴風雨、引擎故障   │
│ • 還原: 隨時重新開始             │
└──────────────────────────────────┘
```

**QEMU 就像「嵌入式系統的飛行模擬器」**：
- ✅ 讓你在安全的環境中練習
- ✅ 可以故意製造各種錯誤情境來學習
- ✅ 不用擔心損壞昂貴的硬體

### QEMU 的兩種模式

QEMU 有兩種主要運作模式：

```
┌──────────────────────────────────────────┐
│ 1. User Mode (使用者模式)                 │
├──────────────────────────────────────────┤
│ 用途: 執行單一程式                        │
│                                           │
│ 範例: qemu-arm my_program                │
│                                           │
│ 適合: Linux 應用程式的跨平台測試          │
└──────────────────────────────────────────┘

┌──────────────────────────────────────────┐
│ 2. System Mode (系統模式) ← 我們使用這個 │
├──────────────────────────────────────────┤
│ 用途: 模擬完整的硬體系統                  │
│                                           │
│ 範例: qemu-system-arm -M lm3s6965evb ... │
│                                           │
│ 適合: 嵌入式系統韌體開發                  │
│       (模擬整個開發板，包含所有周邊)      │
└──────────────────────────────────────────┘
```

**我們使用 `qemu-system-arm`**，因為我們要模擬完整的 ARM 開發板！

---

## 2. QEMU 架構深度解析

### 整體架構圖

```
┌─────────────────────────────────────────────────────────┐
│ 你的電腦 (Host System - Linux x86_64)                   │
│                                                          │
│  ┌────────────────────────────────────────────────────┐ │
│  │ 你的程式 uart_hello_world.bin (ARM 機器碼)        │ │
│  │   • 專為 ARM Cortex-M3 編譯的二進位檔              │ │
│  │   • x86_64 CPU 無法直接執行！                      │ │
│  └────────────────┬───────────────────────────────────┘ │
│                   │ 載入                                 │
│                   ↓                                      │
│  ┌────────────────────────────────────────────────────┐ │
│  │ QEMU-system-arm                                    │ │
│  │ (在 x86_64 上模擬 ARM 硬體)                        │ │
│  │                                                    │ │
│  │  ┌──────────────────────────────────────────────┐ │ │
│  │  │ CPU 模擬層 (Dynamic Binary Translation)     │ │ │
│  │  │                                              │ │ │
│  │  │  ARM 指令 → x86_64 指令的即時翻譯            │ │ │
│  │  │                                              │ │ │
│  │  │  範例:                                       │ │ │
│  │  │  ARM:     MOVS R0, #0x41  (移動 'A' 到 R0)  │ │ │
│  │  │  翻譯為→  x86:  mov eax, 0x41               │ │ │
│  │  │                                              │ │ │
│  │  │  🔄 JIT (Just-In-Time) 編譯加速:            │ │ │
│  │  │     第一次執行: 翻譯並快取                   │ │ │
│  │  │     後續執行: 直接使用快取，速度快！         │ │ │
│  │  └──────────────────────────────────────────────┘ │ │
│  │                                                    │ │
│  │  ┌──────────────────────────────────────────────┐ │ │
│  │  │ ARM Cortex-M3 CPU 狀態                       │ │ │
│  │  │                                              │ │ │
│  │  │  通用暫存器 (16 個):                         │ │ │
│  │  │    R0  = 0x00000000                         │ │ │
│  │  │    R1  = 0x00000000                         │ │ │
│  │  │    ...                                      │ │ │
│  │  │    R13 (SP - Stack Pointer) = 0x20010000    │ │ │
│  │  │    R14 (LR - Link Register)                 │ │ │
│  │  │    R15 (PC - Program Counter) = 0x000001A4  │ │ │
│  │  │                                              │ │ │
│  │  │  狀態暫存器:                                 │ │ │
│  │  │    APSR (Flags: N Z C V)                    │ │ │
│  │  │    PRIMASK, FAULTMASK, CONTROL...           │ │ │
│  │  └──────────────────────────────────────────────┘ │ │
│  │                                                    │ │
│  │  ┌──────────────────────────────────────────────┐ │ │
│  │  │ 記憶體模擬 (Virtual Memory)                  │ │ │
│  │  │                                              │ │ │
│  │  │  0x00000000 ┌─────────────────────────────┐ │ │ │
│  │  │             │ FLASH (256 KB)              │ │ │ │
│  │  │             │  • 程式碼 (.text)           │ │ │ │
│  │  │             │  • 常數資料 (.rodata)       │ │ │ │
│  │  │             │  • 中斷向量表               │ │ │ │
│  │  │  0x00040000 └─────────────────────────────┘ │ │ │
│  │  │                                              │ │ │
│  │  │  0x20000000 ┌─────────────────────────────┐ │ │ │
│  │  │             │ SRAM (64 KB)                │ │ │ │
│  │  │             │  • 全域變數 (.data)         │ │ │ │
│  │  │             │  • 未初始化變數 (.bss)      │ │ │ │
│  │  │             │  • Stack (堆疊)             │ │ │ │
│  │  │             │  • Heap (動態記憶體)        │ │ │ │
│  │  │  0x20010000 └─────────────────────────────┘ │ │ │
│  │  │                                              │ │ │
│  │  │  0x40000000 ┌─────────────────────────────┐ │ │ │
│  │  │             │ 周邊暫存器 (Peripherals)    │ │ │ │
│  │  │             │  • UART0: 0x4000C000        │ │ │ │
│  │  │             │  • GPIO:  0x40004000        │ │ │ │
│  │  │             │  • Timer: 0x40030000        │ │ │ │
│  │  │  0xE0000000 └─────────────────────────────┘ │ │ │
│  │  │             ┌─────────────────────────────┐ │ │ │
│  │  │             │ ARM 系統周邊                │ │ │ │
│  │  │             │  • NVIC (中斷控制器)        │ │ │ │
│  │  │             │  • SysTick Timer            │ │ │ │
│  │  │  0xE0100000 └─────────────────────────────┘ │ │ │
│  │  │                                              │ │ │
│  │  │  實作: 使用 Host 的 RAM 模擬這些記憶體區域  │ │ │
│  │  └──────────────────────────────────────────────┘ │ │
│  │                                                    │ │
│  │  ┌──────────────────────────────────────────────┐ │ │
│  │  │ 周邊裝置模擬                                 │ │ │
│  │  │                                              │ │ │
│  │  │  UART (串列埠):                              │ │ │
│  │  │    當程式寫入 UART0->DR (0x4000C000)         │ │ │
│  │  │    ↓                                         │ │ │
│  │  │    QEMU 攔截這個寫入                         │ │ │
│  │  │    ↓                                         │ │ │
│  │  │    輸出字元到 Host 的終端機                  │ │ │
│  │  │                                              │ │ │
│  │  │    範例: UART0->DR = 'H'                    │ │ │
│  │  │           → 你的終端機顯示: H               │ │ │
│  │  │                                              │ │ │
│  │  │  Timer (計時器):                             │ │ │
│  │  │    使用 Host 的時鐘模擬                      │ │ │
│  │  │    每 N 微秒產生中斷                         │ │ │
│  │  │                                              │ │ │
│  │  │  GPIO (數位 I/O):                            │ │ │
│  │  │    基本實作（某些模擬可能簡化）              │ │ │
│  │  └──────────────────────────────────────────────┘ │ │
│  │                                                    │ │
│  │  ┌──────────────────────────────────────────────┐ │ │
│  │  │ GDB Server (選用)                            │ │ │
│  │  │                                              │ │ │
│  │  │  TCP Port 1234                              │ │ │
│  │  │    ↕ (GDB Remote Serial Protocol)           │ │ │
│  │  │  GDB Client (在另一個終端)                  │ │ │
│  │  │                                              │ │ │
│  │  │  功能:                                       │ │ │
│  │  │    • 設定中斷點                              │ │ │
│  │  │    • 單步執行                                │ │ │
│  │  │    • 檢查記憶體/暫存器                       │ │ │
│  │  └──────────────────────────────────────────────┘ │ │
│  └────────────────────────────────────────────────────┘ │
│                   ↓ 輸出                               │
│  ┌────────────────────────────────────────────────────┐ │
│  │ 你的終端機                                         │ │
│  │                                                    │ │
│  │ $ qemu-system-arm -M lm3s6965evb ...              │ │
│  │ Hello, UART World!                                │ │
│  │ Counter: 1                                        │ │
│  │ Counter: 2                                        │ │
│  └────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

**📖 圖示術語完全解析**

上面的架構圖包含許多專業術語，讓我們逐一解釋每一個：

#### 最外層：Host System (主機系統)

**Host System** = **主機系統** = **宿主系統**
- **定義**: 執行 QEMU 軟體的實體電腦
- **本例**: 你的 Linux x86_64 電腦
- **比喻**: 就像「劇場的舞台」，在上面搭建虛擬的「戲劇場景」

**x86_64** = **64 位元 x86 架構**
- **x86**: Intel/AMD 處理器使用的指令集架構
- **64**: 代表 64 位元 (可以處理最大 2^64 bytes 的記憶體位址)
- **為什麼重要**: ARM 和 x86_64 是完全不同的指令集，無法直接相互執行對方的程式
- **比喻**: x86_64 是「英文」，ARM 是「中文」，需要「翻譯」

#### 第二層：二進位檔案

**uart_hello_world.bin** = **二進位執行檔**
- **.bin**: Binary (二進位) 檔案
- **內容**: 純粹的機器碼 (0 和 1 的組合)
- **特點**: 沒有檔案頭、沒有除錯資訊，只有原始指令

**ARM 機器碼** = **ARM 處理器的機器指令**
- **機器碼**: CPU 可以直接執行的二進位指令
- **ARM Cortex-M3**: 這個檔案專門為 ARM Cortex-M3 處理器編譯
- **問題**: x86_64 CPU 看到這些指令會「完全看不懂」！

#### 第三層：QEMU-system-arm

**QEMU-system-arm** = **QEMU 的 ARM 系統模式模擬器**
- **拆解**: QEMU + system + arm
  - **QEMU**: 模擬器軟體名稱
  - **system**: 系統模式 (模擬完整硬體系統)
  - **arm**: 模擬 ARM 架構
- **作用**: 在 x86_64 上「假裝」有一台 ARM 電腦

#### CPU 模擬層 - Dynamic Binary Translation (動態二進位轉譯)

**Dynamic** = **動態的**
- **意思**: 在「執行時」(runtime) 進行，不是事先做好
- **對比**: Static (靜態) = 事先做好

**Binary** = **二進位**
- **指**: 機器碼 (binary code)，CPU 執行的 0101...

**Translation** = **翻譯**
- **翻譯內容**: ARM 指令 → x86_64 指令
- **目的**: 讓 x86_64 CPU 能執行 ARM 程式

**Dynamic Binary Translation (DBT)** = **動態二進位轉譯**
- **完整定義**: 在程式執行的過程中，即時將一種 CPU 的機器碼翻譯成另一種 CPU 的機器碼
- **類比**: 就像即席口譯，演講者說一句，口譯員立刻翻譯一句

**範例指令解析**:

```
ARM:     MOVS R0, #0x41  (移動 'A' 到 R0)
```
- **MOVS**: Move with Status update (移動並更新狀態旗標)
- **R0**: ARM 的第 0 號暫存器 (Register 0)
- **#0x41**: 立即值 (immediate value) 0x41 = 十進位 65 = ASCII 字元 'A'
- **作用**: 將數值 65 放入 R0 暫存器

```
翻譯為→  x86:  mov eax, 0x41
```
- **mov**: x86 的移動指令 (沒有 S，不更新旗標)
- **eax**: x86_64 的累加暫存器 (對應 ARM 的 R0)
- **0x41**: 同樣的數值
- **差異**: 指令格式完全不同，但效果相同

**JIT (Just-In-Time) 編譯**

**Just-In-Time** = **即時編譯** = **恰好在需要時**
- **J**: Just = 恰好
- **I**: In = 在
- **T**: Time = 時間
- **完整意思**: 在程式執行到某段程式碼「之前」，才進行編譯

**JIT 運作原理**:
- **第一次執行**:
  1. QEMU 看到 ARM 指令
  2. 翻譯成 x86_64 指令
  3. **儲存到快取**
  4. 執行 x86_64 指令
- **後續執行** (相同程式碼):
  1. QEMU 發現快取中已有翻譯結果
  2. **直接使用快取**
  3. 不需重新翻譯！速度快很多！

**Translation Block (TB)** = **翻譯區塊**
- **Translation**: 翻譯
- **Block**: 程式碼的一個區塊 (通常是幾條到幾十條指令)
- **定義**: QEMU 將 ARM 程式碼分成一個個小區塊，每個區塊一起翻譯
- **快取單位**: TB 是 JIT 快取的基本單位

#### ARM Cortex-M3 CPU 狀態

**通用暫存器 (General Purpose Registers)**

**Register** = **暫存器**
- **定義**: CPU 內部的高速儲存單元
- **特點**: 存取速度極快 (比記憶體快 100+ 倍)
- **數量**: ARM Cortex-M3 有 16 個 (R0-R15)
- **大小**: 每個 32 位元 (可存 4 bytes)

**R0-R12** = **一般用途暫存器**
- **用途**: 存放運算的中間結果、函式參數、區域變數等
- **範例**: R0 常用來存放函式的返回值

**R13 (SP - Stack Pointer)** = **堆疊指標**
- **SP**: Stack Pointer 的縮寫
- **Stack**: 堆疊，一種「後進先出」(LIFO) 的資料結構
- **作用**: 指向目前堆疊的「頂端」位址
- **數值 0x20010000**: SRAM 的最頂端
- **方向**: ARM 的堆疊向下成長 (位址遞減)
- **比喻**: 就像「盤子疊起來」，最後放的盤子在最上面，要拿也是先拿最上面的

**R14 (LR - Link Register)** = **連結暫存器** = **返回位址暫存器**
- **LR**: Link Register 的縮寫
- **Link**: 連結，這裡指「函式呼叫的連結」
- **作用**: 儲存函式的「返回位址」
- **使用時機**: 當執行 `BL` (Branch with Link) 指令呼叫函式時，自動將下一條指令的位址存入 LR
- **返回**: 函式結束時執行 `BX LR` 返回

**R15 (PC - Program Counter)** = **程式計數器** = **指令指標**
- **PC**: Program Counter 的縮寫
- **作用**: 永遠指向「下一條要執行的指令」的記憶體位址
- **數值 0x000001A4**: 表示 CPU 即將執行位址 0x1A4 的指令
- **自動更新**: 每執行一條指令，PC 自動遞增
- **比喻**: 就像「書籤」，告訴你現在讀到哪一頁

**狀態暫存器**

**APSR (Application Program Status Register)** = **應用程式狀態暫存器**
- **A**: Application = 應用程式
- **P**: Program = 程式
- **S**: Status = 狀態
- **R**: Register = 暫存器
- **作用**: 儲存運算結果的「狀態旗標」

**Flags: N Z C V** = **四個狀態旗標**
- **N (Negative)**: 負數旗標，結果為負數時設為 1
- **Z (Zero)**: 零旗標，結果為零時設為 1
- **C (Carry)**: 進位旗標，發生進位時設為 1
- **V (oVerflow)**: 溢位旗標，有號數溢位時設為 1

**範例**:
```
假設執行: SUBS R0, R0, R0  (R0 = R0 - R0)
結果: R0 = 0
APSR: Z = 1 (因為結果是 0)
      N = 0 (不是負數)
      C = 1 (沒有借位)
      V = 0 (沒有溢位)
```

**PRIMASK** = **優先遮罩暫存器**
- **PRI**: Priority = 優先權
- **MASK**: 遮罩
- **作用**: 可以一次性關閉所有可遮罩中斷
- **用途**: 保護關鍵程式區段不被中斷打斷

**FAULTMASK** = **錯誤遮罩暫存器**
- **FAULT**: 錯誤
- **作用**: 關閉所有中斷，只留下 NMI (不可遮罩中斷)
- **用途**: 處理嚴重錯誤時使用

**CONTROL** = **控制暫存器**
- **作用**: 控制 CPU 的執行模式
- **功能**: 選擇使用哪個堆疊 (Main Stack 或 Process Stack)

#### 記憶體模擬 (Virtual Memory)

**Virtual Memory** = **虛擬記憶體**
- **Virtual**: 虛擬的，不是真實的
- **意思**: QEMU 用「軟體模擬」的記憶體，不是真實的硬體記憶體
- **實作**: 使用 Host 電腦的 RAM 來「假裝」是 ARM 系統的 Flash 和 SRAM

**FLASH (256 KB)**

**FLASH** = **快閃記憶體** = **閃存**
- **特性**:
  - **非揮發性**: 斷電後資料不會消失
  - **唯讀** (執行時): 程式執行時不能修改
  - **用途**: 儲存程式碼和常數
- **256 KB**: 容量 = 256 × 1024 bytes = 262,144 bytes
- **位址**: 0x00000000 - 0x0003FFFF

**程式碼 (.text)**
- **.text**: 程式碼段 (text section)
- **text**: 這裡的 text 不是「文字」，而是「程式碼」的傳統稱呼
- **內容**: 編譯後的機器指令 (函式、迴圈、條件判斷等)

**常數資料 (.rodata)**
- **.rodata**: Read-Only Data (唯讀資料)
- **ro**: Read-Only = 唯讀
- **data**: 資料
- **內容**: `const` 變數、字串常數
- **範例**: `const char msg[] = "Hello";`

**中斷向量表 (Interrupt Vector Table)**
- **Interrupt**: 中斷
- **Vector**: 向量，這裡指「指向中斷處理函式的指標」
- **Table**: 表格
- **位置**: 必須在 Flash 的最開頭 (0x00000000)
- **內容**: 16 個指標，每個指向一個中斷處理函式
- **關鍵向量**:
  - [0]: 初始 SP 值
  - [1]: Reset_Handler 位址 (開機後第一個執行的函式)

**SRAM (64 KB)**

**SRAM** = **Static RAM** = **靜態隨機存取記憶體**
- **S**: Static = 靜態 (相對於 Dynamic RAM，不需定期刷新)
- **RAM**: Random Access Memory = 隨機存取記憶體
- **特性**:
  - **揮發性**: 斷電後資料消失
  - **可讀寫**: 程式執行時可以自由讀寫
  - **速度快**: 比 Flash 快
- **64 KB**: 容量 = 64 × 1024 bytes = 65,536 bytes
- **位址**: 0x20000000 - 0x2000FFFF

**全域變數 (.data)**
- **.data**: 資料段
- **內容**: 已初始化的全域變數和靜態變數
- **範例**: `int counter = 0;` (有初始值)
- **特殊處理**: 初始值存在 Flash，開機時複製到 SRAM

**未初始化變數 (.bss)**
- **.bss**: Block Started by Symbol (歷史遺留名稱)
- **內容**: 未初始化的全域變數和靜態變數
- **範例**: `int buffer[100];` (沒有給初始值)
- **優化**: 不佔 Flash 空間，開機時只需清零

**Stack (堆疊)**
- **Stack**: 堆疊
- **用途**:
  - 儲存函式的區域變數
  - 儲存函式的返回位址
  - 儲存函式參數
- **成長方向**: 向下 (位址遞減)
- **起點**: SRAM 頂端 (0x20010000)
- **比喻**: 像疊盤子，最後放的先拿出來

**Heap (堆)**
- **Heap**: 堆
- **用途**: 動態記憶體分配 (`malloc()`, `new`)
- **成長方向**: 向上 (位址遞增)
- **起點**: .bss 段之後
- **注意**: Stack 和 Heap 會「相向成長」，可能會碰撞！

#### 周邊暫存器 (Peripherals)

**Peripherals** = **周邊裝置**
- **定義**: CPU 以外的所有硬體 (UART, GPIO, Timer 等)
- **記憶體映射**: 每個周邊都被分配一個記憶體位址範圍

**MMIO (Memory-Mapped I/O)** = **記憶體映射輸入輸出**
- **Memory-Mapped**: 映射到記憶體位址
- **I/O**: Input/Output = 輸入輸出
- **原理**: 控制周邊的「暫存器」被映射到記憶體位址
- **使用**: 寫入特定位址 = 控制硬體

**UART0: 0x4000C000**
- **UART**: Universal Asynchronous Receiver-Transmitter = 通用非同步收發器
  - **Universal**: 通用的
  - **Asynchronous**: 非同步 (不需要共用時鐘訊號)
  - **Receiver**: 接收器
  - **Transmitter**: 發送器
- **作用**: 序列通訊 (Serial Communication)
- **用途**: 傳送文字訊息到電腦
- **0x4000C000**: UART0 的基底位址
- **範例**: 寫入 `*(0x4000C000) = 'A'` → 傳送字元 'A'

**GPIO: 0x40004000**
- **GPIO**: General Purpose Input/Output = 通用輸入輸出
- **作用**: 控制數位腳位 (HIGH/LOW)
- **用途**: 控制 LED、讀取按鈕等

**Timer: 0x40030000**
- **Timer**: 計時器
- **作用**: 產生定時中斷、測量時間

#### ARM 系統周邊

**NVIC (Nested Vectored Interrupt Controller)** = **巢狀向量中斷控制器**
- **Nested**: 巢狀的，中斷可以被更高優先權的中斷打斷
- **Vectored**: 向量化的，每個中斷有專屬的處理函式
- **Interrupt**: 中斷
- **Controller**: 控制器
- **作用**: 管理所有中斷的啟用、禁用、優先權

**SysTick Timer** = **系統滴答計時器**
- **Sys**: System = 系統
- **Tick**: 滴答，每隔一段時間「滴答」一下
- **作用**: 提供作業系統的時間基準
- **典型用途**: RTOS 的任務切換

#### GDB Server

**GDB** = **GNU Debugger** = **GNU 除錯器**
- **GNU**: GNU's Not Unix (自由軟體專案)
- **Debugger**: 除錯器
- **作用**: 讓開發者可以單步執行、檢查變數

**TCP Port 1234**
- **TCP**: Transmission Control Protocol = 傳輸控制協定 (可靠的網路協定)
- **Port**: 連接埠號碼
- **1234**: QEMU GDB server 的預設 port
- **連接**: GDB 客戶端透過這個 port 與 QEMU 通訊

**GDB Remote Serial Protocol** = **GDB 遠端序列協定**
- **Remote**: 遠端的
- **Serial**: 序列的
- **Protocol**: 協定
- **作用**: GDB 和 QEMU 之間的通訊協定
- **功能**: 傳送「設定中斷點」、「讀取記憶體」等命令

---

### 關鍵技術：動態二進位轉譯 (Dynamic Binary Translation)

你可能會好奇：**x86_64 CPU 如何執行 ARM 指令？**

答案是 **TCG (Tiny Code Generator)**，QEMU 的核心技術：

```
執行流程:

┌────────────────────────────────────────────────┐
│ Step 1: ARM 程式碼 (Binary)                    │
├────────────────────────────────────────────────┤
│ 0x00000100:  B508        PUSH {R3, LR}         │
│ 0x00000102:  2041        MOVS R0, #0x41        │
│ 0x00000104:  F7FF FFFE   BL   print_char       │
└────────────────────────────────────────────────┘
                    ↓
┌────────────────────────────────────────────────┐
│ Step 2: QEMU 解碼 ARM 指令                     │
├────────────────────────────────────────────────┤
│ QEMU: "這是 PUSH 指令，要推送 R3 和 LR 到堆疊"│
└────────────────────────────────────────────────┘
                    ↓
┌────────────────────────────────────────────────┐
│ Step 3: 翻譯成 TCG 中間表示 (IR)               │
├────────────────────────────────────────────────┤
│ TCG IR (與平台無關的中間語言):                 │
│   sub sp, sp, #8         ← 調整堆疊指標        │
│   store [sp+0], r3       ← 儲存 R3             │
│   store [sp+4], lr       ← 儲存 LR             │
└────────────────────────────────────────────────┘
                    ↓
┌────────────────────────────────────────────────┐
│ Step 4: TCG 產生 x86_64 機器碼                 │
├────────────────────────────────────────────────┤
│ x86_64 Assembly:                               │
│   sub rax, 8             ← 調整模擬的 SP       │
│   mov [rax], rbx         ← 儲存模擬的 R3       │
│   mov [rax+4], rcx       ← 儲存模擬的 LR       │
└────────────────────────────────────────────────┘
                    ↓
┌────────────────────────────────────────────────┐
│ Step 5: x86_64 CPU 執行產生的機器碼             │
├────────────────────────────────────────────────┤
│ 你的 Intel/AMD CPU 執行這些 x86_64 指令        │
│ 達成與 ARM CPU 相同的效果！                    │
└────────────────────────────────────────────────┘
                    ↓
┌────────────────────────────────────────────────┐
│ Step 6: 快取以提升效能                         │
├────────────────────────────────────────────────┤
│ 第一次執行: 翻譯耗時 ~100 微秒                 │
│ 後續執行: 直接使用快取 ~1 微秒                 │
│                                                │
│ Translation Block (TB) 快取:                   │
│   ARM 位址 0x100 → x86碼 0x7f8a4000           │
│   (下次執行直接跳到 0x7f8a4000)                │
└────────────────────────────────────────────────┘
```

**📖 動態二進位轉譯流程逐步解析**

讓我們深入理解上面 6 個步驟中的每一個專業術語：

#### Step 1: ARM 程式碼 (Binary)

**0x00000100** = **記憶體位址**
- **0x**: 十六進位 (hexadecimal) 的前綴
- **00000100**: 十六進位數值 = 十進位 256
- **作用**: 這條指令儲存在 Flash 記憶體的第 256 個 byte

**B508** = **ARM Thumb-2 機器碼**
- **B508**: 16 位元的機器碼 (2 個 bytes)
- **解碼結果**: PUSH {R3, LR}
- **為什麼不可讀**: 機器碼是二進位，人類無法直接閱讀

**PUSH {R3, LR}** = **將暫存器推入堆疊**
- **PUSH**: Push (推入堆疊)
- **{R3, LR}**: 大括號表示「多個暫存器」
  - **R3**: 通用暫存器 3
  - **LR**: Link Register (返回位址)
- **作用**:
  1. SP = SP - 8 (堆疊指標向下移動 8 bytes)
  2. 將 R3 的值存入 [SP+0]
  3. 將 LR 的值存入 [SP+4]
- **目的**: 在函式開始時保存暫存器，函式結束時可以還原

**2041** = **MOVS R0, #0x41 的機器碼**
- **20**: 指令的 opcode (操作碼)
- **41**: 立即值 (immediate value)
- **MOVS**: Move with Status update
- **R0**: 目標暫存器
- **#0x41**: 立即值 = 十進位 65 = ASCII 'A'

**F7FF FFFE** = **BL print_char 的機器碼**
- **F7FF FFFE**: 32 位元的機器碼 (4 bytes)
- **BL**: Branch with Link (帶連結的跳躍)
  - **Branch**: 跳躍到另一個位址
  - **Link**: 將返回位址存入 LR
- **print_char**: 目標函式名稱 (這裡是符號名稱，實際機器碼是相對偏移量)

#### Step 2: QEMU 解碼 ARM 指令

**解碼 (Decode)** = **將機器碼轉換成可理解的操作**
- **輸入**: B508 (原始 bytes)
- **輸出**: "這是 PUSH 指令，參數是 {R3, LR}"
- **過程**: QEMU 查表 (instruction decode table)，識別指令類型

**B508 解碼過程**:
```
1. 讀取前 8 位元: B5
2. 查表: B5 = PUSH 指令的前綴
3. 讀取後 8 位元: 08
4. 解析: 08 的二進位 = 00001000
   - 位元 3 = 1 → 推入 R3
   - 位元 14 (擴展位) = 0 → 不推入 R14 (LR)
   - 等等...實際更複雜
5. 結論: PUSH {R3, LR}
```

#### Step 3: 翻譯成 TCG 中間表示 (IR)

**TCG (Tiny Code Generator)** = **微型程式碼產生器**
- **Tiny**: 微小的，表示設計簡潔
- **Code Generator**: 程式碼產生器
- **作用**: QEMU 的核心元件，負責翻譯指令

**IR (Intermediate Representation)** = **中間表示**
- **Intermediate**: 中間的
- **Representation**: 表示法
- **定義**: 介於「來源語言」和「目標語言」之間的中立語言
- **類比**: 就像世界語 (Esperanto)，作為不同語言之間的橋樑
- **好處**:
  - 支援多種來源架構 (ARM, x86, RISC-V...)
  - 支援多種目標架構 (x86_64, ARM64...)
  - 只需寫 N + M 個轉換器，而不是 N × M 個

**與平台無關**:
- **意思**: TCG IR 不屬於任何特定 CPU 架構
- **好處**: 新增架構支援時，只需實作 IR → 目標架構

**sub sp, sp, #8**
- **sub**: Subtract (減法)
- **sp**: Stack Pointer (堆疊指標，這是 TCG 的虛擬暫存器)
- **#8**: 立即值 8
- **作用**: sp = sp - 8 (堆疊向下成長 8 bytes)
- **對應**: ARM 的 PUSH 第一步是調整 SP

**store [sp+0], r3**
- **store**: 儲存 (寫入記憶體)
- **[sp+0]**: 記憶體位址 = sp + 0 (堆疊頂端)
- **r3**: TCG 虛擬暫存器 (對應 ARM 的 R3)
- **作用**: 將 r3 的值寫入 [sp+0] 這個記憶體位址
- **對應**: ARM 的 PUSH 第二步是儲存 R3

**store [sp+4], lr**
- **[sp+4]**: 記憶體位址 = sp + 4 (堆疊頂端 + 4 bytes)
- **lr**: Link Register
- **作用**: 將 lr 的值寫入 [sp+4]
- **為什麼是 +4**: 因為每個暫存器 4 bytes，R3 佔 [sp+0] 到 [sp+3]，LR 從 [sp+4] 開始

#### Step 4: TCG 產生 x86_64 機器碼

**x86_64 Assembly** = **x86_64 組合語言**
- **Assembly**: 組合語言，人類可讀的機器碼表示
- **x86_64**: 目標架構 (Host CPU 的架構)

**sub rax, 8**
- **sub**: x86_64 的減法指令
- **rax**: x86_64 的 64 位元通用暫存器
  - **r**: Register
  - **a**: Accumulator (累加器)
  - **x**: Extended (64-bit 版本)
- **8**: 立即值
- **作用**: rax = rax - 8
- **對應**: QEMU 用 rax 來「模擬」ARM 的 SP

**mov [rax], rbx**
- **mov**: Move (移動，實際上是複製)
- **[rax]**: 記憶體位址 (rax 的值當作位址)
- **rbx**: x86_64 的另一個暫存器
  - **b**: Base register
- **作用**: 將 rbx 的值寫入 [rax] 指向的記憶體
- **對應**: QEMU 用 rbx 來「模擬」ARM 的 R3

**mov [rax+4], rcx**
- **rcx**: x86_64 的又一個暫存器
  - **c**: Counter register
- **[rax+4]**: 記憶體位址 = rax + 4
- **作用**: 將 rcx 的值寫入 [rax+4]
- **對應**: QEMU 用 rcx 來「模擬」ARM 的 LR

**關鍵觀念：暫存器映射**
```
ARM 暫存器 → QEMU 模擬 → x86_64 暫存器
───────────────────────────────────────
SP (R13)    →  模擬     → rax
R3          →  模擬     → rbx
LR (R14)    →  模擬     → rcx
R0          →  模擬     → rdx
...

(實際上 QEMU 可能用記憶體來存放某些暫存器，不一定都用 x86_64 暫存器)
```

#### Step 5: x86_64 CPU 執行產生的機器碼

**Intel/AMD CPU**
- **Intel**: Intel 公司 (處理器製造商)
- **AMD**: Advanced Micro Devices (另一家處理器製造商)
- **共同點**: 都實作 x86_64 指令集

**執行這些 x86_64 指令**
- **直接執行**: 不需再翻譯，因為這是 Host CPU 的原生指令
- **速度**: 接近原生速度 (有 JIT 快取的情況下)

**達成與 ARM CPU 相同的效果**
- **相同的效果**: 堆疊向下移動 8 bytes，R3 和 LR 被存入堆疊
- **不同的實作**: ARM 用 1 條 PUSH 指令，x86_64 用 3 條指令 (sub + mov + mov)
- **關鍵**: 最終結果一樣，這就是模擬的精髓！

#### Step 6: 快取以提升效能

**微秒 (microsecond)**
- **micro**: 微，代表 10^-6
- **1 微秒**: 0.000001 秒 = 百萬分之一秒
- **~100 微秒**: 大約 100 微秒 (~ 表示 approximately)

**第一次執行: 翻譯耗時 ~100 微秒**
- **包含**:
  1. 解碼 ARM 指令: ~10 微秒
  2. 產生 TCG IR: ~20 微秒
  3. TCG 產生 x86_64 機器碼: ~50 微秒
  4. 分配記憶體存放機器碼: ~10 微秒
  5. 執行 x86_64 機器碼: ~10 微秒
- **總計**: ~100 微秒

**後續執行: 直接使用快取 ~1 微秒**
- **跳過**: 所有翻譯步驟
- **直接**: 跳到已翻譯好的 x86_64 機器碼執行
- **加速**: 100 倍！

**Translation Block (TB) 快取**
- **快取 (Cache)**: 存放常用資料以加速存取
- **TB**: 一個翻譯好的程式碼區塊
- **快取結構**:
  ```
  ARM 位址 → x86_64 機器碼位址
  ─────────────────────────────
  0x100    → 0x7f8a4000
  0x200    → 0x7f8a4050
  0x300    → 0x7f8a40a0
  ...
  ```

**ARM 位址 0x100 → x86碼 0x7f8a4000**
- **0x100**: ARM 程式碼的位址 (Key 鍵)
- **→**: 映射到
- **0x7f8a4000**: 翻譯後的 x86_64 機器碼存放位址 (Value 值)
- **類比**: 就像字典，查「0x100」會得到「0x7f8a4000」

**下次執行直接跳到 0x7f8a4000**
- **過程**:
  1. QEMU: "要執行 ARM 位址 0x100"
  2. 查快取: "0x100 → 0x7f8a4000"
  3. 直接跳到 0x7f8a4000 執行 x86_64 機器碼
  4. 完成！
- **沒有快取的話**: 需要重新翻譯，慢 100 倍

**快取失效 (Cache Invalidation)**
- **何時失效**:
  - 記憶體被修改 (自我修改程式碼)
  - 快取空間不足 (LRU 清除)
- **失效後**: 需要重新翻譯

---

**類比：口譯員**

想像 ARM 程式是**日文演講稿**，x86_64 CPU 是**只聽得懂英文的聽眾**：

```
沒有 QEMU:
  日文演講稿 → x86_64 CPU 聽不懂 → ✗ 無法執行

有 QEMU (口譯員):
  日文演講稿 → QEMU 即時翻譯成英文 → x86_64 CPU 聽懂了 → ✓ 執行成功

加上快取 (筆記):
  第一次: 口譯員翻譯並寫筆記 (稍慢)
  第二次相同內容: 直接讀筆記 (超快！)
```

---

## 3. LM3S6965EVB 開發板深度解析

### 為什麼選擇 LM3S6965EVB？

```
┌────────────────────────────────────────────┐
│ 理由 1: QEMU 官方支援                       │
├────────────────────────────────────────────┤
│ QEMU 內建 LM3S6965EVB 的完整模型           │
│ 不需額外安裝硬體描述檔                     │
│                                            │
│ $ qemu-system-arm -machine help | grep lm3s│
│ lm3s6965evb    Stellaris LM3S6965EVB       │
└────────────────────────────────────────────┘

┌────────────────────────────────────────────┐
│ 理由 2: 完整的 Cortex-M3 實作               │
├────────────────────────────────────────────┤
│ • ARM Cortex-M3 核心 (ARMv7-M 架構)        │
│ • NVIC 中斷控制器                          │
│ • SysTick 計時器                           │
│ • 所有 ARM 標準周邊                        │
└────────────────────────────────────────────┘

┌────────────────────────────────────────────┐
│ 理由 3: 豐富的周邊裝置                      │
├────────────────────────────────────────────┤
│ • UART × 3 (模擬良好)                      │
│ • Timer × 4                                │
│ • GPIO × 7 ports                           │
│ • ADC (類比數位轉換器)                     │
│ • SSI (SPI)                                │
└────────────────────────────────────────────┘

┌────────────────────────────────────────────┐
│ 理由 4: 實體板子也容易取得                  │
├────────────────────────────────────────────┤
│ 學會 QEMU 模擬後，若想買實體板測試也方便   │
│ (雖然大部分時候用 QEMU 就夠了！)           │
└────────────────────────────────────────────┘
```

### 硬體規格詳細說明

```
┌─────────────────────────────────────────────────────┐
│ LM3S6965 微控制器 (MCU) 規格                        │
├─────────────────────────────────────────────────────┤
│                                                      │
│ CPU:                                                 │
│   • ARM Cortex-M3                                   │
│   • 時脈: 50 MHz (QEMU 模擬為可變速度)              │
│   • 架構: ARMv7-M (32-bit RISC)                     │
│   • 指令集: Thumb-2 (16/32-bit 混合)                │
│                                                      │
│ 記憶體:                                              │
│   • Flash ROM: 256 KB (程式碼儲存)                  │
│     └─ 位址: 0x00000000 - 0x0003FFFF                │
│   • SRAM: 64 KB (執行時資料)                        │
│     └─ 位址: 0x20000000 - 0x2000FFFF                │
│                                                      │
│ 中斷系統:                                            │
│   • NVIC (Nested Vectored Interrupt Controller)    │
│   • 支援 43 個中斷源                                │
│   • 8 級優先權                                       │
│                                                      │
│ 計時器:                                              │
│   • SysTick (系統滴答計時器)                        │
│   • 通用計時器 × 4 (Timer0-Timer3)                  │
│                                                      │
│ 串列通訊:                                            │
│   • UART0, UART1, UART2                             │
│     └─ QEMU 將 UART0 映射到終端機                   │
│   • SSI (Synchronous Serial Interface) × 2         │
│   • I²C × 2                                         │
│                                                      │
│ 數位 I/O:                                            │
│   • GPIO: Port A-G (最多 42 pins)                  │
│                                                      │
│ 類比功能:                                            │
│   • ADC: 10-bit, 4 通道                             │
│                                                      │
│ 其他:                                                │
│   • PWM (脈衝寬度調變) × 4                          │
│   • Watchdog Timer (看門狗)                         │
└─────────────────────────────────────────────────────┘
```

### 記憶體映射表 (Memory Map)

這是 **LM3S6965 記憶體的完整地圖**，理解這個對嵌入式開發非常重要！

```
記憶體位址                    區域                       大小        說明
───────────────────────────────────────────────────────────────────────────────
0x00000000 ┌────────────────────────────────────┐
           │                                    │
           │  Flash Memory (程式碼儲存區)       │  256 KB    • 程式碼 (.text)
           │                                    │            • 唯讀資料 (.rodata)
           │  非揮發性記憶體:                   │            • 中斷向量表 (位址 0x0)
           │    斷電後資料不會消失               │            • 燒錄後固定不變
           │                                    │
0x0003FFFF └────────────────────────────────────┘
0x00040000   (保留區域)
           ┊                                    ┊
0x1FFFFFFF ┊                                    ┊
0x20000000 ┌────────────────────────────────────┐
           │                                    │
           │  SRAM (靜態隨機存取記憶體)         │   64 KB    • 全域變數 (.data)
           │                                    │            • 未初始化變數 (.bss)
           │  揮發性記憶體:                     │            • Stack (堆疊，向下成長)
           │    斷電後資料消失                   │            • Heap (堆，向上成長)
           │    執行時可讀寫                     │
           │                                    │  Stack 頂端通常設在:
           │  Stack 成長方向: ↓                 │    0x20010000 (SRAM 最頂端)
           │                                    │
0x2000FFFF └────────────────────────────────────┘
0x20010000   (保留區域)
           ┊                                    ┊
0x3FFFFFFF ┊                                    ┊
0x40000000 ┌────────────────────────────────────┐
           │  周邊裝置暫存器 (Peripherals)      │   1 MB     記憶體映射 I/O (MMIO)
           │                                    │
           │  0x40004000: GPIO Port A           │            每個周邊都有專屬位址範圍
           │  0x40005000: GPIO Port B           │            寫入這些位址 = 控制硬體
           │  0x40006000: GPIO Port C           │
           │  ...                               │            範例:
           │  0x4000C000: UART0 ← 最常用！      │            UART0->DR = 'A'
           │  0x4000D000: UART1                 │            實際上是:
           │  0x4000E000: UART2                 │            *((volatile uint32_t*)0x4000C000) = 0x41
           │  ...                               │
           │  0x40030000: Timer0                │
           │  0x40031000: Timer1                │
           │  ...                               │
           │                                    │
0x40FFFFFF └────────────────────────────────────┘
0x41000000   (保留區域)
           ┊                                    ┊
0xDFFFFFFF ┊                                    ┊
0xE0000000 ┌────────────────────────────────────┐
           │  ARM Cortex-M3 系統周邊            │    1 MB    ARM 架構標準定義的區域
           │                                    │
           │  0xE000E000: System Control Block  │            所有 Cortex-M3 都一樣的位址
           │    • 0xE000E010: SysTick           │
           │    • 0xE000E100: NVIC              │            NVIC = 中斷控制器
           │    • 0xE000ED00: SCB               │            SCB = 系統控制塊
           │                                    │
           │  0xE000EF00: Debug 相關暫存器      │
           │                                    │
0xE00FFFFF └────────────────────────────────────┘
0xE0100000   (保留)
           ┊                                    ┊
0xFFFFFFFF   (記憶體空間結束)
```

**📖 記憶體映射表術語詳解**

讓我們深入解釋這張記憶體地圖中的每一個術語和概念：

#### 記憶體位址 (Memory Address)

**0x00000000**
- **0x**: 十六進位前綴
- **00000000**: 8 位十六進位數字 = 32 位元位址 (4 bytes)
- **意義**: 記憶體的最開頭，這是 ARM Cortex-M3 執行的第一個位址
- **儲存內容**: 初始 Stack Pointer (SP) 的值

**0x0003FFFF**
- **計算**: 0x40000 - 1 = 0x3FFFF
- **為什麼減 1**: 因為位址從 0 開始，256KB = 0x00000000 到 0x0003FFFF (共 0x40000 個位址)
- **意義**: Flash 的最後一個 byte

**0x20000000**
- **為什麼是這個數字**: ARM Cortex-M3 架構規範定義 SRAM 從 0x20000000 開始
- **二進位**: 0010 0000 0000 0000 0000 0000 0000 0000
- **觀察**: 只有位元 29 = 1，方便硬體解碼

#### Flash Memory 區域 (0x00000000 - 0x0003FFFF)

**Flash Memory** = **快閃記憶體**
- **程式碼儲存區**: 儲存編譯後的程式碼
- **256 KB**: Kilo-Byte (千位元組)
  - **K**: Kilo = 1024 (不是 1000！)
  - **256 KB**: 256 × 1024 = 262,144 bytes
  - **十六進位**: 0x40000 bytes

**非揮發性記憶體 (Non-Volatile Memory)**
- **Non**: 非
- **Volatile**: 揮發性
- **意思**: 斷電後資料**不會**消失
- **對比**: SRAM 是揮發性 (斷電資料消失)
- **類比**: Flash 像硬碟，SRAM 像記憶體

**斷電後資料不會消失**
- **原理**: Flash 使用「浮動閘極」技術，電子被「困在」絕緣層中
- **保存期限**: 通常 10-100 年
- **寫入次數**: 有限 (通常 10,000 - 100,000 次)

**燒錄後固定不變**
- **燒錄 (Flash/Program)**: 將程式碼寫入 Flash 的過程
- **固定**: 執行時無法修改 (需要特殊擦除/寫入程序)
- **原因**: 防止程式碼被意外修改

**程式碼 (.text)**
- **已在前面章節解釋過**，這裡補充:
- **為什麼叫 .text**: Unix 傳統，「text」指「可執行的文字」(機器碼)
- **唯讀**: 執行時 CPU 只讀取，不寫入

**唯讀資料 (.rodata)**
- **ro**: Read-Only
- **data**: Data
- **範例**:
  ```c
  const char message[] = "Hello!";  // 存在 .rodata
  const float pi = 3.14159;         // 存在 .rodata
  ```
- **優勢**: 放在 Flash 省 SRAM 空間

**中斷向量表 (位址 0x0)**
- **必須在 0x0**: ARM Cortex-M3 硬體規定，開機時從 0x0 讀取
- **內容**:
  - [0x0]: 初始 SP 值 (Stack Pointer)
  - [0x4]: Reset_Handler 位址
  - [0x8]: NMI_Handler 位址
  - [0xC]: HardFault_Handler 位址
  - ... (共 16+ 個向量)

#### 保留區域 (0x00040000 - 0x1FFFFFFF)

**保留區域 (Reserved)**
- **Reserved**: 保留的
- **意思**: 這段位址範圍沒有對應的硬體
- **讀取**: 返回未定義值 (通常是 0 或最後一次讀取的值)
- **寫入**: 無效果 (寫入被忽略)
- **大小**: 約 512 MB - 256 KB (非常大！)

**┊ (虛線)**
- **意思**: 這段區域很大，用虛線表示省略
- **為什麼這麼大**: 32 位元位址空間有 4GB，不可能全部使用

#### SRAM 區域 (0x20000000 - 0x2000FFFF)

**SRAM** = **Static RAM** = **靜態隨機存取記憶體**
- **已在前面詳細解釋**，這裡補充:
- **Random Access**: 隨機存取，任何位址存取時間相同
- **與 DRAM 的差異**:
  - **SRAM**: 使用觸發器 (flip-flop)，速度快，成本高
  - **DRAM**: 使用電容，需要定期刷新，速度慢，成本低
- **為什麼 MCU 用 SRAM**: 簡單、速度快、不需刷新電路

**64 KB**
- **計算**: 64 × 1024 = 65,536 bytes
- **十六進位**: 0x10000 bytes
- **位址範圍**: 0x20000000 到 0x2000FFFF

**揮發性記憶體 (Volatile Memory)**
- **Volatile**: 揮發性的
- **意思**: 斷電後資料立即消失
- **原因**: SRAM 使用電流維持狀態，斷電後電流消失
- **類比**: 像黑板，停電後就看不見了

**執行時可讀寫**
- **讀**: 任何時候都可以讀取
- **寫**: 任何時候都可以寫入
- **速度**: 通常幾個 CPU 時鐘週期

**Stack 成長方向: ↓**
- **↓**: 向下箭頭
- **意思**: Stack 從高位址向低位址成長
- **範例**:
  ```
  初始: SP = 0x20010000
  PUSH R0: SP = 0x2000FFFC (減少 4)
  PUSH R1: SP = 0x2000FFF8 (再減少 4)
  ```
- **為什麼向下**: ARM 架構設計，與 x86 相同

**Stack 頂端通常設在: 0x20010000**
- **0x20010000**: SRAM 結束位址 + 1
- **為什麼 +1**: Stack 第一次 PUSH 時會先減 SP，所以設在「邊界外」
- **計算**: 0x20000000 + 0x10000 = 0x20010000

#### 周邊裝置區域 (0x40000000 - 0x40FFFFFF)

**周邊裝置暫存器 (Peripherals)**
- **Peripherals**: 周邊裝置
- **範圍**: 1 MB (0x100000 bytes)
- **實際使用**: 通常只用幾十 KB，大部分是保留區域

**記憶體映射 I/O (MMIO)**
- **Memory-Mapped I/O**: 記憶體映射輸入輸出
- **原理**: 周邊的控制暫存器被「映射」到記憶體位址
- **優勢**: 使用普通的記憶體讀寫指令就能控制硬體
- **對比**: Port-Mapped I/O (x86 用 IN/OUT 指令，需要專用指令)

**每個周邊都有專屬位址範圍**
- **範例**: UART0 佔用 0x4000C000 - 0x4000CFFF (4KB)
- **結構**: 每個周邊有多個暫存器
  ```
  UART0 基底: 0x4000C000
    +0x000: DR (Data Register)           ← 資料暫存器
    +0x004: RSR/ECR (Status/Error)      ← 狀態暫存器
    +0x018: FR (Flag Register)          ← 旗標暫存器
    +0x024: IBRD (Baud Rate Divisor)    ← 鮑率除數
    +0x030: CR (Control Register)       ← 控制暫存器
    ...
  ```

**0x40004000: GPIO Port A**
- **GPIO**: General Purpose Input/Output
- **Port A**: GPIO 的 A 埠 (通常有 8 個 pins)
- **後續埠**: Port B, C, D... 每個間隔 0x1000 (4KB)

**0x4000C000: UART0 ← 最常用！**
- **UART0**: 第一個 UART (通常有 UART0, UART1, UART2)
- **最常用**: 因為除錯輸出通常用 UART0
- **QEMU 模擬**: UART0 被映射到終端機

**寫入這些位址 = 控制硬體**
- **範例**:
  ```c
  *(volatile uint32_t*)0x4000C000 = 0x41;  // 傳送 'A'
  ```
- **volatile**: 告訴編譯器「不要優化」，每次都要真的寫入
- **uint32_t***: 將位址轉型為 32 位元指標
- **0x41**: ASCII 'A'

**UART0->DR = 'A'**
- **UART0**: 結構體指標 (在 driver 中定義)
- **DR**: Data Register 欄位
- **實際上是**: 編譯器將 `UART0->DR` 轉換成 `*(0x4000C000)`

#### ARM 系統周邊區域 (0xE0000000 - 0xE00FFFFF)

**ARM Cortex-M3 系統周邊**
- **定義**: ARM 架構標準定義的周邊，所有 Cortex-M3 MCU 都一樣
- **對比**: 0x40000000 區域的周邊是「廠商特定」(LM3S6965 專屬)

**1 MB**
- **範圍**: 0xE0000000 - 0xE00FFFFF
- **計算**: 0x100000 bytes = 1 MB

**ARM 架構標準定義的區域**
- **標準**: ARM 公司在 ARMv7-M 架構規範中定義
- **好處**: 所有 Cortex-M3 MCU 的這部分都相同，驅動程式可通用

**所有 Cortex-M3 都一樣的位址**
- **範例**: STM32, NXP LPC, TI LM3S... 的 NVIC 都在 0xE000E100
- **移植性**: 寫好的 NVIC 驅動可以在所有 Cortex-M3 上使用

**0xE000E000: System Control Block (SCB)**
- **System Control Block**: 系統控制塊
- **功能**: CPU 核心的配置和狀態
- **重要暫存器**:
  - **CPUID**: CPU ID 暫存器 (識別 CPU 型號)
  - **ICSR**: 中斷控制和狀態
  - **VTOR**: 向量表偏移暫存器
  - **AIRCR**: 應用中斷和復位控制
  - **SCR**: 系統控制暫存器 (睡眠模式等)

**0xE000E010: SysTick**
- **SysTick**: System Tick Timer
- **功能**: 24 位元遞減計時器
- **用途**: RTOS 的時間片、延遲函式
- **暫存器**:
  - **CTRL**: 控制暫存器
  - **LOAD**: 重載值
  - **VAL**: 當前值
  - **CALIB**: 校準值

**0xE000E100: NVIC**
- **NVIC**: Nested Vectored Interrupt Controller
- **暫存器**: (每個 32 位元，每個位元控制一個中斷)
  - **ISER[0-7]**: Interrupt Set-Enable Registers (啟用中斷)
  - **ICER[0-7]**: Interrupt Clear-Enable Registers (禁用中斷)
  - **ISPR[0-7]**: Interrupt Set-Pending Registers (設定待處理)
  - **ICPR[0-7]**: Interrupt Clear-Pending Registers (清除待處理)
  - **IPR[0-59]**: Interrupt Priority Registers (設定優先權)

**0xE000ED00: SCB (System Control Block)**
- **注意**: 這裡的 SCB 與 0xE000E000 相關，但從 0xE000ED00 開始有更多配置暫存器
- **重要暫存器**:
  - **SHCSR**: System Handler Control and State (系統異常控制)
  - **CFSR**: Configurable Fault Status (可配置錯誤狀態)
  - **MMFAR**: MemManage Fault Address (記憶體管理錯誤位址)

**0xE000EF00: Debug 相關暫存器**
- **Debug**: 除錯
- **功能**: JTAG/SWD 除錯介面的控制
- **暫存器**: (由 ARM CoreSight 架構定義)

#### 記憶體空間結束 (0xFFFFFFFF)

**0xFFFFFFFF**
- **意義**: 32 位元位址空間的最大值
- **計算**: 2^32 - 1 = 4,294,967,295
- **十進位**: 4 GB - 1 byte
- **全 1**: 二進位 1111 1111 1111 1111 1111 1111 1111 1111

**32 位元位址空間總覽**
```
總大小: 2^32 bytes = 4 GB
  ├─ Flash: 256 KB (0.006%)
  ├─ SRAM: 64 KB (0.0015%)
  ├─ Peripherals: ~2 MB (0.05%)
  └─ Reserved: ~4 GB - 2.3 MB (99.94%)
```

**為什麼這麼多保留區域？**
- **擴展性**: 未來可能增加更多周邊
- **簡化硬體**: 位址解碼電路簡單 (檢查高位元即可)
- **標準化**: ARM 架構統一規範，所有 Cortex-M3 一致

---

### Linker Script 解讀

讓我們看看專案的 **Linker Script** (`uart_hello_world.ld`) 如何定義記憶體配置：

```ld
MEMORY
{
    FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000
    SRAM (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00010000
}
```

**逐行解釋**:

```
FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000
  │     │      │                    │
  │     │      │                    └─ 長度: 0x40000 = 256 KB
  │     │      └─ 起始位址: 0x0
  │     └─ 權限: r=可讀, x=可執行 (不可寫！)
  └─ 區域名稱: FLASH

SRAM (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00010000
  │    │       │                    │
  │    │       │                    └─ 長度: 0x10000 = 64 KB
  │    │       └─ 起始位址: 0x20000000
  │    └─ 權限: r=可讀, w=可寫, x=可執行
  └─ 區域名稱: SRAM
```

**Sections 定義**:

```ld
SECTIONS
{
    .text :
    {
        _text = .;                  ← 記錄 .text 起始位址
        KEEP(*(.isr_vector))        ← 中斷向量表 (必須在最前面!)
        *(.text*)                   ← 所有程式碼
        *(.rodata*)                 ← 唯讀資料 (const 變數)
        _etext = .;                 ← 記錄 .text 結束位址
    } > FLASH                       ← 放到 FLASH 區域

    .data : AT(ADDR(.text) + SIZEOF(.text))
    {
        _data = .;
        *(vtable)                   ← 虛擬函式表 (C++)
        *(.data*)                   ← 已初始化的全域變數
        _edata = .;
    } > SRAM                        ← 執行時在 SRAM
                                    ← 但初始值儲存在 FLASH!

    .bss :
    {
        _bss = .;
        *(.bss*)                    ← 未初始化的全域變數
        *(COMMON)
        _ebss = .;
    } > SRAM                        ← 執行時在 SRAM (不佔 FLASH 空間)
}
```

**📖 Linker Script 術語完全解析**

Linker Script 是一個充滿專業術語的腳本語言，讓我們逐一解釋：

#### MEMORY 區塊

**MEMORY** = **記憶體定義區塊**
- **作用**: 告訴 Linker (連結器) 這個系統有哪些記憶體區域
- **語法**: `MEMORY { 區域名稱 (權限) : ORIGIN = 起始位址, LENGTH = 長度 }`

**FLASH (rx)**
- **FLASH**: 區域名稱，可以自己取，習慣上用大寫
- **(rx)**: 權限旗標
  - **r**: Read (可讀)
  - **x**: eXecute (可執行)
  - **沒有 w**: 不可寫 (Write)
- **意義**: 這個區域可以讀取和執行，但不能寫入

**ORIGIN** = **起始位址**
- **ORIGIN**: 起源，這個記憶體區域的開始位址
- **= 0x00000000**: Flash 從位址 0 開始
- **為什麼是 0**: ARM Cortex-M3 規定 Flash 必須從 0x0 開始

**LENGTH** = **長度**
- **LENGTH**: 長度
- **= 0x00040000**: Flash 的大小
- **計算**:
  - **0x40000**: 十六進位
  - **= 4 × 16^4**: 4 × 65536 = 262,144
  - **= 256 KB**: 262,144 / 1024 = 256

**SRAM (rwx)**
- **SRAM**: 區域名稱
- **(rwx)**: 權限旗標
  - **r**: Read (可讀)
  - **w**: Write (可寫)
  - **x**: eXecute (可執行)
- **意義**: 這個區域可以讀、寫、執行 (完全權限)
- **注意**: 雖然有 x 權限，但通常不在 SRAM 執行程式碼

#### SECTIONS 區塊

**SECTIONS** = **段落定義區塊**
- **作用**: 定義程式的各個「段落」(Section) 要放在哪個記憶體區域
- **語法**: `SECTIONS { .段落名稱 : { 內容 } > 記憶體區域 }`

#### .text 段落

**.text** = **程式碼段**
- **點號前綴**: Section 名稱習慣以 `.` 開頭
- **.text**: 傳統名稱，代表「可執行的程式碼」
- **內容**: 所有函式的機器碼

**_text = .;**
- **_text**: 符號名稱 (Symbol)，前綴 `_` 是習慣用法
- **=**: 賦值
- **.**: 「目前位址」(Location Counter)
- **作用**: 定義一個符號 `_text`，值是目前的位址
- **用途**: startup code 可以用 `&_text` 取得 .text 段的起始位址

**KEEP(*(.isr_vector))**
- **KEEP**: 保持，告訴 Linker「不要優化掉這個段落」
  - **為什麼需要**: Linker 會移除「沒被使用」的段落
  - **中斷向量表**: 看起來沒被直接使用，但 CPU 會用，所以要 KEEP
- *****: 萬用字元，代表「所有目標檔案」
  - **範例**: main.o, uart.o, startup.o... 全部
- **(.isr_vector)**: 段落名稱
  - **isr**: Interrupt Service Routine (中斷服務例程)
  - **vector**: 向量 (指標)
- **完整意思**: 從所有目標檔中收集 .isr_vector 段，並保留不移除

**中斷向量表為什麼必須在最前面？**
```
ARM Cortex-M3 開機流程:
1. CPU 從位址 0x0 讀取初始 SP 值
2. CPU 從位址 0x4 讀取 Reset_Handler 位址
3. 跳到 Reset_Handler 開始執行

如果中斷向量表不在最前面 → CPU 讀到錯誤的值 → 系統崩潰！
```

***(.text*)**
- *****: 所有目標檔案
- **(.text*)**: 所有名稱以 .text 開頭的段落
  - **.text**: 主要程式碼
  - **.text.main**: main 函式 (某些編譯器會產生)
  - **.text.startup**: startup 程式碼
  - **.***: 萬用字元，符合任何後綴
- **作用**: 收集所有程式碼

***(.rodata*)**
- **.rodata**: Read-Only Data
- **.rodata***: 包含 .rodata, .rodata.str1.1 等
- **內容**: const 變數、字串常數

**_etext = .;**
- **_etext**: End of text (text 段結束)
- **作用**: 記錄 .text 段的結束位址
- **用途**: startup code 可以用來計算 .text 的大小

**} > FLASH**
- **}**: 結束 .text 段的定義
- **>**: 「放到」(Output to)
- **FLASH**: 前面定義的記憶體區域名稱
- **意思**: 將 .text 段放到 FLASH 記憶體

#### .data 段落

**.data** = **已初始化資料段**
- **內容**: 已初始化的全域變數和靜態變數
- **範例**: `int counter = 100;`

**AT(ADDR(.text) + SIZEOF(.text))**
- **AT**: AT address (在這個位址)
- **ADDR(.text)**: .text 段的起始位址
- **SIZEOF(.text)**: .text 段的大小
- **ADDR(.text) + SIZEOF(.text)**: .text 段的結束位址
- **完整意思**: .data 的初始值儲存在 Flash 的 .text 段之後
- **為什麼需要**: .data 執行時在 SRAM，但初始值要存在 Flash (斷電不消失)

**關鍵概念：.data 的兩個位址**
```
Load Address (LA): Flash 中的位址 (初始值儲存處)
  = ADDR(.text) + SIZEOF(.text)
  = 例如 0x00001234

Virtual Memory Address (VMA): SRAM 中的位址 (執行時位址)
  = ORIGIN(SRAM)
  = 0x20000000

開機流程:
  1. Reset_Handler 從 LA 讀取初始值
  2. 複製到 VMA
  3. 之後程式都讀寫 VMA
```

**_data = .;**
- **_data**: .data 段的起始位址 (VMA)
- **用途**: startup code 用來知道「複製到哪裡」

***(vtable)**
- **vtable**: Virtual Table (虛擬函式表)
- **C++ 專用**: C++ 的多型 (polymorphism) 需要 vtable
- **內容**: 虛擬函式的指標陣列
- **C 語言**: 這行沒有效果 (沒有 vtable 段)

**虛擬函式表範例 (C++)**:
```cpp
class Animal {
    virtual void speak() { }  // 虛擬函式
};

class Dog : public Animal {
    void speak() override { printf("Woof!\n"); }
};

// vtable 內容:
// [0] = Dog::speak 的位址
```

***(.data*)**
- **收集所有 .data 段**
- **範例**:
  ```c
  int global_var = 42;        // 放在 .data
  static int static_var = 10; // 放在 .data
  ```

**_edata = .;**
- **_edata**: End of data (.data 段結束)
- **用途**: startup code 用來知道「複製多少資料」
- **計算大小**: `_edata - _data` = .data 段的大小

**} > SRAM**
- **執行時位址** (VMA) 在 SRAM
- **但初始值** (LA) 在 FLASH (由 AT(...) 指定)

#### .bss 段落

**.bss** = **未初始化資料段**
- **BSS**: Block Started by Symbol (歷史名稱，來自 1950 年代的組譯器)
- **內容**: 未初始化的全域變數和靜態變數
- **範例**: `int buffer[1000];` (沒有給初始值)

**_bss = .;**
- **起始位址**: startup code 用來知道「從哪裡開始清零」

***(.bss*)**
- **收集所有 .bss 段**

***(COMMON)**
- **COMMON**: 共用段
- **定義**: C 語言的「tentative definition」
- **範例**:
  ```c
  int shared_var;  // 這是 tentative definition
  // 在多個檔案中都可以這樣宣告，Linker 會合併
  ```
- **現代 C**: 較少使用，但為了相容性保留

**_ebss = .;**
- **_ebss**: End of BSS
- **用途**: startup code 用來知道「清零到哪裡」
- **計算大小**: `_ebss - _bss` = .bss 段的大小

**} > SRAM**
- **執行時** (VMA) 在 SRAM
- **沒有 AT(...)**: 不需要從 Flash 複製，只需清零

**為什麼 .bss 不佔 Flash 空間？**
```
.data: 需要初始值 → Flash 儲存初始值 → 佔用 Flash
.bss: 不需要初始值 (都是 0) → Flash 不用儲存 → 省空間！

範例:
  int buffer[10000] = {0};  // 在 .data，佔用 40KB Flash
  int buffer[10000];        // 在 .bss，佔用 0 bytes Flash！
```

---

**記憶體配置視覺化**:

```
Flash (0x00000000 - 0x0003FFFF)
┌─────────────────────────────┐  ← 0x00000000
│ 中斷向量表 (.isr_vector)    │     64 bytes (16 個向量 × 4 bytes)
│   [0] = 初始 SP 值          │
│   [1] = Reset_Handler 位址  │
│   [2] = NMI_Handler 位址    │
│   ...                        │
├─────────────────────────────┤  ← 0x00000040
│ 程式碼 (.text)              │
│   main()                    │
│   print_uart0()             │
│   ...其他函式               │
├─────────────────────────────┤
│ 唯讀資料 (.rodata)          │
│   const char msg[] = "..."  │
│   const float pi = 3.14159  │
├─────────────────────────────┤  ← _etext
│ .data 的初始值 (copy)       │  ← 這段資料會在啟動時複製到 SRAM!
│   (已初始化全域變數的初始值)│
├─────────────────────────────┤
│ (未使用的 Flash)            │
│                             │
└─────────────────────────────┘  ← 0x0003FFFF

SRAM (0x20000000 - 0x2000FFFF)
┌─────────────────────────────┐  ← 0x20000000
│ .data 段 (已初始化全域變數) │  ← startup code 會從 Flash 複製過來
│   int counter = 0;          │
│   float value = 1.5;        │
├─────────────────────────────┤  ← _edata
│ .bss 段 (未初始化全域變數)  │  ← startup code 會清零
│   int buffer[100];          │
│   char name[50];            │
├─────────────────────────────┤  ← _ebss
│ Heap (動態記憶體，向上成長) │
│   malloc() 從這裡分配       │
│   ↓                         │
│   ...                       │
│   ...                       │
│   ↑                         │
│ Stack (堆疊，向下成長)      │
│   區域變數、函式呼叫        │
│   return address 都在這     │
└─────────────────────────────┘  ← 0x2000FFFF (初始 SP)
                                  ← 0x20010000 (實際最頂端)
```

**啟動流程** (Reset_Handler 做的事):

```c
// 這段程式碼在 startup_gcc.c 裡
void Reset_Handler(void)
{
    // 1. 複製 .data 段從 Flash 到 SRAM
    uint32_t *src = &_etext;         // Flash 中的初始值
    uint32_t *dest = &_data;         // SRAM 目標位址
    while (dest < &_edata) {
        *dest++ = *src++;             // 逐個複製
    }

    // 2. 清零 .bss 段
    dest = &_bss;
    while (dest < &_ebss) {
        *dest++ = 0;                  // 全部設為 0
    }

    // 3. 呼叫 main()
    main();

    // 4. main() 不應該返回，但萬一返回了就進入無窮迴圈
    while(1);
}
```

**為什麼需要複製 .data？**

```
問題: 全域變數 int counter = 100; 的初始值 100 在哪裡？

答案: 在 Flash！(因為 SRAM 會斷電清空)

編譯時:
  • counter 的初始值 100 儲存在 Flash
  • Linker 在 Flash 中預留一個 "100" 的 copy

執行時:
  • Reset_Handler 把 Flash 的 100 複製到 SRAM 的 counter 位址
  • 之後程式讀寫 counter，都是操作 SRAM 的版本
```

**類比：搬家**

```
Flash = 倉庫 (永久儲存，但無法直接使用)
  • 你的傢俱(資料)儲存在這裡
  • 不能在倉庫裡生活(不能寫入)

SRAM = 你的家 (臨時，但可以自由使用)
  • Reset_Handler = 搬家公司
  • 把倉庫(Flash)的傢俱搬到家裡(SRAM)
  • 之後你在家裡(SRAM)自由生活
  • 斷電 = 房子被拆除，傢俱消失
  • 重新上電 = 再次從倉庫搬一次
```

---

## 4. QEMU 命令完全解析

### 基本命令結構

```bash
qemu-system-arm \
    -M lm3s6965evb \
    -nographic \
    -kernel uart_hello_world.bin
```

**逐個參數詳解**:

```
qemu-system-arm
  └─ QEMU 的系統模式 ARM 模擬器
     (全名: QEMU System Emulator for ARM)

     其他變體:
       qemu-system-x86_64  ← 模擬 x86_64 系統
       qemu-system-riscv64 ← 模擬 RISC-V 系統
       qemu-arm            ← User mode (我們不用這個)

-M lm3s6965evb
  │  └─ Machine type: LM3S6965 評估板
  └─ -M 是 --machine 的縮寫

     這告訴 QEMU:
       • CPU: ARM Cortex-M3
       • 記憶體配置: 256KB Flash + 64KB SRAM
       • 周邊裝置: UART, Timer, GPIO...
       • 中斷控制器: NVIC

     查看所有支援的機器:
       $ qemu-system-arm -machine help

     查看 lm3s 系列:
       $ qemu-system-arm -machine help | grep lm3s
       lm3s6965evb    Stellaris LM3S6965EVB (Cortex-M3)
       lm3s811evb     Stellaris LM3S811EVB (Cortex-M3)

-nographic
  └─ 不啟動圖形視窗，所有輸出都到終端機

     如果不加這個參數:
       • QEMU 會開啟一個圖形視窗 (SDL/GTK)
       • 對於沒有螢幕的 MCU 來說沒意義
       • 會增加啟動時間

     加上後:
       • UART 輸出直接顯示在終端機
       • 可以用 Ctrl+C 終止
       • 適合 CI/CD 自動化

-kernel uart_hello_world.bin
  │       └─ 要載入的二進位檔案
  └─ 告訴 QEMU 將這個檔案載入到 0x00000000 (Flash 起始位址)

     QEMU 會:
       1. 讀取 uart_hello_world.bin
       2. 將內容載入到模擬的 Flash (0x0)
       3. 將 PC 設為 Reset 向量的值
       4. 開始執行

     檔案格式:
       • .bin = raw binary (純二進位)
       • .elf = 包含除錯資訊 (用於 GDB)
```

### 常用參數完整清單

```
┌──────────────────────────────────────────────────────────────┐
│ 參數                    說明                                  │
├──────────────────────────────────────────────────────────────┤
│ -M <machine>           指定機器類型                           │
│                        範例: -M lm3s6965evb                   │
├──────────────────────────────────────────────────────────────┤
│ -kernel <file>         載入 kernel/firmware 檔案              │
│                        範例: -kernel program.bin              │
├──────────────────────────────────────────────────────────────┤
│ -nographic             無圖形模式，使用終端機                 │
│                        (適合 MCU 開發)                        │
├──────────────────────────────────────────────────────────────┤
│ -serial <dev>          重定向序列埠輸出                       │
│                        範例:                                  │
│                          -serial stdio     ← 標準輸入輸出     │
│                          -serial /dev/pts/1 ← 特定終端        │
│                          -serial file:log.txt ← 寫入檔案      │
│                          -serial null      ← 丟棄輸出         │
├──────────────────────────────────────────────────────────────┤
│ -s                     啟動 GDB server (port 1234)            │
│                        等同於 -gdb tcp::1234                  │
├──────────────────────────────────────────────────────────────┤
│ -S                     啟動時暫停 (等待 GDB 連接)             │
│                        必須搭配 -s 使用                       │
├──────────────────────────────────────────────────────────────┤
│ -monitor <dev>         QEMU monitor 介面                      │
│                        範例:                                  │
│                          -monitor stdio    ← 標準輸入輸出     │
│                          -monitor telnet::4444,server,nowait  │
├──────────────────────────────────────────────────────────────┤
│ -d <options>           啟用除錯輸出                           │
│                        範例:                                  │
│                          -d in_asm        ← 顯示執行的組語    │
│                          -d cpu           ← 顯示 CPU 狀態     │
│                          -d int           ← 顯示中斷          │
│                          -d exec          ← 顯示執行流程      │
│                        多個選項: -d in_asm,cpu                │
├──────────────────────────────────────────────────────────────┤
│ -D <logfile>           將除錯輸出寫入檔案                     │
│                        範例: -D qemu.log                      │
├──────────────────────────────────────────────────────────────┤
│ -singlestep            單步執行模式 (超級慢！除錯用)         │
├──────────────────────────────────────────────────────────────┤
│ -icount shift=N        精確計時模擬                           │
│                        shift=0: 1:1 時間                      │
│                        shift=3: 8 倍慢速                      │
└──────────────────────────────────────────────────────────────┘
```

### 實用命令範例

#### 範例 1: 基本執行

```bash
qemu-system-arm \
    -M lm3s6965evb \
    -nographic \
    -kernel uart_hello_world.bin

# 輸出:
# Hello, UART World!
# Counter: 1
# Counter: 2
# ...
# (按 Ctrl+C 終止)
```

#### 範例 2: 限時執行 (CI/CD 適用)

```bash
timeout 3 qemu-system-arm \
    -M lm3s6965evb \
    -nographic \
    -kernel uart_hello_world.bin

# 3 秒後自動停止
# 適合用於自動化測試腳本
```

#### 範例 3: 輸出記錄到檔案

```bash
qemu-system-arm \
    -M lm3s6965evb \
    -nographic \
    -kernel uart_hello_world.bin \
    -serial file:output.txt

# UART 輸出會寫入 output.txt
# 終端機不會顯示 (因為被重定向了)
```

#### 範例 4: GDB 遠端除錯

```bash
# 終端 1: 啟動 QEMU GDB Server
qemu-system-arm \
    -M lm3s6965evb \
    -nographic \
    -kernel uart_hello_world.bin \
    -s \    # GDB server on port 1234
    -S      # 啟動時暫停

# 終端 2: 連接 GDB
gdb-multiarch uart_hello_world.axf

# GDB 命令:
(gdb) target remote localhost:1234    # 連接到 QEMU
(gdb) break main                       # 在 main 設中斷點
(gdb) continue                         # 繼續執行
(gdb) next                             # 單步執行
(gdb) print counter                    # 查看變數
(gdb) quit                             # 退出
```

#### 範例 5: 查看執行的組合語言

```bash
qemu-system-arm \
    -M lm3s6965evb \
    -nographic \
    -kernel uart_hello_world.bin \
    -d in_asm \
    -D qemu_trace.log

# 會將執行的 ARM 組語記錄到 qemu_trace.log
# 警告: 檔案會非常大！(每條指令都記錄)
```

**qemu_trace.log 範例內容**:

```
----------------
IN: Reset_Handler
0x00000100:  b508        push    {r3, lr}
0x00000102:  f000 f802   bl       0x10a
0x00000106:  bd08        pop     {r3, pc}

----------------
IN: main
0x0000010a:  b580        push    {r7, lr}
0x0000010c:  af00        add     r7, sp, #0
0x0000010e:  f7ff fff5   bl       0xfc
...
```

#### 範例 6: Docker 中執行 (專案腳本)

```bash
# 使用專案提供的腳本
./run-examples.sh uart

# 等同於:
docker run --rm \
    -v "$PROJECT_ROOT:/work:ro" \
    -w /work/examples/uart_hello_world/gcc \
    cmsis-lm3s-qemu:latest \
    timeout 3 qemu-system-arm \
        -M lm3s6965evb \
        -nographic \
        -kernel uart_hello_world.bin
```

### QEMU 按鍵快捷鍵

當 QEMU 在 `-nographic` 模式下執行時：

```
┌────────────────────────────────────────┐
│ 按鍵組合        功能                   │
├────────────────────────────────────────┤
│ Ctrl + C        終止 QEMU (常用！)     │
├────────────────────────────────────────┤
│ Ctrl + A, C     進入 QEMU Monitor      │
│                 (再按一次返回)         │
├────────────────────────────────────────┤
│ Ctrl + A, X     退出 QEMU              │
├────────────────────────────────────────┤
│ Ctrl + A, H     顯示說明               │
└────────────────────────────────────────┘
```

---

## 5. QEMU Monitor 深入使用

### 什麼是 QEMU Monitor？

QEMU Monitor 是 QEMU 的**內建除錯控制台**，可以：
- 檢查虛擬機狀態
- 控制執行流程
- 查看記憶體/暫存器
- 管理快照

### 進入 Monitor

**方法 1**: 使用快捷鍵 (nographic 模式下)

```
執行中按: Ctrl + A, 然後 C

你會看到:
QEMU 8.0.0 monitor - type 'help' for more information
(qemu) _
```

**方法 2**: 啟動時指定 monitor 介面

```bash
qemu-system-arm \
    -M lm3s6965evb \
    -kernel uart_hello_world.bin \
    -monitor stdio          # monitor 使用標準輸入輸出
```

### 常用 Monitor 命令

#### 檢查 CPU 暫存器

```
(qemu) info registers

顯示所有暫存器:
R00=00000041 R01=00000000 R02=00000000 R03=00000000
R04=00000000 R05=00000000 R06=00000000 R07=00000000
R08=00000000 R09=00000000 R10=00000000 R11=00000000
R12=00000000 R13=2000fff8 R14=000001a5 R15=000001a4
PSR=21000000 -Z-- A handler
```

**解讀**:

```
R13 = 2000fff8  ← Stack Pointer (堆疊指標)
R14 = 000001a5  ← Link Register (返回位址)
R15 = 000001a4  ← Program Counter (目前執行位址)

PSR = 21000000
  ├─ Z flag = 1 (上次運算結果為零)
  ├─ Mode = handler (正在執行中斷處理)
  └─ Thumb mode (Thumb 指令集模式)
```

#### 查看記憶體內容

```
(qemu) x/10xw 0x20000000

顯示從 0x20000000 開始的 10 個字 (word):
20000000: 00000000 00000001 00000000 00000000
20000010: 00000000 00000000 00000000 00000000
20000020: 00000000 00000000

格式: x/<數量><格式><大小> <位址>
  數量: 要顯示幾個單位
  格式: x=十六進位, d=十進位, s=字串
  大小: b=byte, h=halfword, w=word
```

**範例**:

```
(qemu) x/20xb 0x0    # 前 20 個 bytes (中斷向量表)
(qemu) x/4xw 0x0     # 前 4 個 words (初始 SP 和 Reset 向量)
(qemu) x/s 0x1000    # 顯示位址 0x1000 的字串
```

#### 反組譯程式碼

```
(qemu) x/10i 0x100

從 0x100 開始反組譯 10 條指令:
0x00000100:  b508        push    {r3, lr}
0x00000102:  2041        movs    r0, #65
0x00000104:  f7ff fffe   bl      0x1fc
0x00000108:  bd08        pop     {r3, pc}
0x0000010a:  b580        push    {r7, lr}
...
```

#### 控制執行

```
(qemu) stop                    # 暫停執行
(qemu) cont                    # 繼續執行
(qemu) system_reset            # 重置系統 (重新開機)
(qemu) quit                    # 退出 QEMU
```

#### 查看系統資訊

```
(qemu) info qtree              # 顯示裝置樹 (Device Tree)
(qemu) info mtree              # 顯示記憶體映射
(qemu) info pic                # 顯示中斷控制器狀態
```

**info mtree 範例輸出**:

```
memory-region: system
  0000000000000000-ffffffffffffffff (prio 0, i/o): system
    0000000000000000-000000000003ffff (prio 0, rom): lm3s6965evb.flash
    0000000020000000-000000002000ffff (prio 0, ram): lm3s6965evb.sram
    000000004000c000-000000004000cfff (prio 0, i/o): uart
```

這清楚顯示了 Flash、SRAM、UART 的記憶體映射！

---

## 6. run-examples.sh 腳本深度解析

### 腳本架構

專案提供的 [`run-examples.sh`](/home/sbplab/jiawei/qemu/CMSIS_LM3S/run-examples.sh) 是一個完整的自動化腳本，讓執行範例變得非常簡單。

### 使用方式

```bash
# 查看說明
./run-examples.sh help

# 建置 Docker image
./run-examples.sh build

# 執行 UART 範例
./run-examples.sh uart

# 執行 FIR 範例
./run-examples.sh fir

# 執行所有範例
./run-examples.sh all

# 清理 Docker image
./run-examples.sh clean
```

### 腳本內部運作

#### 1. 顏色輸出函式

```bash
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}"
}
```

這些函式讓輸出更易讀：

```
✓ Docker image 建置完成     (綠色)
✗ 找不到 uart_hello_world.bin  (紅色)
⚠ Docker image 已存在        (黃色)
```

#### 2. Docker 檢查

```bash
check_docker() {
    if ! command -v docker &> /dev/null; then
        print_error "Docker 未安裝或不在 PATH 中"
        echo "請先安裝 Docker: https://docs.docker.com/get-docker/"
        exit 1
    fi
    print_success "Docker 已安裝"
}
```

**運作原理**:

```
command -v docker
  └─ 檢查 docker 命令是否存在

&> /dev/null
  └─ 隱藏所有輸出 (標準輸出和錯誤輸出)

! ...
  └─ 否定 (如果命令不存在)

if ! command -v docker &> /dev/null; then
  └─ 如果找不到 docker → 顯示錯誤並退出
```

#### 3. 執行 UART 範例函式

```bash
run_uart_example() {
    print_header "執行 UART Hello World 範例"

    local bin_file="$PROJECT_ROOT/examples/uart_hello_world/gcc/uart_hello_world.bin"

    # 檢查檔案是否存在
    if [[ ! -f "$bin_file" ]]; then
        print_error "找不到 $bin_file"
        print_warning "請先執行 'make' 編譯專案"
        return 1
    fi

    echo -e "${YELLOW}執行中...${NC}"
    docker run --rm \
        -v "$PROJECT_ROOT:/work:ro" \
        -w /work/examples/uart_hello_world/gcc \
        "$DOCKER_IMAGE" \
        timeout 3 qemu-system-arm \
            -M lm3s6965evb \
            -nographic \
            -kernel uart_hello_world.bin 2>&1 || true

    print_success "UART 範例執行完成"
}
```

**逐行解析**:

```bash
local bin_file="$PROJECT_ROOT/examples/uart_hello_world/gcc/uart_hello_world.bin"
  └─ 定義二進位檔案路徑 (local 限定在函式內)

if [[ ! -f "$bin_file" ]]; then
  │     │  └─ 檔案路徑
  │     └─ -f 檢查是否為一般檔案
  └─ ! 否定 (檔案不存在)

docker run --rm \
  └─ --rm: 容器結束後自動刪除

-v "$PROJECT_ROOT:/work:ro" \
  │  └─ Host 路徑:Container 路徑:唯讀
  └─ 掛載專案目錄到容器的 /work

-w /work/examples/uart_hello_world/gcc \
  └─ 設定工作目錄 (容器內的路徑)

"$DOCKER_IMAGE" \
  └─ 使用的 Docker image (cmsis-lm3s-qemu:latest)

timeout 3 qemu-system-arm ...
  └─ 3 秒後自動終止 QEMU

2>&1 || true
  │    └─ 即使命令失敗也不中斷腳本 (因為 timeout 會返回非零)
  └─ 將錯誤輸出重定向到標準輸出
```

### 為什麼使用 Docker？

```
┌──────────────────────────────────────────┐
│ 好處 1: 環境一致性                        │
├──────────────────────────────────────────┤
│ 所有人執行的 QEMU 版本完全相同           │
│ 不會有「在我電腦上可以跑」的問題         │
└──────────────────────────────────────────┘

┌──────────────────────────────────────────┐
│ 好處 2: 簡化安裝                          │
├──────────────────────────────────────────┤
│ 不需要手動安裝:                           │
│   • QEMU                                 │
│   • ARM 工具鏈                           │
│   • 各種相依套件                         │
│                                          │
│ 只需安裝 Docker，一個命令搞定！           │
└──────────────────────────────────────────┘

┌──────────────────────────────────────────┐
│ 好處 3: 隔離性                            │
├──────────────────────────────────────────┤
│ QEMU 在容器內執行                         │
│ 不會污染 Host 系統                       │
│ 不同專案可以用不同版本的工具             │
└──────────────────────────────────────────┘
```

---

## 7. QEMU 與實體硬體的差異

### 完全相同的部分

```
✓ ARM Cortex-M3 指令執行邏輯
✓ 記憶體映射 (Flash 0x0, SRAM 0x20000000)
✓ UART 基本功能
✓ Timer 基本計時
✓ NVIC 中斷控制器
✓ 程式碼完全相同，無需修改！
```

### 可能不同的部分

```
⚠ 執行速度:
  • QEMU 可能比實體硬體快或慢
  • 取決於 Host CPU 性能
  • 時序敏感的程式可能需要調整

⚠ 周邊模擬精度:
  • UART: 模擬良好 ✓
  • Timer: 基本功能正常 ✓
  • GPIO: 簡化實作 (沒有真實電壓)
  • ADC: 可能返回固定值或不支援
  • PWM: 輸出波形無法測量

⚠ 中斷時序:
  • QEMU 的中斷可能不會在精確的時鐘週期觸發
  • 通常不影響功能，但高精度應用需注意

⚠ 功耗:
  • QEMU 無法模擬真實功耗
  • 低功耗模式可能無效果
```

### 開發建議

```
┌────────────────────────────────────────────┐
│ 開發階段                 建議工具           │
├────────────────────────────────────────────┤
│ 1. 初期開發               100% QEMU        │
│    • 學習基本觀念                           │
│    • 撰寫核心邏輯                           │
│    • 快速迭代除錯                           │
├────────────────────────────────────────────┤
│ 2. 功能驗證               80% QEMU          │
│    • 大部分功能測試                         │
│    • 整合測試                               │
│    • 20% 實體板驗證周邊                    │
├────────────────────────────────────────────┤
│ 3. 最終驗證               50% 實體板        │
│    • 時序敏感功能                           │
│    • ADC/PWM 實際量測                      │
│    • 功耗測試                               │
├────────────────────────────────────────────┤
│ 4. 量產測試               100% 實體板       │
│    • 長時間穩定性測試                       │
│    • 環境測試 (溫度/濕度)                  │
└────────────────────────────────────────────┘
```

**真實案例**:

> 一個學生的專題：智慧溫控風扇
>
> **階段 1 (QEMU)**:
> - 撰寫 PWM 控制邏輯
> - 溫度感測器讀取模擬
> - PID 控制演算法
> - 省下 2 週開發時間！
>
> **階段 2 (實體板)**:
> - 發現 ADC 需要校正
> - PWM 頻率需要調整避免噪音
> - 1 週完成硬體整合
>
> **總結**: QEMU 讓 80% 的工作提前完成，只有 20% 需要實體硬體

---

## 8. 進階技巧

### 技巧 1: 自動重新編譯並執行

建立一個腳本 `dev-loop.sh`:

```bash
#!/bin/bash
# 自動重新編譯並執行的開發迴圈

cd examples/uart_hello_world/gcc

while true; do
    echo "編譯中..."
    make clean && make

    if [ $? -eq 0 ]; then
        echo "執行 QEMU..."
        timeout 3 qemu-system-arm \
            -M lm3s6965evb \
            -nographic \
            -kernel uart_hello_world.bin
    else
        echo "編譯失敗！"
    fi

    echo ""
    echo "按 Enter 重新編譯，Ctrl+C 退出..."
    read
done
```

使用:

```bash
chmod +x dev-loop.sh
./dev-loop.sh

# 修改程式碼 → 按 Enter → 立即看到結果！
```

### 技巧 2: 比較輸出與預期結果

適合自動化測試：

```bash
#!/bin/bash
# test-uart.sh - 測試 UART 輸出是否正確

EXPECTED="Hello, UART World!"

ACTUAL=$(timeout 1 qemu-system-arm \
    -M lm3s6965evb \
    -nographic \
    -kernel uart_hello_world.bin 2>&1 | head -n 1)

if [ "$ACTUAL" = "$EXPECTED" ]; then
    echo "✓ 測試通過！"
    exit 0
else
    echo "✗ 測試失敗！"
    echo "預期: $EXPECTED"
    echo "實際: $ACTUAL"
    exit 1
fi
```

### 技巧 3: QEMU 效能分析

使用 `-icount` 進行精確計時：

```bash
qemu-system-arm \
    -M lm3s6965evb \
    -nographic \
    -kernel program.bin \
    -icount shift=0 \       # 1:1 時間模擬
    -d exec,cpu \           # 記錄執行
    -D trace.log

# 分析 trace.log 可以:
#   • 計算執行的指令數
#   • 分析效能瓶頸
#   • 估算真實硬體執行時間
```

### 技巧 4: 整合到 CI/CD (GitHub Actions)

在 `.github/workflows/test.yml`:

```yaml
name: QEMU Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Build Docker image
        run: docker build -t cmsis-lm3s-qemu .

      - name: Compile examples
        run: make

      - name: Run UART test
        run: |
          timeout 3 docker run --rm \
            -v $PWD:/work:ro \
            -w /work/examples/uart_hello_world/gcc \
            cmsis-lm3s-qemu \
            qemu-system-arm -M lm3s6965evb -nographic -kernel uart_hello_world.bin

      - name: Run FIR test
        run: |
          timeout 3 docker run --rm \
            -v $PWD:/work:ro \
            -w /work/examples/arm_fir_example/gcc \
            cmsis-lm3s-qemu \
            qemu-system-arm -M lm3s6965evb -nographic -kernel arm_fir_example_f32.bin

# 每次 push 都會自動測試所有範例！
```

---

## 📝 實作練習

### 練習 1: 基本執行 (簡單)

**目標**: 直接使用 QEMU 執行 UART 範例

```bash
# Step 1: 進入範例目錄
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/gcc

# Step 2: 確認檔案存在
ls -lh uart_hello_world.bin

# Step 3: 執行 QEMU
qemu-system-arm -M lm3s6965evb -nographic -kernel uart_hello_world.bin

# Step 4: 觀察輸出 (應該看到 "Hello, UART World!")

# Step 5: 按 Ctrl+C 終止
```

**預期輸出**:

```
Hello, UART World!
Counter: 1
Counter: 2
Counter: 3
...
^C
```

<details>
<summary>💡 點擊查看詳解</summary>

**發生了什麼？**

1. QEMU 啟動並模擬 LM3S6965EVB 開發板
2. 載入 `uart_hello_world.bin` 到 Flash (0x0)
3. CPU 從 Reset 向量開始執行
4. 程式初始化 UART0
5. 迴圈中不斷輸出訊息
6. QEMU 將 UART0 輸出重定向到終端機

**如果沒有輸出？**

檢查:
- 檔案路徑是否正確？
- 是否忘記加 `-nographic`？(沒加會開視窗)
- 是否 QEMU 版本太舊？(建議 5.0+)

</details>

---

### 練習 2: 使用 timeout 限時執行 (簡單)

**目標**: 讓程式自動停止，不需手動 Ctrl+C

```bash
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/gcc

# 執行 3 秒後自動停止
timeout 3 qemu-system-arm -M lm3s6965evb -nographic -kernel uart_hello_world.bin

# 觀察: 3 秒後自動返回 shell
```

**挑戰**: 修改為執行 10 秒

<details>
<summary>💡 點擊查看解答</summary>

```bash
timeout 10 qemu-system-arm -M lm3s6965evb -nographic -kernel uart_hello_world.bin
```

**`timeout` 的其他用法**:

```bash
timeout 5s  ...      # 5 秒 (預設單位)
timeout 2m  ...      # 2 分鐘
timeout 0.5 ...      # 0.5 秒

timeout --signal=TERM 5 ...   # 使用 SIGTERM (預設)
timeout --signal=KILL 5 ...   # 使用 SIGKILL (強制)
```

</details>

---

### 練習 3: 輸出重定向到檔案 (中等)

**目標**: 將 UART 輸出儲存到檔案

```bash
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/gcc

# 執行並將輸出寫入檔案
timeout 2 qemu-system-arm \
    -M lm3s6965evb \
    -nographic \
    -kernel uart_hello_world.bin \
    -serial file:output.txt

# 檢查檔案內容
cat output.txt

# 應該看到 "Hello, UART World!" 和計數
```

**挑戰**: 執行 FIR 範例並儲存輸出

<details>
<summary>💡 點擊查看解答</summary>

```bash
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/arm_fir_example/gcc

timeout 3 qemu-system-arm \
    -M lm3s6965evb \
    -nographic \
    -kernel arm_fir_example_f32.bin \
    -serial file:fir_output.txt

cat fir_output.txt
```

**預期輸出**:

```
GOOD
(或 BAD，如果 SNR 測試失敗)
```

**延伸**: 比較 FIR 輸出

```bash
# 執行多次並比較
timeout 2 qemu-system-arm ... -serial file:output1.txt
timeout 2 qemu-system-arm ... -serial file:output2.txt

diff output1.txt output2.txt
# 應該完全相同 (確定性執行)
```

</details>

---

### 練習 4: 使用 QEMU Monitor (中等)

**目標**: 在執行中進入 Monitor 檢查狀態

```bash
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/gcc

# Step 1: 啟動 QEMU
qemu-system-arm -M lm3s6965evb -nographic -kernel uart_hello_world.bin

# Step 2: 按 Ctrl+A, 然後 C (進入 Monitor)

# Step 3: 在 Monitor 中執行命令
(qemu) info registers        # 查看暫存器
(qemu) x/10xw 0x20000000     # 查看 SRAM 內容
(qemu) stop                  # 暫停執行
(qemu) cont                  # 繼續執行
(qemu) quit                  # 退出

# (或按 Ctrl+A, C 返回正常模式)
```

**挑戰**: 找出當前的 Stack Pointer 值

<details>
<summary>💡 點擊查看解答</summary>

```
(qemu) info registers

查看輸出中的 R13 (SP):
R13=2000fff8    ← 這就是 Stack Pointer

說明:
  • SP 通常在 SRAM 的頂端附近
  • 0x2000fff8 表示堆疊已使用了 8 bytes
    (因為 SRAM 結束於 0x20010000)
  • 每次函式呼叫，SP 會減少
```

**延伸挑戰**: 查看 Program Counter

```
(qemu) info registers

查看 R15 (PC):
R15=000001a4    ← 目前執行位址

(qemu) x/5i 0x1a4    # 反組譯目前執行的程式碼

可能看到:
0x000001a4:  f7ff fffe   bl      0x1a0
0x000001a8:  2864        cmp     r0, #100
0x000001aa:  d1f9        bne     0x1a0
...
```

</details>

---

### 練習 5: GDB 遠端除錯 (進階)

**目標**: 使用 GDB 連接 QEMU 進行單步除錯

**準備**:

```bash
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world/gcc

# 確認有 .axf 檔案 (包含除錯符號)
ls -lh uart_hello_world.axf
```

**執行**:

**終端 1** (啟動 QEMU GDB Server):

```bash
qemu-system-arm \
    -M lm3s6965evb \
    -nographic \
    -kernel uart_hello_world.bin \
    -s \    # 啟動 GDB server on port 1234
    -S      # 啟動時暫停

# 會看到:
# (無輸出，等待 GDB 連接...)
```

**終端 2** (連接 GDB):

```bash
gdb-multiarch uart_hello_world.axf

# GDB 啟動後輸入:
(gdb) target remote localhost:1234
Remote debugging using localhost:1234
0x00000000 in ?? ()

(gdb) break main
Breakpoint 1 at 0x...: file uart_hello_world.c, line ...

(gdb) continue
Continuing.

Breakpoint 1, main () at uart_hello_world.c:...
...

(gdb) next        # 單步執行
(gdb) print counter    # 查看變數
(gdb) info locals      # 查看所有區域變數
(gdb) backtrace        # 查看呼叫堆疊

(gdb) quit
```

**挑戰**: 在 `print_uart0` 函式設中斷點

<details>
<summary>💡 點擊查看解答</summary>

```gdb
# 終端 2 (GDB):
(gdb) target remote localhost:1234
(gdb) break print_uart0
Breakpoint 1 at 0x...: file uart_hello_world.c, line ...

(gdb) continue
Continuing.

Breakpoint 1, print_uart0 (s=0x... "Hello, UART World!") at uart_hello_world.c:...
...

(gdb) print s
$1 = 0x... "Hello, UART World!"

(gdb) next
... (逐行執行 while 迴圈)

(gdb) print *s
$2 = 72 'H'    ← 目前字元

(gdb) continue
... (繼續執行到下次呼叫 print_uart0)
```

**GDB 技巧**:

```gdb
# 查看 UART0 暫存器 (記憶體映射 I/O)
(gdb) x/x 0x4000C000    # UART0_DR
(gdb) x/x 0x4000C018    # UART0_FR (Flag Register)

# 查看記憶體
(gdb) x/10xw 0x20000000    # 查看 SRAM
(gdb) x/s 0x1000           # 查看字串

# 設定條件中斷點
(gdb) break print_uart0 if counter > 5
# (只在 counter > 5 時中斷)

# 設定 watchpoint (監視變數)
(gdb) watch counter
# (當 counter 改變時自動中斷)
```

</details>

---

### 練習 6: 使用專案腳本 (簡單)

**目標**: 熟悉 `run-examples.sh` 自動化腳本

```bash
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S

# 查看腳本說明
./run-examples.sh help

# 執行 UART 範例
./run-examples.sh uart

# 執行 FIR 範例
./run-examples.sh fir

# 執行所有範例
./run-examples.sh all
```

**挑戰**: 修改腳本增加 IIR 範例執行

<details>
<summary>💡 點擊查看提示</summary>

需要修改 `run-examples.sh`，參考 `run_fir_example()` 函式：

```bash
# 新增函式
run_iir_example() {
    print_header "執行 IIR 濾波器範例"

    local bin_file="$PROJECT_ROOT/examples/arm_biquad_cascade_example/gcc/arm_biquad_cascade_example_f32.bin"

    if [[ ! -f "$bin_file" ]]; then
        print_error "找不到 $bin_file"
        print_warning "請先執行 'make' 編譯專案"
        return 1
    fi

    echo -e "${YELLOW}執行中...${NC}"
    docker run --rm \
        -v "$PROJECT_ROOT:/work:ro" \
        -w /work/examples/arm_biquad_cascade_example/gcc \
        "$DOCKER_IMAGE" \
        timeout 3 qemu-system-arm \
            -M lm3s6965evb \
            -nographic \
            -kernel arm_biquad_cascade_example_f32.bin 2>&1 || true

    print_success "IIR 濾波器範例執行完成"
}

# 修改 main() 函式中的 case
case "${1:-}" in
    ...
    iir)
        build_image
        run_iir_example
        ;;
    all)
        build_image
        run_uart_example
        echo ""
        run_fir_example
        echo ""
        run_iir_example    # 新增這行
        ;;
    ...
esac
```

</details>

---

## 🔧 常見問題與解決

### 問題 1: QEMU 沒有輸出

**現象**:

```bash
$ qemu-system-arm -M lm3s6965evb -kernel uart_hello_world.bin
(開了一個視窗，但沒有終端機輸出)
```

**原因**: 忘記加 `-nographic`

**解決**:

```bash
qemu-system-arm -M lm3s6965evb -nographic -kernel uart_hello_world.bin
#                               ^^^^^^^^^^^^ 加上這個
```

---

### 問題 2: 找不到 qemu-system-arm

**現象**:

```bash
$ qemu-system-arm ...
bash: qemu-system-arm: command not found
```

**原因**: QEMU 未安裝或不在 PATH

**解決**:

```bash
# Debian/Ubuntu:
sudo apt-get update
sudo apt-get install qemu-system-arm

# Fedora/RHEL:
sudo dnf install qemu-system-arm

# macOS (Homebrew):
brew install qemu

# 驗證安裝:
qemu-system-arm --version
```

**替代方案**: 使用 Docker (推薦)

```bash
./run-examples.sh uart
# 自動使用 Docker 容器中的 QEMU
```

---

### 問題 3: GDB 無法連接

**現象**:

```gdb
(gdb) target remote localhost:1234
localhost:1234: Connection refused.
```

**原因**: QEMU 沒有啟動 GDB server

**解決**: 確認 QEMU 命令包含 `-s`:

```bash
qemu-system-arm \
    -M lm3s6965evb \
    -nographic \
    -kernel uart_hello_world.bin \
    -s    # ← 確保有這個！
    -S    # ← 啟動時暫停 (選用)
```

**檢查 GDB server 是否啟動**:

```bash
# 在另一個終端檢查 port 1234 是否被監聽
netstat -tuln | grep 1234

# 應該看到:
tcp        0      0 127.0.0.1:1234        0.0.0.0:*         LISTEN
```

---

### 問題 4: 執行速度很慢

**現象**: QEMU 執行比預期慢很多

**可能原因**:

1. **使用了 `-singlestep` 或 `-d` 除錯選項**
   ```bash
   # 移除這些選項:
   -singlestep    # ← 超級慢！
   -d in_asm      # ← 記錄所有指令，很慢
   ```

2. **Host CPU 效能不足**
   - 檢查 CPU 使用率: `top` 或 `htop`
   - 確保沒有其他程式占用 CPU

3. **Docker 在 macOS/Windows 上執行**
   - Docker Desktop 有額外的虛擬化層
   - 考慮直接安裝 QEMU (Linux 上更快)

**加速技巧**:

```bash
# 使用 KVM 加速 (僅限 Linux Host + x86_64 Guest)
# (不適用於 ARM guest，此技巧不適合本專案)

# 減少輸出
-serial null    # 丟棄 UART 輸出 (測試效能時)
```

---

### 問題 5: 程式無限迴圈，無法退出

**現象**: 程式一直執行，Ctrl+C 無效

**原因**: Docker 容器可能沒有正確處理訊號

**解決**:

```bash
# 方法 1: 使用 timeout (推薦)
timeout 3 qemu-system-arm ...

# 方法 2: 強制終止
# 在另一個終端:
docker ps         # 找到容器 ID
docker kill <container_id>

# 方法 3: 使用 Ctrl+A, X
# (QEMU 的退出快捷鍵)
```

---

### 問題 6: Docker 權限錯誤

**現象**:

```bash
$ docker run ...
permission denied while trying to connect to the Docker daemon socket
```

**原因**: 當前使用者不在 `docker` 群組

**解決**:

```bash
# 方法 1: 將使用者加入 docker 群組 (推薦)
sudo usermod -aG docker $USER

# 登出後重新登入
# 或執行:
newgrp docker

# 方法 2: 使用 sudo (不推薦)
sudo docker run ...
```

---

## 🎯 學習檢查點

完成本模組後，你應該能夠：

**基礎知識**:
- [ ] 解釋 QEMU 的作用與優勢
- [ ] 說明動態二進位轉譯 (DBT) 的原理
- [ ] 理解 LM3S6965EVB 的硬體規格
- [ ] 繪製記憶體映射圖

**實作技能**:
- [ ] 使用 `qemu-system-arm` 執行 ARM 程式
- [ ] 正確使用 `-M`, `-nographic`, `-kernel` 參數
- [ ] 使用 `timeout` 限時執行
- [ ] 將 UART 輸出重定向到檔案

**進階技能**:
- [ ] 進入 QEMU Monitor 並執行命令
- [ ] 檢查 CPU 暫存器與記憶體
- [ ] 設定 QEMU GDB Server
- [ ] 使用 GDB 進行遠端除錯
- [ ] 使用專案的 `run-examples.sh` 腳本
- [ ] 理解 Linker Script 的記憶體配置

**除錯能力**:
- [ ] 診斷常見 QEMU 執行問題
- [ ] 解決 GDB 連接問題
- [ ] 分析程式的執行流程

---

## 📚 延伸學習資源

### 官方文件

- [QEMU 官方文件](https://www.qemu.org/docs/master/)
- [QEMU System Emulation](https://www.qemu.org/docs/master/system/index.html)
- [QEMU ARM System Emulation](https://www.qemu.org/docs/master/system/target-arm.html)

### 進階主題

1. **QEMU 內部運作**:
   - TCG (Tiny Code Generator) 原理
   - Translation Block 快取機制
   - QEMU Object Model (QOM)

2. **客製化 QEMU**:
   - 新增自訂周邊裝置
   - 修改記憶體映射
   - 實作自訂的 Machine Type

3. **QEMU 效能最佳化**:
   - 使用 QEMU 的 profiling 工具
   - 分析 Translation Block 統計
   - 減少 context switch

### 相關工具

- **QEMU Monitor Protocol (QMP)**: 以 JSON 格式控制 QEMU
- **libvirt**: 虛擬機管理工具 (可管理 QEMU)
- **virsh**: libvirt 的命令列工具

---

## 🔗 與其他模組的關聯

```
[模組 09: Docker]
     │
     │ 提供執行環境
     ↓
[模組 10: QEMU] ← 你在這裡
     │
     │ 提供除錯介面
     ↓
[模組 11: GDB 除錯器]
     │
     │ 需要理解編譯產物
     ↓
[模組 01-04: 編譯工具鏈]
```

**學習路徑建議**:

1. **已完成**: 模組 01-09 (環境設定、Docker)
2. **當前**: 模組 10 (QEMU 模擬器)
3. **接下來**: 模組 11 (GDB 除錯器) - 深入學習如何搭配 QEMU 除錯

---

## 🔗 下一步

恭喜完成 QEMU 模擬器模組！

你現在已經學會如何：
- ✅ 在沒有實體硬體的情況下執行 ARM 程式
- ✅ 使用 QEMU 快速測試與驗證程式
- ✅ 檢查 CPU 狀態與記憶體內容
- ✅ 為 GDB 除錯做好準備

**下一個模組**: [模組 11：GDB 除錯器](11-GDB除錯器.md)

在下一個模組中，你將學習：
- 使用 GDB 進行原始碼級別的除錯
- 設定中斷點、單步執行、查看變數
- 分析程式的執行流程
- 診斷與修復常見的 Bug

**繼續加油！**

---

**版本**: 2.0 | **日期**: 2025-11-16
**作者**: Claude (Anthropic) | **授權**: MIT
**更新日誌**:
- v2.0 (2025-11-16): 完整改版，新增大量白話文解釋與生活類比
- v1.0 (2025-11-16): 初版建立
