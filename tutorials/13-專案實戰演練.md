# 模組 13：專案實戰演練

> 整合所有學過的知識：完整開發流程

## 📌 學習目標
- ✅ 整合所有模組知識
- ✅ 從零開始建置專案
- ✅ 完整除錯流程
- ✅ 效能分析與最佳化

## 1. 專案總覽（我們的專案長什麼樣子？）

想像這個專案就像一個工具箱，裡面有很多東西：

```
CMSIS_LM3S 專案架構
┌────────────────────────────────────────────────────┐
│                                                      │
│  📁 CMSIS/                                          │
│     「工具庫」- 別人寫好的程式碼，我們可以直接用    │
│     ├── Include/                                    │
│     │   標頭檔（.h 檔案）- 就像是使用說明書          │
│     │   arm_math.h - 數學函數的說明                 │
│     │   core_cm3.h - CPU 功能的說明                 │
│     │                                                │
│     └── DSP_Lib/                                    │
│         271 個現成的訊號處理函數                     │
│         （濾波、FFT、統計等，都幫你寫好了！）        │
│                                                      │
│  📁 lm3s/                                           │
│     「晶片說明書」- 告訴我們晶片有哪些功能            │
│     GPIO、UART、Timer 怎麼用                        │
│                                                      │
│  📁 examples/                                       │
│     「範例程式」- 可以直接執行的例子                 │
│     ├── uart_hello_world/                           │
│     │   最簡單的例子：印出 "Hello World"             │
│     │                                                │
│     └── arm_fir_example/                            │
│         濾波器例子：處理訊號                         │
│                                                      │
│  📄 Dockerfile                                      │
│     「QEMU 環境設定檔」- 設定模擬器環境              │
│                                                      │
│  📄 Dockerfile.gdb                                  │
│     「除錯環境設定檔」- 設定除錯工具環境             │
│                                                      │
│  📄 Makefile                                        │
│     「自動編譯腳本」- 一個指令就編譯所有東西         │
│                                                      │
└────────────────────────────────────────────────────┘
```

**白話說明：**
- **CMSIS/** = 別人寫好的工具，我們直接用
- **lm3s/** = 晶片的使用說明書
- **examples/** = 可以執行的範例程式
- **Dockerfile** = 設定執行環境的檔案
- **Makefile** = 自動化編譯的腳本

## 2. 完整開發流程（做一個專案的 8 個步驟）

開發一個嵌入式程式就像做菜，要按照順序來：

```
┌─────────────────────────────────────────────────────┐
│                                                       │
│  步驟 1: 需求分析 📋                                 │
│  ─────────────────                                   │
│  「我要做什麼？」                                     │
│  • 功能：要有什麼功能？（例如：顯示溫度）             │
│  • 速度：要多快？（例如：每秒更新 10 次）             │
│  • 記憶體：晶片夠用嗎？（我們的晶片有 64 KB）         │
│                                                       │
│           ↓                                           │
│                                                       │
│  步驟 2: 系統設計 🎨                                 │
│  ─────────────────                                   │
│  「怎麼做？」                                         │
│  • 用哪個晶片？（我們用 LM3S6965）                   │
│  • 程式架構？（main 函數 + 初始化 + 主迴圈）         │
│  • 記憶體規劃？（程式放哪、資料放哪）                 │
│                                                       │
│           ↓                                           │
│                                                       │
│  步驟 3: 寫程式 ✍️                                   │
│  ───────────────                                     │
│  「開始寫 code！」                                    │
│  • 寫 C 程式碼（uart_hello_world.c）                 │
│  • 設定 Makefile（告訴電腦怎麼編譯）                 │
│  • Linker Script（告訴程式記憶體怎麼用）             │
│  • Startup code（開機時要做的事）                    │
│                                                       │
│           ↓                                           │
│                                                       │
│  步驟 4: 編譯 🔨                                     │
│  ──────────                                          │
│  「把 C 語言翻譯成 0 和 1」                           │
│  • 執行: make                                        │
│  • 檢查有沒有錯誤                                     │
│  • 產生 .bin 檔案（晶片能執行的檔案）                 │
│                                                       │
│           ↓                                           │
│                                                       │
│  步驟 5: 測試 🧪                                     │
│  ──────────                                          │
│  「用模擬器跑跑看」                                   │
│  • 用 QEMU 模擬器執行程式                            │
│  • 看看有沒有印出 "Hello World"                      │
│  • 確認基本功能正常                                   │
│                                                       │
│           ↓                                           │
│                                                       │
│  步驟 6: 除錯 🔍                                     │
│  ──────────                                          │
│  「有 bug！找出來修正」                               │
│  • 用 GDB 除錯器                                     │
│  • 一步一步執行程式                                   │
│  • 檢查變數的值對不對                                 │
│  • 修正 bug                                          │
│                                                       │
│           ↓                                           │
│                                                       │
│  步驟 7: 最佳化 ⚡                                   │
│  ───────────────                                     │
│  「讓程式跑更快！」                                   │
│  • 找出哪裡慢                                         │
│  • 用編譯器最佳化（-O2）                             │
│  • 用更快的函數（CMSIS-DSP）                         │
│                                                       │
│           ↓                                           │
│                                                       │
│  步驟 8: 部署 🚀                                     │
│  ──────────                                          │
│  「放進真的晶片！」                                   │
│  • 如果有實體晶片，燒錄進去                           │
│  • 最後測試一次                                       │
│  • 完成！🎉                                          │
│                                                       │
└─────────────────────────────────────────────────────┘
```

**重點：**
- 不能跳步驟！要按順序來
- 每個步驟都要確認沒問題才往下
- 有 bug 就回到步驟 6 除錯

---

## 3. 實戰練習 1: 從零建置 UART 範例

現在我們要實際操作一遍完整的流程！

---

### 📍 步驟 1: 進入專案目錄

```bash
cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples/uart_hello_world
```

**這在做什麼？**
- 進入 UART 範例的資料夾
- UART = 串列通訊，用來印出訊息

---

### 🧹 步驟 2: 清理舊的編譯檔案

```bash
make clean
```

**這在做什麼？**
- 刪除之前編譯產生的檔案
- 讓我們從乾淨的狀態開始

**確認清理完成：**
```bash
ls gcc/
```
- 如果沒有這個資料夾，或是資料夾是空的 → 正確！
- 如果有檔案 → 再執行一次 `make clean`

---

### 🔨 步驟 3: 編譯程式

```bash
make
```

**這在做什麼？**
- 把 C 語言翻譯成機器碼
- 產生 .bin 檔案（晶片能執行的檔案）

**你會看到：**
```
  CC    uart_hello_world.c          ← 正在編譯主程式
  CC    startup_gcc.c                ← 正在編譯開機程式
  CC    ../../lm3s/system_lm3s.c    ← 正在編譯系統設定
  LD    gcc/uart_hello_world.axf    ← 正在連結（拼裝）
  ALL IS GOOD, CHILL OUT            ← 成功！✨
```

**如果看到錯誤訊息：**
- 檢查是否安裝了 `arm-none-eabi-gcc`
- 回到前面的模組檢查環境設定

---

### 📦 步驟 4: 查看編譯出了什麼

```bash
ls -lh gcc/
```

**你會看到這些檔案：**

```
┌────────────────────────────────────────────────┐
│                                                  │
│  uart_hello_world.o                             │
│  「主程式的半成品」                              │
│  → 只有機器碼，還沒拼起來                        │
│                                                  │
│  startup_gcc.o                                  │
│  「開機程式的半成品」                            │
│  → 負責開機時的初始化                            │
│                                                  │
│  system_lm3s.o                                  │
│  「系統設定的半成品」                            │
│  → 設定 CPU 速度、記憶體等                       │
│                                                  │
│  uart_hello_world.axf  (7.3 KB)                 │
│  「完整程式（含除錯資訊）」                      │
│  → 有函式名稱、變數名稱                          │
│  → 用 GDB 除錯時需要這個                         │
│                                                  │
│  uart_hello_world.bin  (423 Bytes)              │
│  「純機器碼（給晶片執行的）」                    │
│  → 只有 0 和 1                                   │
│  → 燒進晶片或 QEMU 執行用這個                    │
│                                                  │
└────────────────────────────────────────────────┘
```

**檔案大小對比：**
- `.axf` = 7.3 KB（有除錯資訊，比較大）
- `.bin` = 423 Bytes（純機器碼，很小）

---

### 📊 步驟 5: 分析記憶體使用

```bash
arm-none-eabi-size gcc/uart_hello_world.axf
```

**這在做什麼？**
- 檢查程式用了多少記憶體
- 確保不會超過晶片的限制（64 KB）

**輸出說明：**
```
   text    data     bss     dec     hex
    512      16      64     592     250
```

**白話翻譯：**
```
┌─────────────────────────────────────────┐
│                                           │
│  text = 512 bytes                        │
│  「程式碼」- 你寫的程式翻譯成機器碼       │
│  放在 Flash（唯讀記憶體）                │
│                                           │
│  data = 16 bytes                         │
│  「已初始化的變數」                       │
│  例如: int x = 10;                       │
│  放在 RAM（可讀寫記憶體）                │
│                                           │
│  bss = 64 bytes                          │
│  「未初始化的變數」                       │
│  例如: int y;                            │
│  放在 RAM（可讀寫記憶體）                │
│                                           │
│  dec = 592 bytes                         │
│  「總共用了多少」                         │
│  = text + data + bss                     │
│                                           │
│  hex = 250                               │
│  「十六進位表示」                         │
│  592 的十六進位就是 0x250                │
│                                           │
└─────────────────────────────────────────┘
```

**記憶體夠用嗎？**
- 我們的晶片有 64 KB RAM = 65536 bytes
- 程式只用了 592 bytes
- 還剩下很多！✅

---

### ▶️ 步驟 6: 執行程式

```bash
docker run --rm \
    -v $(pwd)/../..:/work:ro \
    cmsis-lm3s-qemu:latest \
    bash -c "cd /work/examples/uart_hello_world/gcc && \
             timeout 3 qemu-system-arm -M lm3s6965evb -nographic \
                     -kernel uart_hello_world.bin"
```

**這個複雜的指令在做什麼？**

讓我們一行一行看：

```bash
docker run --rm \
```
→ 啟動一個 Docker 容器（虛擬環境）
→ `--rm` = 執行完就刪除

```bash
    -v $(pwd)/../..:/work:ro \
```
→ 把專案資料夾掛載到容器裡的 /work
→ `ro` = read-only（唯讀，不會修改你的檔案）

```bash
    cmsis-lm3s-qemu:latest \
```
→ 使用我們之前建立的 QEMU 映像檔

```bash
    bash -c "cd /work/examples/uart_hello_world/gcc && \
```
→ 在容器裡執行指令
→ 先進入 uart_hello_world 的 gcc 資料夾

```bash
             timeout 3 qemu-system-arm -M lm3s6965evb -nographic \
                     -kernel uart_hello_world.bin"
```
→ `timeout 3` = 執行 3 秒後自動停止
→ `qemu-system-arm` = QEMU ARM 模擬器
→ `-M lm3s6965evb` = 模擬 LM3S6965 開發板
→ `-nographic` = 不要開視窗，在終端機顯示
→ `-kernel uart_hello_world.bin` = 執行我們的程式

**你會看到：**
```
Hellow World?
```

**成功！程式正確執行了！** 🎉

（注意：程式裡故意拼錯 Hello，所以是 "Hellow"）

---

## 4. 實戰練習 2: 完整除錯 FIR 範例

除錯就像當偵探，要一步一步找出程式的問題在哪裡！

---

### 🎯 除錯的目標

我們要用 GDB（除錯器）來：
1. 一步一步執行程式
2. 看看變數的值對不對
3. 確認 FIR 濾波器正確運作

---

### 🖥️ 步驟 1: 啟動 GDB Server（讓 QEMU 等待除錯器連接）

```bash
docker run --rm -d \
    -v /home/sbplab/jiawei/qemu/CMSIS_LM3S:/work:ro \
    -p 1234:1234 \
    --name qemu_fir \
    cmsis-lm3s-qemu:latest \
    bash -c "cd /work/examples/arm_fir_example/gcc && \
             exec qemu-system-arm -M lm3s6965evb -nographic \
                  -kernel arm_fir_example_f32.bin -s -S"
```

**這個指令在做什麼？**

```bash
docker run --rm -d \
```
→ `-d` = 背景執行（不會佔住終端機）
→ `--rm` = 執行完就刪除

```bash
    -p 1234:1234 \
```
→ 開啟 port 1234
→ GDB 會透過這個 port 連接到 QEMU

```bash
    --name qemu_fir \
```
→ 幫這個容器取名字叫 "qemu_fir"
→ 方便我們之後管理

```bash
             exec qemu-system-arm -M lm3s6965evb -nographic \
                  -kernel arm_fir_example_f32.bin -s -S"
```
→ `-s` = 開啟 GDB server（等待除錯器連接）
→ `-S` = 啟動時暫停（等 GDB 連接後再開始）

**檢查 QEMU 是否啟動：**
```bash
docker ps
```
你應該會看到一個名叫 `qemu_fir` 的容器正在執行。

---

### 🔍 步驟 2: 啟動 GDB（連接到 QEMU）

**開啟另一個終端機**，執行：

```bash
docker run --rm -it \
    -v /home/sbplab/jiawei/qemu/CMSIS_LM3S:/work:ro \
    --network host \
    cmsis-lm3s-gdb:latest \
    bash -c "cd /work/examples/arm_fir_example/gcc && \
             gdb-multiarch arm_fir_example_f32.axf"
```

**這個指令在做什麼？**

```bash
    -it \
```
→ 互動模式（可以輸入 GDB 命令）

```bash
    --network host \
```
→ 使用主機的網路
→ 這樣才能連到 QEMU 的 port 1234

```bash
             gdb-multiarch arm_fir_example_f32.axf"
```
→ 啟動 GDB 並載入 .axf 檔案
→ .axf 有除錯符號，GDB 才能顯示函式名稱和變數名稱

---

### 🕵️ 步驟 3: GDB 除錯會話（當偵探！）

現在你會看到 GDB 的提示符號：`(gdb)`

#### 🔗 連接到 QEMU

```gdb
(gdb) target remote localhost:1234
```

**這在做什麼？**
- 連接到 QEMU（在 localhost 的 port 1234）
- GDB 和 QEMU 現在連起來了！

---

#### 🛑 在 main 函數設中斷點

```gdb
(gdb) break main
```

**什麼是中斷點？**
- 告訴程式「跑到這裡停下來」
- 就像在路上設置路障

**你會看到：**
```
Breakpoint 1 at 0x130
```
→ 中斷點設在位址 0x130（main 函數的位置）

---

#### ▶️ 開始執行程式

```gdb
(gdb) continue
```

**這在做什麼？**
- 讓程式開始執行
- 會跑到第一個中斷點（main）就停下來

**你會看到：**
```
Breakpoint 1, 0x00000130 in main ()
```
→ 程式停在 main 函數了！

---

#### 👀 查看 FIR 濾波器結構（初始化前）

```gdb
(gdb) print S
```

**這在做什麼？**
- 印出變數 `S` 的值
- `S` 是 FIR 濾波器的結構

**你會看到：**
```
$1 = {numTaps = 0, pState = 0x0, pCoeffs = 0x0}
```

**白話翻譯：**
```
┌──────────────────────────────────────────┐
│  FIR 濾波器結構 S:                        │
│                                            │
│  numTaps = 0                              │
│  「係數數量」還是 0 → 還沒初始化           │
│                                            │
│  pState = 0x0                             │
│  「狀態緩衝區指標」是 0 → 還沒初始化       │
│                                            │
│  pCoeffs = 0x0                            │
│  「係數陣列指標」是 0 → 還沒初始化         │
│                                            │
└──────────────────────────────────────────┘
```

---

#### ⏭️ 單步執行（執行下一行）

```gdb
(gdb) next
```

**這在做什麼？**
- 執行下一行程式碼
- `next` = 不進入函數內部

執行幾次 `next`，直到 FIR 濾波器初始化完成。

---

#### 👀 再次查看 FIR 結構（初始化後）

```gdb
(gdb) print S
```

**你會看到：**
```
$2 = {numTaps = 29, pState = 0x200014f0, pCoeffs = 0x20000008}
```

**白話翻譯：**
```
┌──────────────────────────────────────────┐
│  FIR 濾波器結構 S（已初始化）:            │
│                                            │
│  numTaps = 29                             │
│  「係數數量」= 29 個 ✅                    │
│                                            │
│  pState = 0x200014f0                      │
│  「狀態緩衝區」位址 ✅                     │
│                                            │
│  pCoeffs = 0x20000008                     │
│  「係數陣列」位址 ✅                       │
│                                            │
└──────────────────────────────────────────┘
```

初始化成功！✨

---

#### 🔢 查看濾波器係數

```gdb
(gdb) x/29f S.pCoeffs
```

**這個指令在做什麼？**
- `x` = examine（檢查記憶體）
- `/29f` = 顯示 29 個浮點數
- `S.pCoeffs` = 從這個位址開始

**你會看到：**
```
0x20000008: -0.0002  0.0000  0.0008  0.0021 ...
```
→ 這些是 FIR 濾波器的係數！

---

#### 🛑 在濾波函數設中斷點

```gdb
(gdb) break arm_fir_f32
(gdb) continue
```

**這在做什麼？**
- 在 `arm_fir_f32` 函數設中斷點
- 繼續執行，直到跑到這個函數

---

#### 📊 查看輸入資料

```gdb
(gdb) x/32f pSrc
```
→ 顯示 32 個浮點數（輸入訊號）

---

#### ⏩ 執行濾波函數

```gdb
(gdb) step      # 進入函數
(gdb) finish    # 執行完整個函數
```

**這在做什麼？**
- `step` = 進入函數內部
- `finish` = 執行完整個函數後停下來

---

#### 📊 查看輸出資料

```gdb
(gdb) x/32f pDst
```
→ 顯示 32 個浮點數（濾波後的訊號）

---

#### 📈 查看訊號雜訊比（SNR）

```gdb
(gdb) continue
(gdb) print snr
```

**你會看到類似：**
```
$10 = 89.123456
```
→ SNR = 訊號雜訊比
→ 數字越大 = 濾波器效果越好

---

#### 🚪 離開 GDB

```gdb
(gdb) quit
```

---

### 🧹 清理：停止 QEMU

回到另一個終端機，停止 QEMU 容器：

```bash
docker stop qemu_fir
```

**恭喜！你已經完成除錯了！** 🎉

---

## 5. 故障排除清單（遇到問題怎麼辦？）

### 😵 問題 1: 編譯失敗

**症狀：**
```
make: arm-none-eabi-gcc: command not found
```
或
```
fatal error: arm_math.h: No such file or directory
```

**檢查清單：**

```
┌────────────────────────────────────────────────┐
│                                                  │
│  ☐ arm-none-eabi-gcc 有裝嗎？                   │
│     試試看: arm-none-eabi-gcc --version         │
│     如果沒裝: sudo apt install gcc-arm-none-eabi│
│                                                  │
│  ☐ Makefile 的路徑對嗎？                        │
│     檢查 Makefile 裡的 ROOT=../..               │
│                                                  │
│  ☐ CMSIS 資料夾在嗎？                           │
│     檢查 CMSIS/Include/ 存不存在                │
│                                                  │
│  ☐ 有定義晶片型號嗎？                            │
│     Makefile 裡要有 PART=LM3S6965               │
│                                                  │
│  ☐ 有定義 ARM_MATH_CM3 嗎？                     │
│     makedefs 裡要有 -D ARM_MATH_CM3             │
│                                                  │
└────────────────────────────────────────────────┘
```

---

### 🚫 問題 2: 執行失敗

**症狀：**
```
qemu-system-arm: command not found
```
或
```
Could not open 'uart_hello_world.bin': No such file
```

**檢查清單：**

```
┌────────────────────────────────────────────────┐
│                                                  │
│  ☐ QEMU 有裝嗎？                                │
│     試試看: qemu-system-arm --version           │
│     如果用 Docker，檢查 image 存不存在：        │
│     docker images | grep cmsis-lm3s-qemu        │
│                                                  │
│  ☐ .bin 檔案存在嗎？                            │
│     檢查: ls gcc/uart_hello_world.bin           │
│     如果不存在，重新編譯: make                   │
│                                                  │
│  ☐ Docker 容器狀態正常嗎？                      │
│     檢查: docker ps -a                          │
│                                                  │
│  ☐ 路徑掛載對嗎？                               │
│     檢查 -v 參數的路徑是否正確                   │
│                                                  │
└────────────────────────────────────────────────┘
```

---

### 🔍 問題 3: 除錯失敗

**症狀：**
```
Connection refused
```
或
```
Remote debugging using localhost:1234
localhost:1234: Connection timed out.
```

**檢查清單：**

```
┌────────────────────────────────────────────────┐
│                                                  │
│  ☐ QEMU GDB Server 有啟動嗎？                   │
│     檢查: docker ps                             │
│     應該要看到 qemu_fir 容器在執行               │
│                                                  │
│  ☐ Port 1234 有開嗎？                           │
│     檢查: netstat -tlnp | grep 1234             │
│     或: ss -tlnp | grep 1234                    │
│                                                  │
│  ☐ GDB 用的檔案對嗎？                           │
│     要用 .axf（有除錯符號）                      │
│     不要用 .bin（沒有除錯符號）                  │
│                                                  │
│  ☐ 網路設定對嗎？                               │
│     GDB 容器要加 --network host                 │
│                                                  │
│  ☐ 防火牆有擋嗎？                               │
│     暫時關閉防火牆試試看                         │
│                                                  │
└────────────────────────────────────────────────┘
```

---

### 🆘 萬用除錯步驟

如果上面都檢查過還是不行：

1. **重新開始**
   ```bash
   make clean        # 清理編譯產物
   make              # 重新編譯
   ```

2. **檢查 Docker**
   ```bash
   docker ps -a      # 看所有容器
   docker stop $(docker ps -aq)  # 停止所有容器
   docker rm $(docker ps -aq)    # 刪除所有容器
   ```

3. **重新建立 Docker image**
   ```bash
   docker build -t cmsis-lm3s-qemu:latest -f Dockerfile .
   docker build -t cmsis-lm3s-gdb:latest -f Dockerfile.gdb .
   ```

4. **檢查檔案權限**
   ```bash
   ls -la gcc/
   # 確保檔案不是 root 擁有的
   ```

---

## 6. 效能最佳化技巧（讓程式跑更快！）

### ⚡ 技巧 1: 調整編譯器最佳化等級

**什麼是最佳化？**
- 編譯器可以重新排列你的程式碼
- 讓程式跑更快或更小

**三種最佳化等級：**

```
┌─────────────────────────────────────────────────┐
│                                                   │
│  -O0（不最佳化）                                 │
│  ──────────────                                  │
│  優點: 方便除錯（程式碼和你寫的一樣）            │
│  缺點: 程式碼大、執行慢                           │
│  用途: 開發階段                                   │
│                                                   │
│  範例: CFLAGS = -O0                              │
│                                                   │
├─────────────────────────────────────────────────┤
│                                                   │
│  -O2（最佳化速度）                               │
│  ────────────────                                │
│  優點: 執行速度快！                               │
│  缺點: 程式碼可能被重排，除錯困難                 │
│  用途: 發布版本                                   │
│                                                   │
│  範例: CFLAGS = -O2                              │
│                                                   │
│  效果: 程式可能快 2-5 倍！                        │
│                                                   │
├─────────────────────────────────────────────────┤
│                                                   │
│  -Os（最佳化大小）                               │
│  ────────────────                                │
│  優點: 程式碼最小                                 │
│  缺點: 速度沒有 -O2 快                            │
│  用途: 記憶體有限的晶片                           │
│                                                   │
│  範例: CFLAGS = -Os                              │
│                                                   │
│  效果: 程式可能小 20-30%！                        │
│                                                   │
└─────────────────────────────────────────────────┘
```

**怎麼改？**

編輯 `makedefs` 檔案：
```makefile
# 找到這一行：
CFLAGS=-mthumb -mcpu=cortex-m3 -O0 ...

# 改成：
CFLAGS=-mthumb -mcpu=cortex-m3 -O2 ...
#                               ↑↑
#                         改這裡！
```

---

### 📚 技巧 2: 使用 CMSIS-DSP 函數

**為什麼要用？**
- CMSIS-DSP 是別人寫好的超快函數
- 已經用組合語言最佳化過
- 比你自己寫的迴圈快很多！

**比較：**

```c
// ❌ 慢 - 自己寫迴圈
float sum = 0;
for(int i = 0; i < N; i++) {
    sum += a[i] * b[i];    // 每次都要做乘法和加法
}
```

```c
// ✅ 快 - 用 CMSIS-DSP
float sum;
arm_dot_prod_f32(a, b, N, &sum);  // 一行搞定！而且更快！
```

**速度差異：**
- 自己寫: 1000 個運算可能要 5000 個 CPU cycle
- CMSIS-DSP: 可能只要 1500 個 CPU cycle（快 3 倍！）

---

### 🔄 技巧 3: 減少函數呼叫

**為什麼函數呼叫慢？**

每次呼叫函數，CPU 要：
1. 把參數放進暫存器
2. 跳到函數位址
3. 執行函數
4. 跳回來
5. 拿回返回值

如果呼叫 1000 次，就要做這些步驟 1000 次！

**比較：**

```c
// ❌ 慢 - 呼叫 1000 次函數
for(int i = 0; i < 1000; i++) {
    result[i] = process_sample(input[i]);
    // 每次迴圈都要呼叫函數 → 慢！
}
```

```c
// ✅ 快 - 一次處理 1000 個
process_samples(input, result, 1000);
// 只呼叫一次函數 → 快！
// 函數內部用最佳化的方式處理
```

**速度差異：**
- 多次呼叫: 可能需要額外 2000 個 cycle
- 一次呼叫: 只需要額外 10 個 cycle

---

### 💡 技巧 4: 用內聯函數（進階）

**什麼是內聯函數？**
- 告訴編譯器「把函數內容直接貼到呼叫的地方」
- 省掉函數呼叫的開銷

**範例：**

```c
// 普通函數
float calculate_distance(float x, float y) {
    return arm_sqrt_f32(x*x + y*y);
}

// 呼叫時：
float dist = calculate_distance(3.0, 4.0);
// CPU 要跳到函數、執行、跳回來
```

```c
// 內聯函數
static inline float calculate_distance(float x, float y) {
//     ↑↑↑↑↑↑
//     加這個！
    return arm_sqrt_f32(x*x + y*y);
}

// 呼叫時：
float dist = calculate_distance(3.0, 4.0);
// 編譯器會把函數內容直接貼在這裡，不用跳來跳去！
```

**注意：**
- 只對小函數有用（2-3 行）
- 太大的函數不要用（會讓程式變大）

---

### 📊 效能最佳化對比表

```
┌──────────────────────────────────────────────┐
│                                                │
│  技巧                  速度提升    難度        │
│  ────────────────────  ────────    ────       │
│                                                │
│  -O2 最佳化            2-5倍       ⭐         │
│  （最簡單！只要改一行）                       │
│                                                │
│  使用 CMSIS-DSP        2-10倍      ⭐⭐       │
│  （要找對應的函數）                           │
│                                                │
│  減少函數呼叫          1.5-3倍     ⭐⭐⭐     │
│  （要重新設計程式）                           │
│                                                │
│  內聯函數              1.2-2倍     ⭐⭐⭐⭐   │
│  （要小心使用）                               │
│                                                │
└──────────────────────────────────────────────┘
```

**建議順序：**
1. 先用 `-O2`（最簡單，效果最好）
2. 再找出程式最慢的地方
3. 用 CMSIS-DSP 取代慢的計算
4. 減少不必要的函數呼叫

---

## 7. 完整檢查清單（確保一切都完成了！）

在提交專案或說「我做完了」之前，檢查這些項目：

```
┌────────────────────────────────────────────────┐
│                                                  │
│  ☐ 程式碼寫完了                                 │
│     所有功能都實作了嗎？                         │
│                                                  │
│  ☐ 編譯成功，沒有錯誤                           │
│     make 能順利完成嗎？                          │
│     有沒有紅色的 error 訊息？                    │
│                                                  │
│  ☐ 編譯沒有警告                                 │
│     有沒有黃色的 warning 訊息？                  │
│     警告也要修正！                               │
│                                                  │
│  ☐ QEMU 能正常執行                              │
│     程式在模擬器上跑得起來嗎？                   │
│     有印出預期的結果嗎？                         │
│                                                  │
│  ☐ 用 GDB 驗證過邏輯                            │
│     用除錯器檢查過變數的值嗎？                   │
│     計算結果正確嗎？                             │
│                                                  │
│  ☐ 記憶體使用合理                               │
│     用 arm-none-eabi-size 檢查過嗎？            │
│     沒有超過晶片限制嗎？                         │
│     （64 KB RAM，256 KB Flash）                 │
│                                                  │
│  ☐ 效能符合需求                                 │
│     程式夠快嗎？                                 │
│     如果慢，有最佳化過嗎？                       │
│                                                  │
│  ☐ 程式碼有註解                                 │
│     別人看得懂你的程式碼嗎？                     │
│     重要的地方有解釋嗎？                         │
│                                                  │
│  ☐ 寫了說明文件                                 │
│     有 README.md 嗎？                            │
│     說明怎麼編譯、怎麼執行嗎？                   │
│                                                  │
└────────────────────────────────────────────────┘
```

---

## 📝 最終專案練習（挑戰自己！）

### 🎯 挑戰：建立你自己的 DSP 應用

現在你已經學完所有東西了，試試看自己做一個專案！

**步驟：**

1. **建立新專案資料夾**
   ```bash
   cd /home/sbplab/jiawei/qemu/CMSIS_LM3S/examples
   mkdir my_dsp_project
   cd my_dsp_project
   ```

2. **複製範例檔案**
   ```bash
   # 複製 UART 範例的 Makefile 當範本
   cp ../uart_hello_world/Makefile .

   # 複製 Linker Script
   cp ../uart_hello_world/uart_hello_world.ld my_project.ld

   # 複製 startup code
   cp ../uart_hello_world/startup_gcc.c .
   ```

3. **寫你的程式**
   ```bash
   # 建立主程式檔案
   touch my_project.c

   # 用編輯器開啟
   nano my_project.c  # 或用 vi, vim, code
   ```

4. **修改 Makefile**
   - 把 `uart_hello_world` 改成 `my_project`
   - 如果用到 CMSIS-DSP，記得加入對應的 .c 檔案

5. **編譯**
   ```bash
   make
   ```

6. **測試**
   ```bash
   # 用 QEMU 執行
   docker run --rm \
       -v $(pwd)/../..:/work:ro \
       cmsis-lm3s-qemu:latest \
       bash -c "cd /work/examples/my_dsp_project/gcc && \
                timeout 3 qemu-system-arm -M lm3s6965evb -nographic \
                        -kernel my_project.bin"
   ```

7. **除錯**
   - 如果有問題，用 GDB 找出 bug

8. **最佳化**
   - 用 `-O2` 編譯
   - 用 CMSIS-DSP 函數

9. **寫說明文件**
   ```bash
   # 建立 README.md
   nano README.md
   ```

   **README.md 應該包含：**
   - 專案名稱和簡介
   - 功能說明
   - 如何編譯
   - 如何執行
   - 預期輸出

---

### 💡 建議的專案題目

**簡單（適合初學者）：**

1. **移動平均濾波器**
   - 功能：平滑訊號
   - 用到：`arm_mean_f32`
   - 難度：⭐

2. **最大值/最小值偵測器**
   - 功能：找出訊號的最大值和最小值
   - 用到：`arm_max_f32`, `arm_min_f32`
   - 難度：⭐

3. **訊號統計分析**
   - 功能：計算平均值、標準差
   - 用到：`arm_mean_f32`, `arm_std_f32`
   - 難度：⭐⭐

**中等（需要一些思考）：**

4. **雙 Biquad 串接濾波器**
   - 功能：兩個 Biquad 濾波器串起來
   - 用到：`arm_biquad_cascade_df1_f32`
   - 難度：⭐⭐⭐

5. **訊號放大器（帶限制）**
   - 功能：放大訊號，但不超過某個值
   - 用到：`arm_scale_f32`, `arm_clip_f32`
   - 難度：⭐⭐⭐

**進階（挑戰性）：**

6. **簡單音訊等化器**
   - 功能：3 個頻段的等化器
   - 用到：多個 Biquad 濾波器
   - 難度：⭐⭐⭐⭐

7. **FFT 頻譜分析器**
   - 功能：顯示訊號的頻率成分
   - 用到：`arm_cfft_f32`
   - 難度：⭐⭐⭐⭐⭐

---

### 📚 有用的資源

**CMSIS-DSP 函數列表：**
- FIR 濾波：`arm_fir_f32`
- IIR 濾波：`arm_biquad_cascade_df1_f32`
- FFT：`arm_cfft_f32`
- 統計：`arm_mean_f32`, `arm_std_f32`, `arm_var_f32`
- 數學：`arm_sqrt_f32`, `arm_sin_f32`, `arm_cos_f32`

**在哪裡找範例？**
- `examples/arm_fir_example/` - FIR 濾波器範例
- `CMSIS/DSP_Lib/Examples/` - 更多範例（如果有的話）

**遇到問題怎麼辦？**
1. 回去看前面的模組
2. 參考現有的範例程式
3. 用 GDB 一步一步除錯
4. 檢查 CMSIS-DSP 文件

---

## 🎯 最終學習檢查點

### 你已經學會了：

完成這整個課程後，檢查看看你是否都會了：

```
┌────────────────────────────────────────────────┐
│                                                  │
│  基礎知識                                        │
│  ────────                                        │
│  ☐ 我知道什麼是嵌入式系統                       │
│     （在小晶片上跑的程式）                       │
│                                                  │
│  ☐ 我知道編譯的流程                             │
│     （C 語言 → 組合語言 → 機器碼）              │
│                                                  │
│  ☐ 我知道什麼是交叉編譯                         │
│     （在電腦上編譯，給晶片執行）                 │
│                                                  │
├────────────────────────────────────────────────┤
│                                                  │
│  實作能力                                        │
│  ────────                                        │
│  ☐ 我會從零開始建置 ARM 專案                    │
│     （建資料夾、寫程式、設定 Makefile）         │
│                                                  │
│  ☐ 我會使用 Makefile 編譯程式                  │
│     （只要打 make 就編譯好）                     │
│                                                  │
│  ☐ 我理解記憶體怎麼用                           │
│     （Flash 放程式，RAM 放資料）                │
│                                                  │
│  ☐ 我知道晶片開機時做了什麼                     │
│     （執行 startup code → 跳到 main）           │
│                                                  │
│  ☐ 我會控制 LM3S6965 的硬體                     │
│     （GPIO、UART、Timer 等）                    │
│                                                  │
├────────────────────────────────────────────────┤
│                                                  │
│  DSP 訊號處理                                    │
│  ──────────────                                 │
│  ☐ 我會實作 FIR 濾波器                          │
│     （用 arm_fir_f32）                           │
│                                                  │
│  ☐ 我會實作 IIR 濾波器                          │
│     （用 arm_biquad_cascade_df1_f32）           │
│                                                  │
│  ☐ 我會使用 CMSIS-DSP 函式庫                    │
│     （271 個現成的函數）                         │
│                                                  │
├────────────────────────────────────────────────┤
│                                                  │
│  開發工具                                        │
│  ────────                                        │
│  ☐ 我會用 Docker 建立開發環境                   │
│     （docker build, docker run）                │
│                                                  │
│  ☐ 我會用 QEMU 模擬 ARM 硬體                    │
│     （不用買實體晶片就能測試）                   │
│                                                  │
│  ☐ 我會用 GDB 除錯 ARM 程式                     │
│     （設中斷點、單步執行、看變數）               │
│                                                  │
├────────────────────────────────────────────────┤
│                                                  │
│  進階技巧                                        │
│  ────────                                        │
│  ☐ 我會進行效能最佳化                           │
│     （用 -O2、用 CMSIS-DSP、減少函數呼叫）      │
│                                                  │
│  ☐ 我會分析記憶體使用                           │
│     （用 arm-none-eabi-size）                   │
│                                                  │
│  ☐ 我會解決常見問題                             │
│     （編譯錯誤、執行錯誤、除錯錯誤）             │
│                                                  │
└────────────────────────────────────────────────┘
```

---

## 🎉 恭喜完成！

**你已經完成了從零開始的嵌入式系統學習之旅！**

從完全不懂，到現在你已經可以：
- ✅ 寫 ARM 程式
- ✅ 編譯程式
- ✅ 在模擬器上執行
- ✅ 用除錯器找 bug
- ✅ 實作 DSP 濾波器
- ✅ 最佳化程式效能

**這些技能可以用在：**
- 🎵 音訊處理（濾波器、等化器）
- 📡 通訊系統（調變、解調）
- 🎮 遊戲開發（在小型裝置上）
- 🤖 機器人控制
- 📱 IoT 物聯網裝置

---

## 🚀 下一步建議

### 繼續學習：

1. **深入研究 DSP 演算法**
   - FFT（快速傅立葉轉換）
   - 自適應濾波器
   - 數位訊號壓縮

2. **嘗試實體硬體**
   - 買一塊 ARM 開發板（如 STM32）
   - 把程式燒進真的晶片
   - 連接感測器、馬達等

3. **學習 RTOS（即時作業系統）**
   - FreeRTOS
   - 多工處理
   - 任務排程

4. **探索更多 CMSIS 組件**
   - CMSIS-RTOS
   - CMSIS-Driver
   - CMSIS-NN（神經網路）

### 實作專案：

- 🎵 **音訊效果器**：混響、延遲、失真
- 📻 **軟體無線電**：AM/FM 調變解調
- 🎛️ **數位合成器**：產生不同波形的聲音
- 🔊 **語音辨識**：簡單的語音命令識別
- 🌡️ **感測器資料處理**：溫度、加速度濾波

---

## 💪 你現在的程度

```
┌────────────────────────────────────────┐
│                                          │
│  完全新手 ─────────────────► 你在這裡！ │
│  🐣                           💪         │
│  不懂程式                   會開發       │
│                             嵌入式系統   │
│                                          │
│  下一步 ──────────────────────────────► │
│                             專業工程師   │
│                             🚀           │
│                                          │
└────────────────────────────────────────┘
```

你已經不是新手了！繼續練習、持續學習，很快就能成為專業的嵌入式工程師！

---

**🙏 感謝你完成這個課程！**

如果你有任何問題或建議，歡迎回饋！

**祝你在嵌入式系統的世界中，玩得開心、學得愉快！** 🎉

---

**版本**: 1.0
**日期**: 2025-11-16
**作者**: Claude Code with 💙
